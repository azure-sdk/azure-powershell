// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Extensions;

    /// <summary>Describes the properties of an AssessPatches result.</summary>
    public partial class VirtualMachineAssessPatchesResult :
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResult,
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal
    {

        /// <summary>Backing field for <see cref="AssessmentActivityId" /> property.</summary>
        private string _assessmentActivityId;

        /// <summary>The activity ID of the operation that produced this result.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Owned)]
        public string AssessmentActivityId { get => this._assessmentActivityId; }

        /// <summary>Backing field for <see cref="AvailablePatchCountByClassification" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassification _availablePatchCountByClassification;

        /// <summary>
        /// Summarization of patches available for installation on the machine by classification.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassification AvailablePatchCountByClassification { get => (this._availablePatchCountByClassification = this._availablePatchCountByClassification ?? new Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.AvailablePatchCountByClassification()); set => this._availablePatchCountByClassification = value; }

        /// <summary>Number of critical patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public int? AvailablePatchCountByClassificationCritical { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Critical; }

        /// <summary>Number of definition patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public int? AvailablePatchCountByClassificationDefinition { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Definition; }

        /// <summary>Number of feature pack patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public int? AvailablePatchCountByClassificationFeaturePack { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).FeaturePack; }

        /// <summary>Number of other patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public int? AvailablePatchCountByClassificationOther { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Other; }

        /// <summary>Number of security patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public int? AvailablePatchCountByClassificationSecurity { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Security; }

        /// <summary>Number of service pack patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public int? AvailablePatchCountByClassificationServicePack { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).ServicePack; }

        /// <summary>Number of tools patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public int? AvailablePatchCountByClassificationTool { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Tool; }

        /// <summary>Number of updates category patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public int? AvailablePatchCountByClassificationUpdate { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Update; }

        /// <summary>Number of update Rollup patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public int? AvailablePatchCountByClassificationUpdateRollup { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).UpdateRollup; }

        /// <summary>Backing field for <see cref="ErrorDetail" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetail _errorDetail;

        /// <summary>
        /// The errors that were encountered during execution of the operation. The details array contains the list of them.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetail ErrorDetail { get => (this._errorDetail = this._errorDetail ?? new Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.ErrorDetail()); }

        /// <summary>The error's code.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public string ErrorDetailCode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetailInternal)ErrorDetail).Code; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetailInternal)ErrorDetail).Code = value ?? null; }

        /// <summary>A human readable error message.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public string ErrorDetailMessage { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetailInternal)ErrorDetail).Message; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetailInternal)ErrorDetail).Message = value ?? null; }

        /// <summary>Indicates which property in the request is responsible for the error.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public string ErrorDetailTarget { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetailInternal)ErrorDetail).Target; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetailInternal)ErrorDetail).Target = value ?? null; }

        /// <summary>Additional error details.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetail[] ErrorDetailsDetails { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetailInternal)ErrorDetail).Detail; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetailInternal)ErrorDetail).Detail = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="LastModifiedDateTime" /> property.</summary>
        private global::System.DateTime? _lastModifiedDateTime;

        /// <summary>The UTC timestamp when the operation finished.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Owned)]
        public global::System.DateTime? LastModifiedDateTime { get => this._lastModifiedDateTime; }

        /// <summary>Internal Acessors for AssessmentActivityId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AssessmentActivityId { get => this._assessmentActivityId; set { {_assessmentActivityId = value;} } }

        /// <summary>Internal Acessors for AvailablePatchCountByClassification</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassification Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AvailablePatchCountByClassification { get => (this._availablePatchCountByClassification = this._availablePatchCountByClassification ?? new Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.AvailablePatchCountByClassification()); set { {_availablePatchCountByClassification = value;} } }

        /// <summary>Internal Acessors for AvailablePatchCountByClassificationCritical</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AvailablePatchCountByClassificationCritical { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Critical; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Critical = value; }

        /// <summary>Internal Acessors for AvailablePatchCountByClassificationDefinition</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AvailablePatchCountByClassificationDefinition { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Definition; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Definition = value; }

        /// <summary>Internal Acessors for AvailablePatchCountByClassificationFeaturePack</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AvailablePatchCountByClassificationFeaturePack { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).FeaturePack; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).FeaturePack = value; }

        /// <summary>Internal Acessors for AvailablePatchCountByClassificationOther</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AvailablePatchCountByClassificationOther { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Other; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Other = value; }

        /// <summary>Internal Acessors for AvailablePatchCountByClassificationSecurity</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AvailablePatchCountByClassificationSecurity { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Security; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Security = value; }

        /// <summary>Internal Acessors for AvailablePatchCountByClassificationServicePack</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AvailablePatchCountByClassificationServicePack { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).ServicePack; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).ServicePack = value; }

        /// <summary>Internal Acessors for AvailablePatchCountByClassificationTool</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AvailablePatchCountByClassificationTool { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Tool; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Tool = value; }

        /// <summary>Internal Acessors for AvailablePatchCountByClassificationUpdate</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AvailablePatchCountByClassificationUpdate { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Update; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).Update = value; }

        /// <summary>Internal Acessors for AvailablePatchCountByClassificationUpdateRollup</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.AvailablePatchCountByClassificationUpdateRollup { get => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).UpdateRollup; set => ((Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassificationInternal)AvailablePatchCountByClassification).UpdateRollup = value; }

        /// <summary>Internal Acessors for ErrorDetail</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetail Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.ErrorDetail { get => (this._errorDetail = this._errorDetail ?? new Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.ErrorDetail()); set { {_errorDetail = value;} } }

        /// <summary>Internal Acessors for LastModifiedDateTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.LastModifiedDateTime { get => this._lastModifiedDateTime; set { {_lastModifiedDateTime = value;} } }

        /// <summary>Internal Acessors for OSType</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.OSTypeUm? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.OSType { get => this._oSType; set { {_oSType = value;} } }

        /// <summary>Internal Acessors for PatchServiceUsed</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchServiceUsed? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.PatchServiceUsed { get => this._patchServiceUsed; set { {_patchServiceUsed = value;} } }

        /// <summary>Internal Acessors for RebootPending</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.RebootPending { get => this._rebootPending; set { {_rebootPending = value;} } }

        /// <summary>Internal Acessors for StartDateTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.StartDateTime { get => this._startDateTime; set { {_startDateTime = value;} } }

        /// <summary>Internal Acessors for StartedBy</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStartedBy? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.StartedBy { get => this._startedBy; set { {_startedBy = value;} } }

        /// <summary>Internal Acessors for Status</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStatus? Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IVirtualMachineAssessPatchesResultInternal.Status { get => this._status; set { {_status = value;} } }

        /// <summary>Backing field for <see cref="OSType" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.OSTypeUm? _oSType;

        /// <summary>The operating system type of the machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.OSTypeUm? OSType { get => this._oSType; }

        /// <summary>Backing field for <see cref="PatchServiceUsed" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchServiceUsed? _patchServiceUsed;

        /// <summary>Specifies the patch service used for the operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchServiceUsed? PatchServiceUsed { get => this._patchServiceUsed; }

        /// <summary>Backing field for <see cref="RebootPending" /> property.</summary>
        private bool? _rebootPending;

        /// <summary>
        /// The overall reboot status of the VM. It will be true when partially installed patches require a reboot to complete installation
        /// but the reboot has not yet occurred.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Owned)]
        public bool? RebootPending { get => this._rebootPending; }

        /// <summary>Backing field for <see cref="StartDateTime" /> property.</summary>
        private global::System.DateTime? _startDateTime;

        /// <summary>The UTC timestamp when the operation began.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Owned)]
        public global::System.DateTime? StartDateTime { get => this._startDateTime; }

        /// <summary>Backing field for <see cref="StartedBy" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStartedBy? _startedBy;

        /// <summary>Indicates if operation was triggered by user or by platform.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStartedBy? StartedBy { get => this._startedBy; }

        /// <summary>Backing field for <see cref="Status" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStatus? _status;

        /// <summary>
        /// The overall success or failure status of the operation. It remains "InProgress" until the operation completes. At that
        /// point it will become "Unknown", "Failed", "Succeeded", or "CompletedWithWarnings."
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Origin(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStatus? Status { get => this._status; }

        /// <summary>Creates an new <see cref="VirtualMachineAssessPatchesResult" /> instance.</summary>
        public VirtualMachineAssessPatchesResult()
        {

        }
    }
    /// Describes the properties of an AssessPatches result.
    public partial interface IVirtualMachineAssessPatchesResult :
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.IJsonSerializable
    {
        /// <summary>The activity ID of the operation that produced this result.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The activity ID of the operation that produced this result.",
        SerializedName = @"assessmentActivityId",
        PossibleTypes = new [] { typeof(string) })]
        string AssessmentActivityId { get;  }
        /// <summary>Number of critical patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Number of critical patches available for installation.",
        SerializedName = @"critical",
        PossibleTypes = new [] { typeof(int) })]
        int? AvailablePatchCountByClassificationCritical { get;  }
        /// <summary>Number of definition patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Number of definition patches available for installation.",
        SerializedName = @"definition",
        PossibleTypes = new [] { typeof(int) })]
        int? AvailablePatchCountByClassificationDefinition { get;  }
        /// <summary>Number of feature pack patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Number of feature pack patches available for installation.",
        SerializedName = @"featurePack",
        PossibleTypes = new [] { typeof(int) })]
        int? AvailablePatchCountByClassificationFeaturePack { get;  }
        /// <summary>Number of other patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Number of other patches available for installation.",
        SerializedName = @"other",
        PossibleTypes = new [] { typeof(int) })]
        int? AvailablePatchCountByClassificationOther { get;  }
        /// <summary>Number of security patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Number of security patches available for installation.",
        SerializedName = @"security",
        PossibleTypes = new [] { typeof(int) })]
        int? AvailablePatchCountByClassificationSecurity { get;  }
        /// <summary>Number of service pack patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Number of service pack patches available for installation.",
        SerializedName = @"servicePack",
        PossibleTypes = new [] { typeof(int) })]
        int? AvailablePatchCountByClassificationServicePack { get;  }
        /// <summary>Number of tools patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Number of tools patches available for installation.",
        SerializedName = @"tools",
        PossibleTypes = new [] { typeof(int) })]
        int? AvailablePatchCountByClassificationTool { get;  }
        /// <summary>Number of updates category patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Number of updates category patches available for installation.",
        SerializedName = @"updates",
        PossibleTypes = new [] { typeof(int) })]
        int? AvailablePatchCountByClassificationUpdate { get;  }
        /// <summary>Number of update Rollup patches available for installation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Number of update Rollup patches available for installation.",
        SerializedName = @"updateRollup",
        PossibleTypes = new [] { typeof(int) })]
        int? AvailablePatchCountByClassificationUpdateRollup { get;  }
        /// <summary>The error's code.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The error's code.",
        SerializedName = @"code",
        PossibleTypes = new [] { typeof(string) })]
        string ErrorDetailCode { get; set; }
        /// <summary>A human readable error message.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A human readable error message.",
        SerializedName = @"message",
        PossibleTypes = new [] { typeof(string) })]
        string ErrorDetailMessage { get; set; }
        /// <summary>Indicates which property in the request is responsible for the error.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates which property in the request is responsible for the error.",
        SerializedName = @"target",
        PossibleTypes = new [] { typeof(string) })]
        string ErrorDetailTarget { get; set; }
        /// <summary>Additional error details.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Additional error details.",
        SerializedName = @"details",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetail) })]
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetail[] ErrorDetailsDetails { get; set; }
        /// <summary>The UTC timestamp when the operation finished.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The UTC timestamp when the operation finished.",
        SerializedName = @"lastModifiedDateTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? LastModifiedDateTime { get;  }
        /// <summary>The operating system type of the machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The operating system type of the machine.",
        SerializedName = @"osType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.OSTypeUm) })]
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.OSTypeUm? OSType { get;  }
        /// <summary>Specifies the patch service used for the operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Specifies the patch service used for the operation.",
        SerializedName = @"patchServiceUsed",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchServiceUsed) })]
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchServiceUsed? PatchServiceUsed { get;  }
        /// <summary>
        /// The overall reboot status of the VM. It will be true when partially installed patches require a reboot to complete installation
        /// but the reboot has not yet occurred.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The overall reboot status of the VM. It will be true when partially installed patches require a reboot to complete installation but the reboot has not yet occurred.",
        SerializedName = @"rebootPending",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RebootPending { get;  }
        /// <summary>The UTC timestamp when the operation began.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The UTC timestamp when the operation began.",
        SerializedName = @"startDateTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? StartDateTime { get;  }
        /// <summary>Indicates if operation was triggered by user or by platform.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Indicates if operation was triggered by user or by platform.",
        SerializedName = @"startedBy",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStartedBy) })]
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStartedBy? StartedBy { get;  }
        /// <summary>
        /// The overall success or failure status of the operation. It remains "InProgress" until the operation completes. At that
        /// point it will become "Unknown", "Failed", "Succeeded", or "CompletedWithWarnings."
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The overall success or failure status of the operation. It remains ""InProgress"" until the operation completes. At that point it will become ""Unknown"", ""Failed"", ""Succeeded"", or ""CompletedWithWarnings.""",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStatus) })]
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStatus? Status { get;  }

    }
    /// Describes the properties of an AssessPatches result.
    internal partial interface IVirtualMachineAssessPatchesResultInternal

    {
        /// <summary>The activity ID of the operation that produced this result.</summary>
        string AssessmentActivityId { get; set; }
        /// <summary>
        /// Summarization of patches available for installation on the machine by classification.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IAvailablePatchCountByClassification AvailablePatchCountByClassification { get; set; }
        /// <summary>Number of critical patches available for installation.</summary>
        int? AvailablePatchCountByClassificationCritical { get; set; }
        /// <summary>Number of definition patches available for installation.</summary>
        int? AvailablePatchCountByClassificationDefinition { get; set; }
        /// <summary>Number of feature pack patches available for installation.</summary>
        int? AvailablePatchCountByClassificationFeaturePack { get; set; }
        /// <summary>Number of other patches available for installation.</summary>
        int? AvailablePatchCountByClassificationOther { get; set; }
        /// <summary>Number of security patches available for installation.</summary>
        int? AvailablePatchCountByClassificationSecurity { get; set; }
        /// <summary>Number of service pack patches available for installation.</summary>
        int? AvailablePatchCountByClassificationServicePack { get; set; }
        /// <summary>Number of tools patches available for installation.</summary>
        int? AvailablePatchCountByClassificationTool { get; set; }
        /// <summary>Number of updates category patches available for installation.</summary>
        int? AvailablePatchCountByClassificationUpdate { get; set; }
        /// <summary>Number of update Rollup patches available for installation.</summary>
        int? AvailablePatchCountByClassificationUpdateRollup { get; set; }
        /// <summary>
        /// The errors that were encountered during execution of the operation. The details array contains the list of them.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetail ErrorDetail { get; set; }
        /// <summary>The error's code.</summary>
        string ErrorDetailCode { get; set; }
        /// <summary>A human readable error message.</summary>
        string ErrorDetailMessage { get; set; }
        /// <summary>Indicates which property in the request is responsible for the error.</summary>
        string ErrorDetailTarget { get; set; }
        /// <summary>Additional error details.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Models.Api20220110Preview.IErrorDetail[] ErrorDetailsDetails { get; set; }
        /// <summary>The UTC timestamp when the operation finished.</summary>
        global::System.DateTime? LastModifiedDateTime { get; set; }
        /// <summary>The operating system type of the machine.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.OSTypeUm? OSType { get; set; }
        /// <summary>Specifies the patch service used for the operation.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchServiceUsed? PatchServiceUsed { get; set; }
        /// <summary>
        /// The overall reboot status of the VM. It will be true when partially installed patches require a reboot to complete installation
        /// but the reboot has not yet occurred.
        /// </summary>
        bool? RebootPending { get; set; }
        /// <summary>The UTC timestamp when the operation began.</summary>
        global::System.DateTime? StartDateTime { get; set; }
        /// <summary>Indicates if operation was triggered by user or by platform.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStartedBy? StartedBy { get; set; }
        /// <summary>
        /// The overall success or failure status of the operation. It remains "InProgress" until the operation completes. At that
        /// point it will become "Unknown", "Failed", "Succeeded", or "CompletedWithWarnings."
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ArcVMwareServiceApi.Support.PatchOperationStatus? Status { get; set; }

    }
}
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Extensions;

    /// <summary>An export run.</summary>
    public partial class ExportRun :
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRun,
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal,
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResource __costManagementProxyResource = new Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.CostManagementProxyResource();

        /// <summary>Error code.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public string Code { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).Code; }

        /// <summary>
        /// Array of column names to be included in the export. If not provided then the export will include all available columns.
        /// The available columns can vary by customer channel (see examples).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public string[] ConfigurationColumn { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).ConfigurationColumn; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).ConfigurationColumn = value ?? null /* arrayOf */; }

        /// <summary>The granularity of rows in the export. Currently only 'Daily' is supported.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.GranularityType? DataSetGranularity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DataSetGranularity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DataSetGranularity = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.GranularityType)""); }

        /// <summary>
        /// The time frame for pulling data for the export. If custom, then a specific time period must be provided.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.TimeframeType? DefinitionTimeframe { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DefinitionTimeframe; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DefinitionTimeframe = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.TimeframeType)""); }

        /// <summary>
        /// The type of the export. Note that 'Usage' is equivalent to 'ActualCost' and is applicable to exports that do not yet provide
        /// data for charges or amortization for service reservations.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExportType? DefinitionType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DefinitionType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DefinitionType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExportType)""); }

        /// <summary>
        /// The name of the container where exports will be uploaded. If the container does not exist it will be created.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public string DestinationContainer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DestinationContainer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DestinationContainer = value ?? null; }

        /// <summary>
        /// The resource id of the storage account where exports will be delivered. This is not required if a sasToken and storageAccount
        /// are specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public string DestinationResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DestinationResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DestinationResourceId = value ?? null; }

        /// <summary>The name of the directory where exports will be uploaded.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public string DestinationRootFolderPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DestinationRootFolderPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DestinationRootFolderPath = value ?? null; }

        /// <summary>
        /// A SAS token for the storage account. For a restricted set of Azure customers this together with storageAccount can be
        /// specified instead of resourceId. Note: the value returned by the API for this property will always be obfuscated. Returning
        /// this same obfuscated value will not result in the SAS token being updated. To update this value a new SAS token must be
        /// specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public string DestinationSasToken { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DestinationSasToken; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DestinationSasToken = value ?? null; }

        /// <summary>
        /// The storage account where exports will be uploaded. For a restricted set of Azure customers this together with sasToken
        /// can be specified instead of resourceId.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public string DestinationStorageAccount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DestinationStorageAccount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DestinationStorageAccount = value ?? null; }

        /// <summary>
        /// eTag of the resource. To handle concurrent update scenario, this field will be used to determine whether the user is updating
        /// the latest version or not.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inherited)]
        public string ETag { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).ETag; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).ETag = value ?? null; }

        /// <summary>The type of the export run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExecutionType? ExecutionType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).ExecutionType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).ExecutionType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExecutionType)""); }

        /// <summary>The name of the exported file.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public string FileName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).FileName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).FileName = value ?? null; }

        /// <summary>Resource Id.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).Id; }

        /// <summary>Error message indicating why the operation failed.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public string Message { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).Message; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).Name = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).Type = value; }

        /// <summary>Internal Acessors for Code</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.Code { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).Code; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).Code = value; }

        /// <summary>Internal Acessors for DataSetConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportDatasetConfiguration Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.DataSetConfiguration { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DataSetConfiguration; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DataSetConfiguration = value; }

        /// <summary>Internal Acessors for DefinitionDataSet</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportDataset Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.DefinitionDataSet { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DefinitionDataSet; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DefinitionDataSet = value; }

        /// <summary>Internal Acessors for DefinitionTimePeriod</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportTimePeriod Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.DefinitionTimePeriod { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DefinitionTimePeriod; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DefinitionTimePeriod = value; }

        /// <summary>Internal Acessors for DeliveryInfoDestination</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportDeliveryDestination Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.DeliveryInfoDestination { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DeliveryInfoDestination; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).DeliveryInfoDestination = value; }

        /// <summary>Internal Acessors for Error</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IErrorDetails Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.Error { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).Error; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).Error = value; }

        /// <summary>Internal Acessors for Message</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.Message { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).Message; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).Message = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunProperties Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ExportRunProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for RunHistoryValue</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRun[] Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.RunHistoryValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunHistoryValue; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunHistoryValue = value; }

        /// <summary>Internal Acessors for RunSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICommonExportProperties Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.RunSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSetting = value; }

        /// <summary>Internal Acessors for RunSettingDefinition</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportDefinition Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.RunSettingDefinition { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingDefinition; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingDefinition = value; }

        /// <summary>Internal Acessors for RunSettingDeliveryInfo</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportDeliveryInfo Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.RunSettingDeliveryInfo { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingDeliveryInfo; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingDeliveryInfo = value; }

        /// <summary>Internal Acessors for RunSettingNextRunTimeEstimate</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.RunSettingNextRunTimeEstimate { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingNextRunTimeEstimate; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingNextRunTimeEstimate = value; }

        /// <summary>Internal Acessors for RunSettingRunHistory</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportExecutionListResult Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunInternal.RunSettingRunHistory { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingRunHistory; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingRunHistory = value; }

        /// <summary>Resource name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).Name; }

        /// <summary>The time when the export run finished.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public global::System.DateTime? ProcessingEndTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).ProcessingEndTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).ProcessingEndTime = value ?? default(global::System.DateTime); }

        /// <summary>The time when export was picked up to be run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public global::System.DateTime? ProcessingStartTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).ProcessingStartTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).ProcessingStartTime = value ?? default(global::System.DateTime); }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunProperties _property;

        /// <summary>The properties of the export run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ExportRunProperties()); set => this._property = value; }

        /// <summary>A list of export runs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRun[] RunHistoryValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunHistoryValue; }

        /// <summary>The format of the export being delivered. Currently only 'Csv' is supported.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.FormatType? RunSettingFormat { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingFormat; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingFormat = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.FormatType)""); }

        /// <summary>
        /// If the export has an active schedule, provides an estimate of the next run time.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public global::System.DateTime? RunSettingNextRunTimeEstimate { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingNextRunTimeEstimate; }

        /// <summary>
        /// If set to true, exported data will be partitioned by size and placed in a blob directory together with a manifest file.
        /// Note: this option is currently available only for Microsoft Customer Agreement commerce scopes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public bool? RunSettingPartitionData { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingPartitionData; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).RunSettingPartitionData = value ?? default(bool); }

        /// <summary>The last known status of the export run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExecutionStatus? Status { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).Status; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).Status = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExecutionStatus)""); }

        /// <summary>
        /// The identifier for the entity that triggered the export. For on-demand runs it is the user email. For scheduled runs it
        /// is 'System'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public string SubmittedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).SubmittedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).SubmittedBy = value ?? null; }

        /// <summary>The time when export was queued to be run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public global::System.DateTime? SubmittedTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).SubmittedTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).SubmittedTime = value ?? default(global::System.DateTime); }

        /// <summary>The start date for export data.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public global::System.DateTime? TimePeriodFrom { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).TimePeriodFrom; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).TimePeriodFrom = value ?? default(global::System.DateTime); }

        /// <summary>The end date for export data.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inlined)]
        public global::System.DateTime? TimePeriodTo { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).TimePeriodTo; set => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunPropertiesInternal)Property).TimePeriodTo = value ?? default(global::System.DateTime); }

        /// <summary>Resource type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Origin(Microsoft.Azure.PowerShell.Cmdlets.Cost.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal)__costManagementProxyResource).Type; }

        /// <summary>Creates an new <see cref="ExportRun" /> instance.</summary>
        public ExportRun()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__costManagementProxyResource), __costManagementProxyResource);
            await eventListener.AssertObjectIsValid(nameof(__costManagementProxyResource), __costManagementProxyResource);
        }
    }
    /// An export run.
    public partial interface IExportRun :
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResource
    {
        /// <summary>Error code.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Error code.",
        SerializedName = @"code",
        PossibleTypes = new [] { typeof(string) })]
        string Code { get;  }
        /// <summary>
        /// Array of column names to be included in the export. If not provided then the export will include all available columns.
        /// The available columns can vary by customer channel (see examples).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Array of column names to be included in the export. If not provided then the export will include all available columns. The available columns can vary by customer channel (see examples).",
        SerializedName = @"columns",
        PossibleTypes = new [] { typeof(string) })]
        string[] ConfigurationColumn { get; set; }
        /// <summary>The granularity of rows in the export. Currently only 'Daily' is supported.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The granularity of rows in the export. Currently only 'Daily' is supported.",
        SerializedName = @"granularity",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.GranularityType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.GranularityType? DataSetGranularity { get; set; }
        /// <summary>
        /// The time frame for pulling data for the export. If custom, then a specific time period must be provided.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The time frame for pulling data for the export. If custom, then a specific time period must be provided.",
        SerializedName = @"timeframe",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.TimeframeType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.TimeframeType? DefinitionTimeframe { get; set; }
        /// <summary>
        /// The type of the export. Note that 'Usage' is equivalent to 'ActualCost' and is applicable to exports that do not yet provide
        /// data for charges or amortization for service reservations.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of the export. Note that 'Usage' is equivalent to 'ActualCost' and is applicable to exports that do not yet provide data for charges or amortization for service reservations.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExportType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExportType? DefinitionType { get; set; }
        /// <summary>
        /// The name of the container where exports will be uploaded. If the container does not exist it will be created.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the container where exports will be uploaded. If the container does not exist it will be created.",
        SerializedName = @"container",
        PossibleTypes = new [] { typeof(string) })]
        string DestinationContainer { get; set; }
        /// <summary>
        /// The resource id of the storage account where exports will be delivered. This is not required if a sasToken and storageAccount
        /// are specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource id of the storage account where exports will be delivered. This is not required if a sasToken and storageAccount are specified.",
        SerializedName = @"resourceId",
        PossibleTypes = new [] { typeof(string) })]
        string DestinationResourceId { get; set; }
        /// <summary>The name of the directory where exports will be uploaded.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the directory where exports will be uploaded.",
        SerializedName = @"rootFolderPath",
        PossibleTypes = new [] { typeof(string) })]
        string DestinationRootFolderPath { get; set; }
        /// <summary>
        /// A SAS token for the storage account. For a restricted set of Azure customers this together with storageAccount can be
        /// specified instead of resourceId. Note: the value returned by the API for this property will always be obfuscated. Returning
        /// this same obfuscated value will not result in the SAS token being updated. To update this value a new SAS token must be
        /// specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A SAS token for the storage account. For a restricted set of Azure customers this together with storageAccount can be specified instead of resourceId. Note: the value returned by the API for this property will always be obfuscated. Returning this same obfuscated value will not result in the SAS token being updated. To update this value a new SAS token must be specified.",
        SerializedName = @"sasToken",
        PossibleTypes = new [] { typeof(string) })]
        string DestinationSasToken { get; set; }
        /// <summary>
        /// The storage account where exports will be uploaded. For a restricted set of Azure customers this together with sasToken
        /// can be specified instead of resourceId.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The storage account where exports will be uploaded. For a restricted set of Azure customers this together with sasToken can be specified instead of resourceId.",
        SerializedName = @"storageAccount",
        PossibleTypes = new [] { typeof(string) })]
        string DestinationStorageAccount { get; set; }
        /// <summary>The type of the export run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of the export run.",
        SerializedName = @"executionType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExecutionType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExecutionType? ExecutionType { get; set; }
        /// <summary>The name of the exported file.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the exported file.",
        SerializedName = @"fileName",
        PossibleTypes = new [] { typeof(string) })]
        string FileName { get; set; }
        /// <summary>Error message indicating why the operation failed.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Error message indicating why the operation failed.",
        SerializedName = @"message",
        PossibleTypes = new [] { typeof(string) })]
        string Message { get;  }
        /// <summary>The time when the export run finished.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The time when the export run finished.",
        SerializedName = @"processingEndTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ProcessingEndTime { get; set; }
        /// <summary>The time when export was picked up to be run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The time when export was picked up to be run.",
        SerializedName = @"processingStartTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ProcessingStartTime { get; set; }
        /// <summary>A list of export runs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"A list of export runs.",
        SerializedName = @"value",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRun) })]
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRun[] RunHistoryValue { get;  }
        /// <summary>The format of the export being delivered. Currently only 'Csv' is supported.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The format of the export being delivered. Currently only 'Csv' is supported.",
        SerializedName = @"format",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.FormatType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.FormatType? RunSettingFormat { get; set; }
        /// <summary>
        /// If the export has an active schedule, provides an estimate of the next run time.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"If the export has an active schedule, provides an estimate of the next run time.",
        SerializedName = @"nextRunTimeEstimate",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? RunSettingNextRunTimeEstimate { get;  }
        /// <summary>
        /// If set to true, exported data will be partitioned by size and placed in a blob directory together with a manifest file.
        /// Note: this option is currently available only for Microsoft Customer Agreement commerce scopes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, exported data will be partitioned by size and placed in a blob directory together with a manifest file. Note: this option is currently available only for Microsoft Customer Agreement commerce scopes.",
        SerializedName = @"partitionData",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RunSettingPartitionData { get; set; }
        /// <summary>The last known status of the export run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The last known status of the export run.",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExecutionStatus) })]
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExecutionStatus? Status { get; set; }
        /// <summary>
        /// The identifier for the entity that triggered the export. For on-demand runs it is the user email. For scheduled runs it
        /// is 'System'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The identifier for the entity that triggered the export. For on-demand runs it is the user email. For scheduled runs it is 'System'.",
        SerializedName = @"submittedBy",
        PossibleTypes = new [] { typeof(string) })]
        string SubmittedBy { get; set; }
        /// <summary>The time when export was queued to be run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The time when export was queued to be run.",
        SerializedName = @"submittedTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? SubmittedTime { get; set; }
        /// <summary>The start date for export data.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The start date for export data.",
        SerializedName = @"from",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? TimePeriodFrom { get; set; }
        /// <summary>The end date for export data.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Cost.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The end date for export data.",
        SerializedName = @"to",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? TimePeriodTo { get; set; }

    }
    /// An export run.
    internal partial interface IExportRunInternal :
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICostManagementProxyResourceInternal
    {
        /// <summary>Error code.</summary>
        string Code { get; set; }
        /// <summary>
        /// Array of column names to be included in the export. If not provided then the export will include all available columns.
        /// The available columns can vary by customer channel (see examples).
        /// </summary>
        string[] ConfigurationColumn { get; set; }
        /// <summary>The export dataset configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportDatasetConfiguration DataSetConfiguration { get; set; }
        /// <summary>The granularity of rows in the export. Currently only 'Daily' is supported.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.GranularityType? DataSetGranularity { get; set; }
        /// <summary>The definition for data in the export.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportDataset DefinitionDataSet { get; set; }
        /// <summary>Has time period for pulling data for the export.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportTimePeriod DefinitionTimePeriod { get; set; }
        /// <summary>
        /// The time frame for pulling data for the export. If custom, then a specific time period must be provided.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.TimeframeType? DefinitionTimeframe { get; set; }
        /// <summary>
        /// The type of the export. Note that 'Usage' is equivalent to 'ActualCost' and is applicable to exports that do not yet provide
        /// data for charges or amortization for service reservations.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExportType? DefinitionType { get; set; }
        /// <summary>Has destination for the export being delivered.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportDeliveryDestination DeliveryInfoDestination { get; set; }
        /// <summary>
        /// The name of the container where exports will be uploaded. If the container does not exist it will be created.
        /// </summary>
        string DestinationContainer { get; set; }
        /// <summary>
        /// The resource id of the storage account where exports will be delivered. This is not required if a sasToken and storageAccount
        /// are specified.
        /// </summary>
        string DestinationResourceId { get; set; }
        /// <summary>The name of the directory where exports will be uploaded.</summary>
        string DestinationRootFolderPath { get; set; }
        /// <summary>
        /// A SAS token for the storage account. For a restricted set of Azure customers this together with storageAccount can be
        /// specified instead of resourceId. Note: the value returned by the API for this property will always be obfuscated. Returning
        /// this same obfuscated value will not result in the SAS token being updated. To update this value a new SAS token must be
        /// specified.
        /// </summary>
        string DestinationSasToken { get; set; }
        /// <summary>
        /// The storage account where exports will be uploaded. For a restricted set of Azure customers this together with sasToken
        /// can be specified instead of resourceId.
        /// </summary>
        string DestinationStorageAccount { get; set; }
        /// <summary>The details of any error.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IErrorDetails Error { get; set; }
        /// <summary>The type of the export run.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExecutionType? ExecutionType { get; set; }
        /// <summary>The name of the exported file.</summary>
        string FileName { get; set; }
        /// <summary>Error message indicating why the operation failed.</summary>
        string Message { get; set; }
        /// <summary>The time when the export run finished.</summary>
        global::System.DateTime? ProcessingEndTime { get; set; }
        /// <summary>The time when export was picked up to be run.</summary>
        global::System.DateTime? ProcessingStartTime { get; set; }
        /// <summary>The properties of the export run.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRunProperties Property { get; set; }
        /// <summary>A list of export runs.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportRun[] RunHistoryValue { get; set; }
        /// <summary>The export settings that were in effect for this run.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.ICommonExportProperties RunSetting { get; set; }
        /// <summary>Has the definition for the export.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportDefinition RunSettingDefinition { get; set; }
        /// <summary>Has delivery information for the export.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportDeliveryInfo RunSettingDeliveryInfo { get; set; }
        /// <summary>The format of the export being delivered. Currently only 'Csv' is supported.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.FormatType? RunSettingFormat { get; set; }
        /// <summary>
        /// If the export has an active schedule, provides an estimate of the next run time.
        /// </summary>
        global::System.DateTime? RunSettingNextRunTimeEstimate { get; set; }
        /// <summary>
        /// If set to true, exported data will be partitioned by size and placed in a blob directory together with a manifest file.
        /// Note: this option is currently available only for Microsoft Customer Agreement commerce scopes.
        /// </summary>
        bool? RunSettingPartitionData { get; set; }
        /// <summary>If requested, has the most recent run history for the export.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Models.Api20221001.IExportExecutionListResult RunSettingRunHistory { get; set; }
        /// <summary>The last known status of the export run.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Cost.Support.ExecutionStatus? Status { get; set; }
        /// <summary>
        /// The identifier for the entity that triggered the export. For on-demand runs it is the user email. For scheduled runs it
        /// is 'System'.
        /// </summary>
        string SubmittedBy { get; set; }
        /// <summary>The time when export was queued to be run.</summary>
        global::System.DateTime? SubmittedTime { get; set; }
        /// <summary>The start date for export data.</summary>
        global::System.DateTime? TimePeriodFrom { get; set; }
        /// <summary>The end date for export data.</summary>
        global::System.DateTime? TimePeriodTo { get; set; }

    }
}
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Extensions;

    /// <summary>Properties of the managed cluster.</summary>
    public partial class ManagedClusterProperties :
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterProperties,
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal
    {

        /// <summary>Backing field for <see cref="AadProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfile _aadProfile;

        /// <summary>The Azure Active Directory configuration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfile AadProfile { get => (this._aadProfile = this._aadProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterAadProfile()); set => this._aadProfile = value; }

        /// <summary>The list of AAD group object IDs that will have admin role of the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string[] AadProfileAdminGroupObjectID { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).AdminGroupObjectID; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).AdminGroupObjectID = value ?? null /* arrayOf */; }

        /// <summary>
        /// (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AadProfileClientAppId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).ClientAppId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).ClientAppId = value ?? null; }

        /// <summary>Whether to enable Azure RBAC for Kubernetes authorization.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? AadProfileEnableAzureRbac { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).EnableAzureRbac; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).EnableAzureRbac = value ?? default(bool); }

        /// <summary>Whether to enable managed AAD.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? AadProfileManaged { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).Managed; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).Managed = value ?? default(bool); }

        /// <summary>
        /// (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AadProfileServerAppId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).ServerAppId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).ServerAppId = value ?? null; }

        /// <summary>
        /// (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AadProfileServerAppSecret { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).ServerAppSecret; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).ServerAppSecret = value ?? null; }

        /// <summary>
        /// The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AadProfileTenantId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).TenantId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfileInternal)AadProfile).TenantId = value ?? null; }

        /// <summary>Backing field for <see cref="AddonProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAddonProfiles _addonProfile;

        /// <summary>The profile of managed cluster add-on.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAddonProfiles AddonProfile { get => (this._addonProfile = this._addonProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterPropertiesAddonProfiles()); set => this._addonProfile = value; }

        /// <summary>Backing field for <see cref="AgentPoolProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAgentPoolProfile[] _agentPoolProfile;

        /// <summary>The agent pool properties.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAgentPoolProfile[] AgentPoolProfile { get => this._agentPoolProfile; set => this._agentPoolProfile = value; }

        /// <summary>Backing field for <see cref="AiToolchainOperatorProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAiToolchainOperatorProfile _aiToolchainOperatorProfile;

        /// <summary>AI toolchain operator settings that apply to the whole cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAiToolchainOperatorProfile AiToolchainOperatorProfile { get => (this._aiToolchainOperatorProfile = this._aiToolchainOperatorProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterAiToolchainOperatorProfile()); set => this._aiToolchainOperatorProfile = value; }

        /// <summary>Indicates if AI toolchain operator enabled or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? AiToolchainOperatorProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAiToolchainOperatorProfileInternal)AiToolchainOperatorProfile).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAiToolchainOperatorProfileInternal)AiToolchainOperatorProfile).Enabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="ApiServerAccessProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfile _apiServerAccessProfile;

        /// <summary>The access profile for managed cluster API server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfile ApiServerAccessProfile { get => (this._apiServerAccessProfile = this._apiServerAccessProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterApiServerAccessProfile()); set => this._apiServerAccessProfile = value; }

        /// <summary>
        /// IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use
        /// Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized
        /// IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string[] ApiServerAccessProfileAuthorizedIPRange { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).AuthorizedIPRange; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).AuthorizedIPRange = value ?? null /* arrayOf */; }

        /// <summary>Whether to disable run command for the cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ApiServerAccessProfileDisableRunCommand { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).DisableRunCommand; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).DisableRunCommand = value ?? default(bool); }

        /// <summary>
        /// For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ApiServerAccessProfileEnablePrivateCluster { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).EnablePrivateCluster; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).EnablePrivateCluster = value ?? default(bool); }

        /// <summary>Whether to create additional public FQDN for private cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ApiServerAccessProfileEnablePrivateClusterPublicFqdn { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).EnablePrivateClusterPublicFqdn; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).EnablePrivateClusterPublicFqdn = value ?? default(bool); }

        /// <summary>Whether to enable apiserver vnet integration for the cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ApiServerAccessProfileEnableVnetIntegration { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).EnableVnetIntegration; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).EnableVnetIntegration = value ?? default(bool); }

        /// <summary>
        /// The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
        /// Allowed values are 'system' and 'none'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string ApiServerAccessProfilePrivateDnsZone { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).PrivateDnsZone; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).PrivateDnsZone = value ?? null; }

        /// <summary>
        /// It is required when: 1. creating a new cluster with BYO Vnet; 2. updating an existing cluster to enable apiserver vnet
        /// integration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string ApiServerAccessProfileSubnetId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).SubnetId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfileInternal)ApiServerAccessProfile).SubnetId = value ?? null; }

        /// <summary>Indicates if Application Monitoring Auto Instrumentation is enabled or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? AutoInstrumentationEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).AutoInstrumentationEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).AutoInstrumentationEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="AutoScalerProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfile _autoScalerProfile;

        /// <summary>Parameters to be applied to the cluster-autoscaler when enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfile AutoScalerProfile { get => (this._autoScalerProfile = this._autoScalerProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterPropertiesAutoScalerProfile()); set => this._autoScalerProfile = value; }

        /// <summary>Valid values are 'true' and 'false'</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileBalanceSimilarNodeGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).BalanceSimilarNodeGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).BalanceSimilarNodeGroup = value ?? null; }

        /// <summary>
        /// If set to true, all daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot
        /// be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset
        /// pods are deleted or evicted.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? AutoScalerProfileDaemonsetEvictionForEmptyNode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).DaemonsetEvictionForEmptyNode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).DaemonsetEvictionForEmptyNode = value ?? default(bool); }

        /// <summary>
        /// If set to true, all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod
        /// cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring
        /// that daemonset pods are deleted or evicted.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? AutoScalerProfileDaemonsetEvictionForOccupiedNode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).DaemonsetEvictionForOccupiedNode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).DaemonsetEvictionForOccupiedNode = value ?? default(bool); }

        /// <summary>Available values are: 'least-waste', 'most-pods', 'priority', 'random'.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander? AutoScalerProfileExpander { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).Expander; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).Expander = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander)""); }

        /// <summary>
        /// If set to true, the resources used by daemonset will be taken into account when making scaling down decisions.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? AutoScalerProfileIgnoreDaemonsetsUtilization { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).IgnoreDaemonsetsUtilization; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).IgnoreDaemonsetsUtilization = value ?? default(bool); }

        /// <summary>The default is 10.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileMaxEmptyBulkDelete { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).MaxEmptyBulkDelete; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).MaxEmptyBulkDelete = value ?? null; }

        /// <summary>The default is 600.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileMaxGracefulTerminationSec { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).MaxGracefulTerminationSec; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).MaxGracefulTerminationSec = value ?? null; }

        /// <summary>
        /// The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileMaxNodeProvisionTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).MaxNodeProvisionTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).MaxNodeProvisionTime = value ?? null; }

        /// <summary>The default is 45. The maximum is 100 and the minimum is 0.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileMaxTotalUnreadyPercentage { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).MaxTotalUnreadyPercentage; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).MaxTotalUnreadyPercentage = value ?? null; }

        /// <summary>
        /// For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all
        /// the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be
        /// an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileNewPodScaleUpDelay { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).NewPodScaleUpDelay; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).NewPodScaleUpDelay = value ?? null; }

        /// <summary>This must be an integer. The default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileOkTotalUnreadyCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).OkTotalUnreadyCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).OkTotalUnreadyCount = value ?? null; }

        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownDelayAfterAdd { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownDelayAfterAdd; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownDelayAfterAdd = value ?? null; }

        /// <summary>
        /// The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m)
        /// is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownDelayAfterDelete { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownDelayAfterDelete; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownDelayAfterDelete = value ?? null; }

        /// <summary>
        /// The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownDelayAfterFailure { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownDelayAfterFailure; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownDelayAfterFailure = value ?? null; }

        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownUnneededTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownUnneededTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownUnneededTime = value ?? null; }

        /// <summary>
        /// The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownUnreadyTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownUnreadyTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownUnreadyTime = value ?? null; }

        /// <summary>The default is '0.5'.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownUtilizationThreshold { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownUtilizationThreshold; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScaleDownUtilizationThreshold = value ?? null; }

        /// <summary>The default is '10'. Values must be an integer number of seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScanInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScanInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).ScanInterval = value ?? null; }

        /// <summary>The default is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileSkipNodesWithLocalStorage { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).SkipNodesWithLocalStorage; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).SkipNodesWithLocalStorage = value ?? null; }

        /// <summary>The default is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AutoScalerProfileSkipNodesWithSystemPod { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).SkipNodesWithSystemPod; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfileInternal)AutoScalerProfile).SkipNodesWithSystemPod = value ?? null; }

        /// <summary>Backing field for <see cref="AutoUpgradeProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAutoUpgradeProfile _autoUpgradeProfile;

        /// <summary>The auto upgrade configuration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAutoUpgradeProfile AutoUpgradeProfile { get => (this._autoUpgradeProfile = this._autoUpgradeProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterAutoUpgradeProfile()); set => this._autoUpgradeProfile = value; }

        /// <summary>
        /// The default is Unmanaged, but may change to either NodeImage or SecurityPatch at GA.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeOSUpgradeChannel? AutoUpgradeProfileNodeOSUpgradeChannel { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAutoUpgradeProfileInternal)AutoUpgradeProfile).NodeOSUpgradeChannel; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAutoUpgradeProfileInternal)AutoUpgradeProfile).NodeOSUpgradeChannel = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeOSUpgradeChannel)""); }

        /// <summary>
        /// For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel? AutoUpgradeProfileUpgradeChannel { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAutoUpgradeProfileInternal)AutoUpgradeProfile).UpgradeChannel; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAutoUpgradeProfileInternal)AutoUpgradeProfile).UpgradeChannel = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel)""); }

        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? AzureKeyVaultKmEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).AzureKeyVaultKmEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).AzureKeyVaultKmEnabled = value ?? default(bool); }

        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AzureKeyVaultKmKeyId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).AzureKeyVaultKmKeyId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).AzureKeyVaultKmKeyId = value ?? null; }

        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes? AzureKeyVaultKmKeyVaultNetworkAccess { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).AzureKeyVaultKmKeyVaultNetworkAccess; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).AzureKeyVaultKmKeyVaultNetworkAccess = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes)""); }

        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AzureKeyVaultKmKeyVaultResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).AzureKeyVaultKmKeyVaultResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).AzureKeyVaultKmKeyVaultResourceId = value ?? null; }

        /// <summary>Backing field for <see cref="AzureMonitorProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfile _azureMonitorProfile;

        /// <summary>Prometheus addon profile for the container service cluster</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfile AzureMonitorProfile { get => (this._azureMonitorProfile = this._azureMonitorProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterAzureMonitorProfile()); set => this._azureMonitorProfile = value; }

        /// <summary>Backing field for <see cref="AzurePortalFqdn" /> property.</summary>
        private string _azurePortalFqdn;

        /// <summary>
        /// The Azure Portal requires certain Cross-Origin Resource Sharing (CORS) headers to be sent in some responses, which Kubernetes
        /// APIServer doesn't handle by default. This special FQDN supports CORS, allowing the Azure Portal to function properly.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string AzurePortalFqdn { get => this._azurePortalFqdn; }

        /// <summary>Whether to enable AzureBlob CSI Driver. The default value is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? BlobCsiDriverEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).BlobCsiDriverEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).BlobCsiDriverEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="BootstrapProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterBootstrapProfile _bootstrapProfile;

        /// <summary>Profile of the cluster bootstrap configuration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterBootstrapProfile BootstrapProfile { get => (this._bootstrapProfile = this._bootstrapProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterBootstrapProfile()); set => this._bootstrapProfile = value; }

        /// <summary>The source where the artifacts are downloaded from.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ArtifactSource? BootstrapProfileArtifactSource { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterBootstrapProfileInternal)BootstrapProfile).ArtifactSource; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterBootstrapProfileInternal)BootstrapProfile).ArtifactSource = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ArtifactSource)""); }

        /// <summary>
        /// The resource Id of Azure Container Registry. The registry must have private network access, premium SKU and zone redundancy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string BootstrapProfileContainerRegistryId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterBootstrapProfileInternal)BootstrapProfile).ContainerRegistryId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterBootstrapProfileInternal)BootstrapProfile).ContainerRegistryId = value ?? null; }

        /// <summary>Istio egress gateways.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioEgressGateway[] ComponentEgressGateway { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).ComponentEgressGateway; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).ComponentEgressGateway = value ?? null /* arrayOf */; }

        /// <summary>Istio ingress gateways.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioIngressGateway[] ComponentIngressGateway { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).ComponentIngressGateway; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).ComponentIngressGateway = value ?? null /* arrayOf */; }

        /// <summary>
        /// Indicates whether custom metrics collection has to be disabled or not. If not specified the default is false. No custom
        /// metrics will be emitted if this field is false but the container insights enabled field is false
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ContainerInsightDisableCustomMetric { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsightDisableCustomMetric; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsightDisableCustomMetric = value ?? default(bool); }

        /// <summary>
        /// Indicates whether prometheus metrics scraping is disabled or not. If not specified the default is false. No prometheus
        /// metrics will be emitted if this field is false but the container insights enabled field is false
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ContainerInsightDisablePrometheusMetricsScraping { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsightDisablePrometheusMetricsScraping; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsightDisablePrometheusMetricsScraping = value ?? default(bool); }

        /// <summary>Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ContainerInsightEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsightEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsightEnabled = value ?? default(bool); }

        /// <summary>
        /// Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing Azure Monitor Container Insights Logs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string ContainerInsightLogAnalyticsWorkspaceResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsightLogAnalyticsWorkspaceResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsightLogAnalyticsWorkspaceResourceId = value ?? null; }

        /// <summary>The syslog host port. If not specified, the default port is 28330.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public long? ContainerInsightSyslogPort { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsightSyslogPort; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsightSyslogPort = value ?? default(long); }

        /// <summary>
        /// The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable this feature. Enabling this will add Kubernetes
        /// Namespace and Deployment details to the Cost Analysis views in the Azure portal. If not specified, the default is false.
        /// For more information see aka.ms/aks/docs/cost-analysis.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? CostAnalysisEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterMetricsProfileInternal)MetricsProfile).CostAnalysisEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterMetricsProfileInternal)MetricsProfile).CostAnalysisEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="CreationData" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICreationData _creationData;

        /// <summary>
        /// CreationData to be used to specify the source Snapshot ID if the cluster will be created/upgraded using a snapshot.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICreationData CreationData { get => (this._creationData = this._creationData ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.CreationData()); set => this._creationData = value; }

        /// <summary>This is the ARM ID of the source object to be used to create the target object.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string CreationDataSourceResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICreationDataInternal)CreationData).SourceResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICreationDataInternal)CreationData).SourceResourceId = value ?? null; }

        /// <summary>Backing field for <see cref="CurrentKubernetesVersion" /> property.</summary>
        private string _currentKubernetesVersion;

        /// <summary>The version of Kubernetes the Managed Cluster is running.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string CurrentKubernetesVersion { get => this._currentKubernetesVersion; }

        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string DefenderLogAnalyticsWorkspaceResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).DefenderLogAnalyticsWorkspaceResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).DefenderLogAnalyticsWorkspaceResourceId = value ?? null; }

        /// <summary>Backing field for <see cref="DisableLocalAccount" /> property.</summary>
        private bool? _disableLocalAccount;

        /// <summary>
        /// If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters
        /// that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public bool? DisableLocalAccount { get => this._disableLocalAccount; set => this._disableLocalAccount = value; }

        /// <summary>Whether to enable AzureDisk CSI Driver. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? DiskCsiDriverEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).DiskCsiDriverEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).DiskCsiDriverEnabled = value ?? default(bool); }

        /// <summary>The version of AzureDisk CSI Driver. The default value is v1.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string DiskCsiDriverVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).DiskCsiDriverVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).DiskCsiDriverVersion = value ?? null; }

        /// <summary>Backing field for <see cref="DiskEncryptionSetId" /> property.</summary>
        private string _diskEncryptionSetId;

        /// <summary>
        /// This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string DiskEncryptionSetId { get => this._diskEncryptionSetId; set => this._diskEncryptionSetId = value; }

        /// <summary>Backing field for <see cref="DnsPrefix" /> property.</summary>
        private string _dnsPrefix;

        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string DnsPrefix { get => this._dnsPrefix; set => this._dnsPrefix = value; }

        /// <summary>Backing field for <see cref="EnableNamespaceResource" /> property.</summary>
        private bool? _enableNamespaceResource;

        /// <summary>
        /// The default value is false. It can be enabled/disabled on creation and updating of the managed cluster. See [https://aka.ms/NamespaceARMResource](https://aka.ms/NamespaceARMResource)
        /// for more details on Namespace as a ARM Resource.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public bool? EnableNamespaceResource { get => this._enableNamespaceResource; set => this._enableNamespaceResource = value; }

        /// <summary>Backing field for <see cref="EnableRbac" /> property.</summary>
        private bool? _enableRbac;

        /// <summary>Whether to enable Kubernetes Role-Based Access Control.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public bool? EnableRbac { get => this._enableRbac; set => this._enableRbac = value; }

        /// <summary>Whether to enable AzureFile CSI Driver. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? FileCsiDriverEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).FileCsiDriverEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).FileCsiDriverEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="Fqdn" /> property.</summary>
        private string _fqdn;

        /// <summary>The FQDN of the master pool.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string Fqdn { get => this._fqdn; }

        /// <summary>Backing field for <see cref="FqdnSubdomain" /> property.</summary>
        private string _fqdnSubdomain;

        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string FqdnSubdomain { get => this._fqdnSubdomain; set => this._fqdnSubdomain = value; }

        /// <summary>
        /// Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet
        /// which is used to create the managed cluster.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string GmsaProfileDnsServer { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).GmsaProfileDnsServer; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).GmsaProfileDnsServer = value ?? null; }

        /// <summary>Specifies whether to enable Windows gMSA in the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? GmsaProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).GmsaProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).GmsaProfileEnabled = value ?? default(bool); }

        /// <summary>
        /// Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the
        /// vnet which is used to create the managed cluster.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string GmsaProfileRootDomainName { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).GmsaProfileRootDomainName; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).GmsaProfileRootDomainName = value ?? null; }

        /// <summary>Backing field for <see cref="HttpProxyConfig" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfig _httpProxyConfig;

        /// <summary>Configurations for provisioning the cluster with HTTP proxy servers.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfig HttpProxyConfig { get => (this._httpProxyConfig = this._httpProxyConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterHttpProxyConfig()); set => this._httpProxyConfig = value; }

        /// <summary>
        /// A read-only list of all endpoints for which traffic should not be sent to the proxy. This list is a superset of noProxy
        /// and values injected by AKS.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string[] HttpProxyConfigEffectiveNoProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).EffectiveNoProxy; }

        /// <summary>
        /// Whether to enable HTTP proxy. When disabled, the specified proxy configuration will be not be set on pods and nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? HttpProxyConfigEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).Enabled = value ?? default(bool); }

        /// <summary>The HTTP proxy server endpoint to use.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string HttpProxyConfigHttpProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).HttpProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).HttpProxy = value ?? null; }

        /// <summary>The HTTPS proxy server endpoint to use.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string HttpProxyConfigHttpsProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).HttpsProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).HttpsProxy = value ?? null; }

        /// <summary>The endpoints that should not go through proxy.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string[] HttpProxyConfigNoProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).NoProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).NoProxy = value ?? null /* arrayOf */; }

        /// <summary>Alternative CA cert to use for connecting to proxy servers.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string HttpProxyConfigTrustedCa { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).TrustedCa; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).TrustedCa = value ?? null; }

        /// <summary>The client ID of the user assigned identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string IdentityClientId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).IdentityClientId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).IdentityClientId = value ?? null; }

        /// <summary>The object ID of the user assigned identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string IdentityObjectId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).IdentityObjectId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).IdentityObjectId = value ?? null; }

        /// <summary>Backing field for <see cref="IdentityProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesIdentityProfile _identityProfile;

        /// <summary>
        /// The user identity associated with the managed cluster. This identity will be used by the kubelet. Only one user assigned
        /// identity is allowed. The only accepted key is "kubeletidentity", with value of "resourceId": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}".
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesIdentityProfile IdentityProfile { get => (this._identityProfile = this._identityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterPropertiesIdentityProfile()); set => this._identityProfile = value; }

        /// <summary>The resource ID of the user assigned identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string IdentityResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).IdentityResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).IdentityResourceId = value ?? null; }

        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ImageCleanerEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).ImageCleanerEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).ImageCleanerEnabled = value ?? default(bool); }

        /// <summary>Image Cleaner scanning interval in hours.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public int? ImageCleanerIntervalHour { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).ImageCleanerIntervalHour; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).ImageCleanerIntervalHour = value ?? default(int); }

        /// <summary>Whether to enable image integrity. The default value is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ImageIntegrityEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).ImageIntegrityEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).ImageIntegrityEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="IngressProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfile _ingressProfile;

        /// <summary>Ingress profile for the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfile IngressProfile { get => (this._ingressProfile = this._ingressProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterIngressProfile()); set => this._ingressProfile = value; }

        /// <summary>
        /// The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary
        /// upgrade is in progress, this can only hold two consecutive values. For more information, see: https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string[] IstioRevision { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).IstioRevision; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).IstioRevision = value ?? null /* arrayOf */; }

        /// <summary>Whether to enable KEDA.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? KedaEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileInternal)WorkloadAutoScalerProfile).KedaEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileInternal)WorkloadAutoScalerProfile).KedaEnabled = value ?? default(bool); }

        /// <summary>
        /// Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string KubeStateMetricAnnotationsAllowList { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).KubeStateMetricAnnotationsAllowList; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).KubeStateMetricAnnotationsAllowList = value ?? null; }

        /// <summary>
        /// Comma-separated list of Kubernetes annotations keys that will be used in the resource's labels metric.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string KubeStateMetricLabelsAllowlist { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).KubeStateMetricLabelsAllowlist; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).KubeStateMetricLabelsAllowlist = value ?? null; }

        /// <summary>Backing field for <see cref="KubernetesVersion" /> property.</summary>
        private string _kubernetesVersion;

        /// <summary>
        /// When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed
        /// sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed,
        /// however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster)
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string KubernetesVersion { get => this._kubernetesVersion; set => this._kubernetesVersion = value; }

        /// <summary>Backing field for <see cref="LinuxProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceLinuxProfile _linuxProfile;

        /// <summary>The profile for Linux VMs in the Managed Cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceLinuxProfile LinuxProfile { get => (this._linuxProfile = this._linuxProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ContainerServiceLinuxProfile()); set => this._linuxProfile = value; }

        /// <summary>The administrator username to use for Linux VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string LinuxProfileAdminUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceLinuxProfileInternal)LinuxProfile).AdminUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceLinuxProfileInternal)LinuxProfile).AdminUsername = value ?? null; }

        /// <summary>Backing field for <see cref="MaxAgentPool" /> property.</summary>
        private int? _maxAgentPool;

        /// <summary>The max number of agent pools for the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public int? MaxAgentPool { get => this._maxAgentPool; }

        /// <summary>Whether to enable the Prometheus collector</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? MetricEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).MetricEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).MetricEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="MetricsProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterMetricsProfile _metricsProfile;

        /// <summary>Optional cluster metrics configuration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterMetricsProfile MetricsProfile { get => (this._metricsProfile = this._metricsProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterMetricsProfile()); set => this._metricsProfile = value; }

        /// <summary>Internal Acessors for AadProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AadProfile { get => (this._aadProfile = this._aadProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterAadProfile()); set { {_aadProfile = value;} } }

        /// <summary>Internal Acessors for AiToolchainOperatorProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAiToolchainOperatorProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AiToolchainOperatorProfile { get => (this._aiToolchainOperatorProfile = this._aiToolchainOperatorProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterAiToolchainOperatorProfile()); set { {_aiToolchainOperatorProfile = value;} } }

        /// <summary>Internal Acessors for ApiServerAccessProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.ApiServerAccessProfile { get => (this._apiServerAccessProfile = this._apiServerAccessProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterApiServerAccessProfile()); set { {_apiServerAccessProfile = value;} } }

        /// <summary>Internal Acessors for AppMonitoringAutoInstrumentation</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AppMonitoringAutoInstrumentation { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).AppMonitoringAutoInstrumentation; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).AppMonitoringAutoInstrumentation = value; }

        /// <summary>Internal Acessors for AppMonitoringOpenTelemetryLog</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AppMonitoringOpenTelemetryLog { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).AppMonitoringOpenTelemetryLog; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).AppMonitoringOpenTelemetryLog = value; }

        /// <summary>Internal Acessors for AppMonitoringOpenTelemetryMetric</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AppMonitoringOpenTelemetryMetric { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).AppMonitoringOpenTelemetryMetric; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).AppMonitoringOpenTelemetryMetric = value; }

        /// <summary>Internal Acessors for AutoScalerProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AutoScalerProfile { get => (this._autoScalerProfile = this._autoScalerProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterPropertiesAutoScalerProfile()); set { {_autoScalerProfile = value;} } }

        /// <summary>Internal Acessors for AutoUpgradeProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAutoUpgradeProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AutoUpgradeProfile { get => (this._autoUpgradeProfile = this._autoUpgradeProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterAutoUpgradeProfile()); set { {_autoUpgradeProfile = value;} } }

        /// <summary>Internal Acessors for AzureMonitorProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AzureMonitorProfile { get => (this._azureMonitorProfile = this._azureMonitorProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterAzureMonitorProfile()); set { {_azureMonitorProfile = value;} } }

        /// <summary>Internal Acessors for AzureMonitorProfileAppMonitoring</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileAppMonitoring Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AzureMonitorProfileAppMonitoring { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).AppMonitoring; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).AppMonitoring = value; }

        /// <summary>Internal Acessors for AzureMonitorProfileContainerInsight</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileContainerInsights Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AzureMonitorProfileContainerInsight { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsight; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).ContainerInsight = value; }

        /// <summary>Internal Acessors for AzureMonitorProfileMetric</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileMetrics Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AzureMonitorProfileMetric { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).Metric; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).Metric = value; }

        /// <summary>Internal Acessors for AzurePortalFqdn</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.AzurePortalFqdn { get => this._azurePortalFqdn; set { {_azurePortalFqdn = value;} } }

        /// <summary>Internal Acessors for BootstrapProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterBootstrapProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.BootstrapProfile { get => (this._bootstrapProfile = this._bootstrapProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterBootstrapProfile()); set { {_bootstrapProfile = value;} } }

        /// <summary>Internal Acessors for CertificateAuthorityPlugin</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioPluginCertificateAuthority Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.CertificateAuthorityPlugin { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).CertificateAuthorityPlugin; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).CertificateAuthorityPlugin = value; }

        /// <summary>Internal Acessors for CreationData</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICreationData Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.CreationData { get => (this._creationData = this._creationData ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.CreationData()); set { {_creationData = value;} } }

        /// <summary>Internal Acessors for CurrentKubernetesVersion</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.CurrentKubernetesVersion { get => this._currentKubernetesVersion; set { {_currentKubernetesVersion = value;} } }

        /// <summary>Internal Acessors for DefenderSecurityGating</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileDefenderSecurityGating Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.DefenderSecurityGating { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).DefenderSecurityGating; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).DefenderSecurityGating = value; }

        /// <summary>Internal Acessors for DefenderSecurityMonitoring</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileDefenderSecurityMonitoring Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.DefenderSecurityMonitoring { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).DefenderSecurityMonitoring; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).DefenderSecurityMonitoring = value; }

        /// <summary>Internal Acessors for Fqdn</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.Fqdn { get => this._fqdn; set { {_fqdn = value;} } }

        /// <summary>Internal Acessors for HttpProxyConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfig Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.HttpProxyConfig { get => (this._httpProxyConfig = this._httpProxyConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterHttpProxyConfig()); set { {_httpProxyConfig = value;} } }

        /// <summary>Internal Acessors for HttpProxyConfigEffectiveNoProxy</summary>
        string[] Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.HttpProxyConfigEffectiveNoProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).EffectiveNoProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfigInternal)HttpProxyConfig).EffectiveNoProxy = value; }

        /// <summary>Internal Acessors for IngressProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.IngressProfile { get => (this._ingressProfile = this._ingressProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterIngressProfile()); set { {_ingressProfile = value;} } }

        /// <summary>Internal Acessors for IngressProfileWebAppRouting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileWebAppRouting Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.IngressProfileWebAppRouting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).WebAppRouting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).WebAppRouting = value; }

        /// <summary>Internal Acessors for IstioCertificateAuthority</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioCertificateAuthority Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.IstioCertificateAuthority { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).IstioCertificateAuthority; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).IstioCertificateAuthority = value; }

        /// <summary>Internal Acessors for IstioComponent</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioComponents Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.IstioComponent { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).IstioComponent; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).IstioComponent = value; }

        /// <summary>Internal Acessors for LinuxProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceLinuxProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.LinuxProfile { get => (this._linuxProfile = this._linuxProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ContainerServiceLinuxProfile()); set { {_linuxProfile = value;} } }

        /// <summary>Internal Acessors for LinuxProfileSsh</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceSshConfiguration Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.LinuxProfileSsh { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceLinuxProfileInternal)LinuxProfile).Ssh; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceLinuxProfileInternal)LinuxProfile).Ssh = value; }

        /// <summary>Internal Acessors for MaxAgentPool</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.MaxAgentPool { get => this._maxAgentPool; set { {_maxAgentPool = value;} } }

        /// <summary>Internal Acessors for MetricKubeStateMetric</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileKubeStateMetrics Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.MetricKubeStateMetric { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).MetricKubeStateMetric; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).MetricKubeStateMetric = value; }

        /// <summary>Internal Acessors for MetricProfileCostAnalysis</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterCostAnalysis Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.MetricProfileCostAnalysis { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterMetricsProfileInternal)MetricsProfile).CostAnalysis; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterMetricsProfileInternal)MetricsProfile).CostAnalysis = value; }

        /// <summary>Internal Acessors for MetricsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterMetricsProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.MetricsProfile { get => (this._metricsProfile = this._metricsProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterMetricsProfile()); set { {_metricsProfile = value;} } }

        /// <summary>Internal Acessors for NodeProvisioningProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeProvisioningProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.NodeProvisioningProfile { get => (this._nodeProvisioningProfile = this._nodeProvisioningProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterNodeProvisioningProfile()); set { {_nodeProvisioningProfile = value;} } }

        /// <summary>Internal Acessors for NodeResourceGroupProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeResourceGroupProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.NodeResourceGroupProfile { get => (this._nodeResourceGroupProfile = this._nodeResourceGroupProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterNodeResourceGroupProfile()); set { {_nodeResourceGroupProfile = value;} } }

        /// <summary>Internal Acessors for OidcIssuerProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterOidcIssuerProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.OidcIssuerProfile { get => (this._oidcIssuerProfile = this._oidcIssuerProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterOidcIssuerProfile()); set { {_oidcIssuerProfile = value;} } }

        /// <summary>Internal Acessors for OidcIssuerProfileIssuerUrl</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.OidcIssuerProfileIssuerUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterOidcIssuerProfileInternal)OidcIssuerProfile).IssuerUrl; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterOidcIssuerProfileInternal)OidcIssuerProfile).IssuerUrl = value; }

        /// <summary>Internal Acessors for PodIdentityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.PodIdentityProfile { get => (this._podIdentityProfile = this._podIdentityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterPodIdentityProfile()); set { {_podIdentityProfile = value;} } }

        /// <summary>Internal Acessors for PowerState</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPowerState Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.PowerState { get => (this._powerState = this._powerState ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.PowerState()); set { {_powerState = value;} } }

        /// <summary>Internal Acessors for PrivateFqdn</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.PrivateFqdn { get => this._privateFqdn; set { {_privateFqdn = value;} } }

        /// <summary>Internal Acessors for ProvisioningState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.ProvisioningState { get => this._provisioningState; set { {_provisioningState = value;} } }

        /// <summary>Internal Acessors for ResourceUid</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.ResourceUid { get => this._resourceUid; set { {_resourceUid = value;} } }

        /// <summary>Internal Acessors for SafeguardProfileSystemExcludedNamespace</summary>
        string[] Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.SafeguardProfileSystemExcludedNamespace { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfileInternal)SafeguardsProfile).SystemExcludedNamespace; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfileInternal)SafeguardsProfile).SystemExcludedNamespace = value; }

        /// <summary>Internal Acessors for SafeguardsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.SafeguardsProfile { get => (this._safeguardsProfile = this._safeguardsProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.SafeguardsProfile()); set { {_safeguardsProfile = value;} } }

        /// <summary>Internal Acessors for SecurityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.SecurityProfile { get => (this._securityProfile = this._securityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterSecurityProfile()); set { {_securityProfile = value;} } }

        /// <summary>Internal Acessors for SecurityProfileAzureKeyVaultKm</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IAzureKeyVaultKms Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.SecurityProfileAzureKeyVaultKm { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).AzureKeyVaultKm; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).AzureKeyVaultKm = value; }

        /// <summary>Internal Acessors for SecurityProfileDefender</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileDefender Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.SecurityProfileDefender { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).Defender; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).Defender = value; }

        /// <summary>Internal Acessors for SecurityProfileImageCleaner</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileImageCleaner Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.SecurityProfileImageCleaner { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).ImageCleaner; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).ImageCleaner = value; }

        /// <summary>Internal Acessors for SecurityProfileImageIntegrity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileImageIntegrity Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.SecurityProfileImageIntegrity { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).ImageIntegrity; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).ImageIntegrity = value; }

        /// <summary>Internal Acessors for SecurityProfileNodeRestriction</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileNodeRestriction Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.SecurityProfileNodeRestriction { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).NodeRestriction; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).NodeRestriction = value; }

        /// <summary>Internal Acessors for SecurityProfileWorkloadIdentity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileWorkloadIdentity Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.SecurityProfileWorkloadIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).WorkloadIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).WorkloadIdentity = value; }

        /// <summary>Internal Acessors for ServiceMeshProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.ServiceMeshProfile { get => (this._serviceMeshProfile = this._serviceMeshProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ServiceMeshProfile()); set { {_serviceMeshProfile = value;} } }

        /// <summary>Internal Acessors for ServiceMeshProfileIstio</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioServiceMesh Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.ServiceMeshProfileIstio { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).Istio; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).Istio = value; }

        /// <summary>Internal Acessors for ServicePrincipalProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterServicePrincipalProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.ServicePrincipalProfile { get => (this._servicePrincipalProfile = this._servicePrincipalProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterServicePrincipalProfile()); set { {_servicePrincipalProfile = value;} } }

        /// <summary>Internal Acessors for Status</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatus Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.Status { get => (this._status = this._status ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterStatus()); set { {_status = value;} } }

        /// <summary>Internal Acessors for StatusProvisioningError</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICloudErrorBody Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.StatusProvisioningError { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatusInternal)Status).ProvisioningError; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatusInternal)Status).ProvisioningError = value; }

        /// <summary>Internal Acessors for StorageProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.StorageProfile { get => (this._storageProfile = this._storageProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterStorageProfile()); set { {_storageProfile = value;} } }

        /// <summary>Internal Acessors for StorageProfileBlobCsiDriver</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileBlobCsiDriver Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.StorageProfileBlobCsiDriver { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).BlobCsiDriver; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).BlobCsiDriver = value; }

        /// <summary>Internal Acessors for StorageProfileDiskCsiDriver</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileDiskCsiDriver Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.StorageProfileDiskCsiDriver { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).DiskCsiDriver; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).DiskCsiDriver = value; }

        /// <summary>Internal Acessors for StorageProfileFileCsiDriver</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileFileCsiDriver Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.StorageProfileFileCsiDriver { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).FileCsiDriver; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).FileCsiDriver = value; }

        /// <summary>Internal Acessors for StorageProfileSnapshotController</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileSnapshotController Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.StorageProfileSnapshotController { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).SnapshotController; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).SnapshotController = value; }

        /// <summary>Internal Acessors for UpgradeSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IClusterUpgradeSettings Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.UpgradeSetting { get => (this._upgradeSetting = this._upgradeSetting ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ClusterUpgradeSettings()); set { {_upgradeSetting = value;} } }

        /// <summary>Internal Acessors for UpgradeSettingOverrideSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IUpgradeOverrideSettings Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.UpgradeSettingOverrideSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IClusterUpgradeSettingsInternal)UpgradeSetting).OverrideSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IClusterUpgradeSettingsInternal)UpgradeSetting).OverrideSetting = value; }

        /// <summary>Internal Acessors for WebAppRoutingIdentity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IUserAssignedIdentity Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.WebAppRoutingIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).WebAppRoutingIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).WebAppRoutingIdentity = value; }

        /// <summary>Internal Acessors for WebAppRoutingNginx</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileNginx Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.WebAppRoutingNginx { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).WebAppRoutingNginx; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).WebAppRoutingNginx = value; }

        /// <summary>Internal Acessors for WindowProfileGmsaProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IWindowsGmsaProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.WindowProfileGmsaProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).GmsaProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).GmsaProfile = value; }

        /// <summary>Internal Acessors for WindowsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.WindowsProfile { get => (this._windowsProfile = this._windowsProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterWindowsProfile()); set { {_windowsProfile = value;} } }

        /// <summary>Internal Acessors for WorkloadAutoScalerProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfile Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.WorkloadAutoScalerProfile { get => (this._workloadAutoScalerProfile = this._workloadAutoScalerProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterWorkloadAutoScalerProfile()); set { {_workloadAutoScalerProfile = value;} } }

        /// <summary>Internal Acessors for WorkloadAutoScalerProfileKeda</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileKeda Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.WorkloadAutoScalerProfileKeda { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileInternal)WorkloadAutoScalerProfile).Keda; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileInternal)WorkloadAutoScalerProfile).Keda = value; }

        /// <summary>Internal Acessors for WorkloadAutoScalerProfileVerticalPodAutoscaler</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesInternal.WorkloadAutoScalerProfileVerticalPodAutoscaler { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileInternal)WorkloadAutoScalerProfile).VerticalPodAutoscaler; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileInternal)WorkloadAutoScalerProfile).VerticalPodAutoscaler = value; }

        /// <summary>Backing field for <see cref="NetworkProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceNetworkProfile _networkProfile;

        /// <summary>The network configuration profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceNetworkProfile NetworkProfile { get => (this._networkProfile = this._networkProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ContainerServiceNetworkProfile()); set => this._networkProfile = value; }

        /// <summary>Ingress type for the default NginxIngressController custom resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NginxIngressControllerType? NginxDefaultIngressControllerType { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).NginxDefaultIngressControllerType; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).NginxDefaultIngressControllerType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NginxIngressControllerType)""); }

        /// <summary>Backing field for <see cref="NodeProvisioningProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeProvisioningProfile _nodeProvisioningProfile;

        /// <summary>Node provisioning settings that apply to the whole cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeProvisioningProfile NodeProvisioningProfile { get => (this._nodeProvisioningProfile = this._nodeProvisioningProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterNodeProvisioningProfile()); set => this._nodeProvisioningProfile = value; }

        /// <summary>
        /// This field has no effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will cause
        /// the default Karpenter NodePools to be deleted, which will in turn drain and delete the nodes associated with those pools.
        /// It is strongly recommended to not do this unless there are idle nodes ready to take the pods evicted by that action. If
        /// not specified, the default is Auto. For more information see aka.ms/something
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningDefaultNodePools? NodeProvisioningProfileDefaultNodePool { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeProvisioningProfileInternal)NodeProvisioningProfile).DefaultNodePool; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeProvisioningProfileInternal)NodeProvisioningProfile).DefaultNodePool = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningDefaultNodePools)""); }

        /// <summary>Once the mode it set to Auto, it cannot be changed back to Manual.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningMode? NodeProvisioningProfileMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeProvisioningProfileInternal)NodeProvisioningProfile).Mode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeProvisioningProfileInternal)NodeProvisioningProfile).Mode = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningMode)""); }

        /// <summary>Backing field for <see cref="NodeResourceGroup" /> property.</summary>
        private string _nodeResourceGroup;

        /// <summary>The name of the resource group containing agent pool nodes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string NodeResourceGroup { get => this._nodeResourceGroup; set => this._nodeResourceGroup = value; }

        /// <summary>Backing field for <see cref="NodeResourceGroupProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeResourceGroupProfile _nodeResourceGroupProfile;

        /// <summary>The node resource group configuration profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeResourceGroupProfile NodeResourceGroupProfile { get => (this._nodeResourceGroupProfile = this._nodeResourceGroupProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterNodeResourceGroupProfile()); set => this._nodeResourceGroupProfile = value; }

        /// <summary>The restriction level applied to the cluster's node resource group</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.RestrictionLevel? NodeResourceGroupProfileRestrictionLevel { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeResourceGroupProfileInternal)NodeResourceGroupProfile).RestrictionLevel; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeResourceGroupProfileInternal)NodeResourceGroupProfile).RestrictionLevel = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.RestrictionLevel)""); }

        /// <summary>Whether to enable Node Restriction</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? NodeRestrictionEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).NodeRestrictionEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).NodeRestrictionEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="OidcIssuerProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterOidcIssuerProfile _oidcIssuerProfile;

        /// <summary>The OIDC issuer profile of the Managed Cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterOidcIssuerProfile OidcIssuerProfile { get => (this._oidcIssuerProfile = this._oidcIssuerProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterOidcIssuerProfile()); set => this._oidcIssuerProfile = value; }

        /// <summary>Whether the OIDC issuer is enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? OidcIssuerProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterOidcIssuerProfileInternal)OidcIssuerProfile).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterOidcIssuerProfileInternal)OidcIssuerProfile).Enabled = value ?? default(bool); }

        /// <summary>The OIDC issuer url of the Managed Cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string OidcIssuerProfileIssuerUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterOidcIssuerProfileInternal)OidcIssuerProfile).IssuerUrl; }

        /// <summary>
        /// Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? OpenTelemetryLogEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).OpenTelemetryLogEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).OpenTelemetryLogEnabled = value ?? default(bool); }

        /// <summary>
        /// The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default port is 28331.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public long? OpenTelemetryLogPort { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).OpenTelemetryLogPort; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).OpenTelemetryLogPort = value ?? default(long); }

        /// <summary>Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? OpenTelemetryMetricEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).OpenTelemetryMetricEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).OpenTelemetryMetricEnabled = value ?? default(bool); }

        /// <summary>
        /// The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is 28333.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public long? OpenTelemetryMetricPort { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).OpenTelemetryMetricPort; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileInternal)AzureMonitorProfile).OpenTelemetryMetricPort = value ?? default(long); }

        /// <summary>
        /// Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade protections
        /// such as checking for deprecated API usage. Enable this option only with caution.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? OverrideSettingForceUpgrade { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IClusterUpgradeSettingsInternal)UpgradeSetting).OverrideSettingForceUpgrade; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IClusterUpgradeSettingsInternal)UpgradeSetting).OverrideSettingForceUpgrade = value ?? default(bool); }

        /// <summary>
        /// Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the effectiveness
        /// won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set by default.
        /// It must be set for the overrides to take effect.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public global::System.DateTime? OverrideSettingUntil { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IClusterUpgradeSettingsInternal)UpgradeSetting).OverrideSettingUntil; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IClusterUpgradeSettingsInternal)UpgradeSetting).OverrideSettingUntil = value ?? default(global::System.DateTime); }

        /// <summary>Certificate chain object name in Azure Key Vault.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string PluginCertChainObjectName { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).PluginCertChainObjectName; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).PluginCertChainObjectName = value ?? null; }

        /// <summary>Intermediate certificate object name in Azure Key Vault.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string PluginCertObjectName { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).PluginCertObjectName; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).PluginCertObjectName = value ?? null; }

        /// <summary>Intermediate certificate private key object name in Azure Key Vault.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string PluginKeyObjectName { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).PluginKeyObjectName; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).PluginKeyObjectName = value ?? null; }

        /// <summary>The resource ID of the Key Vault.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string PluginKeyVaultId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).PluginKeyVaultId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).PluginKeyVaultId = value ?? null; }

        /// <summary>Root certificate object name in Azure Key Vault.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string PluginRootCertObjectName { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).PluginRootCertObjectName; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).PluginRootCertObjectName = value ?? null; }

        /// <summary>Backing field for <see cref="PodIdentityProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfile _podIdentityProfile;

        /// <summary>
        /// See [use AAD pod identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on AAD pod
        /// identity integration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfile PodIdentityProfile { get => (this._podIdentityProfile = this._podIdentityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterPodIdentityProfile()); set => this._podIdentityProfile = value; }

        /// <summary>
        /// Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing.
        /// See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
        /// for more information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? PodIdentityProfileAllowNetworkPluginKubenet { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfileInternal)PodIdentityProfile).AllowNetworkPluginKubenet; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfileInternal)PodIdentityProfile).AllowNetworkPluginKubenet = value ?? default(bool); }

        /// <summary>Whether the pod identity addon is enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? PodIdentityProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfileInternal)PodIdentityProfile).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfileInternal)PodIdentityProfile).Enabled = value ?? default(bool); }

        /// <summary>The pod identities to use in the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentity[] PodIdentityProfileUserAssignedIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfileInternal)PodIdentityProfile).UserAssignedIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfileInternal)PodIdentityProfile).UserAssignedIdentity = value ?? null /* arrayOf */; }

        /// <summary>The pod identity exceptions to allow.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityException[] PodIdentityProfileUserAssignedIdentityException { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfileInternal)PodIdentityProfile).UserAssignedIdentityException; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfileInternal)PodIdentityProfile).UserAssignedIdentityException = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="PowerState" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPowerState _powerState;

        /// <summary>The Power State of the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPowerState PowerState { get => (this._powerState = this._powerState ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.PowerState()); }

        /// <summary>Tells whether the cluster is Running or Stopped</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Code? PowerStateCode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPowerStateInternal)PowerState).Code; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPowerStateInternal)PowerState).Code = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Code)""); }

        /// <summary>Backing field for <see cref="PrivateFqdn" /> property.</summary>
        private string _privateFqdn;

        /// <summary>The FQDN of private cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string PrivateFqdn { get => this._privateFqdn; }

        /// <summary>Backing field for <see cref="PrivateLinkResource" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPrivateLinkResource[] _privateLinkResource;

        /// <summary>Private link resources associated with the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPrivateLinkResource[] PrivateLinkResource { get => this._privateLinkResource; set => this._privateLinkResource = value; }

        /// <summary>
        /// An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string ProvisioningErrorCode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatusInternal)Status).ProvisioningErrorCode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatusInternal)Status).ProvisioningErrorCode = value ?? null; }

        /// <summary>A list of additional details about the error.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICloudErrorBody[] ProvisioningErrorDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatusInternal)Status).ProvisioningErrorDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatusInternal)Status).ProvisioningErrorDetail = value ?? null /* arrayOf */; }

        /// <summary>
        /// A message describing the error, intended to be suitable for display in a user interface.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string ProvisioningErrorMessage { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatusInternal)Status).ProvisioningErrorMessage; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatusInternal)Status).ProvisioningErrorMessage = value ?? null; }

        /// <summary>
        /// The target of the particular error. For example, the name of the property in error.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string ProvisioningErrorTarget { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatusInternal)Status).ProvisioningErrorTarget; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatusInternal)Status).ProvisioningErrorTarget = value ?? null; }

        /// <summary>Backing field for <see cref="ProvisioningState" /> property.</summary>
        private string _provisioningState;

        /// <summary>The current provisioning state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string ProvisioningState { get => this._provisioningState; }

        /// <summary>Backing field for <see cref="PublicNetworkAccess" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess? _publicNetworkAccess;

        /// <summary>Allow or deny public network access for AKS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess? PublicNetworkAccess { get => this._publicNetworkAccess; set => this._publicNetworkAccess = value; }

        /// <summary>Backing field for <see cref="ResourceUid" /> property.</summary>
        private string _resourceUid;

        /// <summary>
        /// The resourceUID uniquely identifies ManagedClusters that reuse ARM ResourceIds (i.e: create, delete, create sequence)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public string ResourceUid { get => this._resourceUid; }

        /// <summary>List of namespaces excluded from Safeguards checks</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string[] SafeguardProfileExcludedNamespace { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfileInternal)SafeguardsProfile).ExcludedNamespace; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfileInternal)SafeguardsProfile).ExcludedNamespace = value ?? null /* arrayOf */; }

        /// <summary>
        /// The Safeguards level to be used. By default, Safeguards is enabled for all namespaces except those that AKS excludes via
        /// systemExcludedNamespaces
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Level? SafeguardProfileLevel { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfileInternal)SafeguardsProfile).Level; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfileInternal)SafeguardsProfile).Level = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Level)""); }

        /// <summary>List of namespaces specified by AKS to be excluded from Safeguards</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string[] SafeguardProfileSystemExcludedNamespace { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfileInternal)SafeguardsProfile).SystemExcludedNamespace; }

        /// <summary>The version of constraints to use</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string SafeguardProfileVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfileInternal)SafeguardsProfile).Version; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfileInternal)SafeguardsProfile).Version = value ?? null; }

        /// <summary>Backing field for <see cref="SafeguardsProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfile _safeguardsProfile;

        /// <summary>The Safeguards profile holds all the safeguards information for a given cluster</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfile SafeguardsProfile { get => (this._safeguardsProfile = this._safeguardsProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.SafeguardsProfile()); set => this._safeguardsProfile = value; }

        /// <summary>
        /// In use only while registry access granted by secret rather than managed identity. Set whether to grant the Defender gating
        /// agent access to the cluster's secrets for pulling images from registries. If secret access is denied and the registry
        /// requires pull secrets, the add-on will not perform any image validation. Default value is false.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? SecurityGatingAllowSecretAccess { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).SecurityGatingAllowSecretAccess; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).SecurityGatingAllowSecretAccess = value ?? default(bool); }

        /// <summary>
        /// Whether to enable Defender security gating. When enabled, the gating feature will scan container images and audit or block
        /// the deployment of images that do not meet security standards according to the configured security rules.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? SecurityGatingEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).SecurityGatingEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).SecurityGatingEnabled = value ?? default(bool); }

        /// <summary>
        /// List of identities that the admission controller will make use of in order to pull security artifacts from the registry.
        /// These are the same identities used by the cluster to pull container images. Each identity provided should have federated
        /// identity credential attached to it.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem[] SecurityGatingIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).SecurityGatingIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).SecurityGatingIdentity = value ?? null /* arrayOf */; }

        /// <summary>Whether to enable Defender threat detection</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? SecurityMonitoringEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).SecurityMonitoringEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).SecurityMonitoringEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="SecurityProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfile _securityProfile;

        /// <summary>Security profile for the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfile SecurityProfile { get => (this._securityProfile = this._securityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterSecurityProfile()); set => this._securityProfile = value; }

        /// <summary>
        /// A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the cluster. For more information
        /// see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public byte[][] SecurityProfileCustomCaTrustCertificate { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).CustomCaTrustCertificate; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).CustomCaTrustCertificate = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="ServiceMeshProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfile _serviceMeshProfile;

        /// <summary>Service mesh profile for a managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfile ServiceMeshProfile { get => (this._serviceMeshProfile = this._serviceMeshProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ServiceMeshProfile()); set => this._serviceMeshProfile = value; }

        /// <summary>Mode of the service mesh.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ServiceMeshMode? ServiceMeshProfileMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).Mode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfileInternal)ServiceMeshProfile).Mode = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ServiceMeshMode)""); }

        /// <summary>Backing field for <see cref="ServicePrincipalProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterServicePrincipalProfile _servicePrincipalProfile;

        /// <summary>
        /// Information about a service principal identity for the cluster to use for manipulating Azure APIs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterServicePrincipalProfile ServicePrincipalProfile { get => (this._servicePrincipalProfile = this._servicePrincipalProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterServicePrincipalProfile()); set => this._servicePrincipalProfile = value; }

        /// <summary>The ID for the service principal.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string ServicePrincipalProfileClientId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterServicePrincipalProfileInternal)ServicePrincipalProfile).ClientId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterServicePrincipalProfileInternal)ServicePrincipalProfile).ClientId = value ?? null; }

        /// <summary>The secret password associated with the service principal in plain text.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string ServicePrincipalProfileSecret { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterServicePrincipalProfileInternal)ServicePrincipalProfile).Secret; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterServicePrincipalProfileInternal)ServicePrincipalProfile).Secret = value ?? null; }

        /// <summary>Whether to enable Snapshot Controller. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? SnapshotControllerEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).SnapshotControllerEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileInternal)StorageProfile).SnapshotControllerEnabled = value ?? default(bool); }

        /// <summary>
        /// The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceSshPublicKey[] SshPublicKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceLinuxProfileInternal)LinuxProfile).SshPublicKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceLinuxProfileInternal)LinuxProfile).SshPublicKey = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="Status" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatus _status;

        /// <summary>Contains read-only information about the Managed Cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatus Status { get => (this._status = this._status ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterStatus()); set => this._status = value; }

        /// <summary>Backing field for <see cref="StorageProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfile _storageProfile;

        /// <summary>Storage profile for the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfile StorageProfile { get => (this._storageProfile = this._storageProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterStorageProfile()); set => this._storageProfile = value; }

        /// <summary>Backing field for <see cref="SupportPlan" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan? _supportPlan;

        /// <summary>
        /// The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan? SupportPlan { get => this._supportPlan; set => this._supportPlan = value; }

        /// <summary>Backing field for <see cref="UpgradeSetting" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IClusterUpgradeSettings _upgradeSetting;

        /// <summary>Settings for upgrading a cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IClusterUpgradeSettings UpgradeSetting { get => (this._upgradeSetting = this._upgradeSetting ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ClusterUpgradeSettings()); set => this._upgradeSetting = value; }

        /// <summary>Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AddonAutoscaling? VerticalPodAutoscalerAddonAutoscaling { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileInternal)WorkloadAutoScalerProfile).VerticalPodAutoscalerAddonAutoscaling; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileInternal)WorkloadAutoScalerProfile).VerticalPodAutoscalerAddonAutoscaling = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AddonAutoscaling)""); }

        /// <summary>Whether to enable VPA add-on in cluster. Default value is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? VerticalPodAutoscalerEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileInternal)WorkloadAutoScalerProfile).VerticalPodAutoscalerEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileInternal)WorkloadAutoScalerProfile).VerticalPodAutoscalerEnabled = value ?? default(bool); }

        /// <summary>
        /// Resource IDs of the DNS zones to be associated with the Web App Routing add-on. Used only when Web App Routing is enabled.
        /// Public and private DNS zones can be in different resource groups, but all public DNS zones must be in the same resource
        /// group and all private DNS zones must be in the same resource group.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string[] WebAppRoutingDnsZoneResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).WebAppRoutingDnsZoneResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).WebAppRoutingDnsZoneResourceId = value ?? null /* arrayOf */; }

        /// <summary>Whether to enable Web App Routing.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? WebAppRoutingEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).WebAppRoutingEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileInternal)IngressProfile).WebAppRoutingEnabled = value ?? default(bool); }

        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:**
        /// 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters
        /// <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:**
        /// "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string WindowProfileAdminPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).AdminPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).AdminPassword = value ?? null; }

        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm",
        /// "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0",
        /// "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string WindowProfileAdminUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).AdminUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).AdminUsername = value ?? null; }

        /// <summary>
        /// For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? WindowProfileEnableCsiProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).EnableCsiProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).EnableCsiProxy = value ?? default(bool); }

        /// <summary>
        /// The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/)
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType? WindowProfileLicenseType { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).LicenseType; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfileInternal)WindowsProfile).LicenseType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType)""); }

        /// <summary>Backing field for <see cref="WindowsProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfile _windowsProfile;

        /// <summary>The profile for Windows VMs in the Managed Cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfile WindowsProfile { get => (this._windowsProfile = this._windowsProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterWindowsProfile()); set => this._windowsProfile = value; }

        /// <summary>Backing field for <see cref="WorkloadAutoScalerProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfile _workloadAutoScalerProfile;

        /// <summary>Workload Auto-scaler profile for the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfile WorkloadAutoScalerProfile { get => (this._workloadAutoScalerProfile = this._workloadAutoScalerProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ManagedClusterWorkloadAutoScalerProfile()); set => this._workloadAutoScalerProfile = value; }

        /// <summary>Whether to enable workload identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? WorkloadIdentityEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).WorkloadIdentityEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileInternal)SecurityProfile).WorkloadIdentityEnabled = value ?? default(bool); }

        /// <summary>Creates an new <see cref="ManagedClusterProperties" /> instance.</summary>
        public ManagedClusterProperties()
        {

        }
    }
    /// Properties of the managed cluster.
    public partial interface IManagedClusterProperties :
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IJsonSerializable
    {
        /// <summary>The list of AAD group object IDs that will have admin role of the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of AAD group object IDs that will have admin role of the cluster.",
        SerializedName = @"adminGroupObjectIDs",
        PossibleTypes = new [] { typeof(string) })]
        string[] AadProfileAdminGroupObjectID { get; set; }
        /// <summary>
        /// (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"clientAppID",
        PossibleTypes = new [] { typeof(string) })]
        string AadProfileClientAppId { get; set; }
        /// <summary>Whether to enable Azure RBAC for Kubernetes authorization.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Azure RBAC for Kubernetes authorization.",
        SerializedName = @"enableAzureRBAC",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AadProfileEnableAzureRbac { get; set; }
        /// <summary>Whether to enable managed AAD.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable managed AAD.",
        SerializedName = @"managed",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AadProfileManaged { get; set; }
        /// <summary>
        /// (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"serverAppID",
        PossibleTypes = new [] { typeof(string) })]
        string AadProfileServerAppId { get; set; }
        /// <summary>
        /// (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"serverAppSecret",
        PossibleTypes = new [] { typeof(string) })]
        string AadProfileServerAppSecret { get; set; }
        /// <summary>
        /// The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.",
        SerializedName = @"tenantID",
        PossibleTypes = new [] { typeof(string) })]
        string AadProfileTenantId { get; set; }
        /// <summary>The profile of managed cluster add-on.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The profile of managed cluster add-on.",
        SerializedName = @"addonProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAddonProfiles) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAddonProfiles AddonProfile { get; set; }
        /// <summary>The agent pool properties.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The agent pool properties.",
        SerializedName = @"agentPoolProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAgentPoolProfile) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAgentPoolProfile[] AgentPoolProfile { get; set; }
        /// <summary>Indicates if AI toolchain operator enabled or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates if AI toolchain operator  enabled or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AiToolchainOperatorProfileEnabled { get; set; }
        /// <summary>
        /// IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use
        /// Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized
        /// IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).",
        SerializedName = @"authorizedIPRanges",
        PossibleTypes = new [] { typeof(string) })]
        string[] ApiServerAccessProfileAuthorizedIPRange { get; set; }
        /// <summary>Whether to disable run command for the cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to disable run command for the cluster or not.",
        SerializedName = @"disableRunCommand",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApiServerAccessProfileDisableRunCommand { get; set; }
        /// <summary>
        /// For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).",
        SerializedName = @"enablePrivateCluster",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApiServerAccessProfileEnablePrivateCluster { get; set; }
        /// <summary>Whether to create additional public FQDN for private cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to create additional public FQDN for private cluster or not.",
        SerializedName = @"enablePrivateClusterPublicFQDN",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApiServerAccessProfileEnablePrivateClusterPublicFqdn { get; set; }
        /// <summary>Whether to enable apiserver vnet integration for the cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable apiserver vnet integration for the cluster or not.",
        SerializedName = @"enableVnetIntegration",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApiServerAccessProfileEnableVnetIntegration { get; set; }
        /// <summary>
        /// The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
        /// Allowed values are 'system' and 'none'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are 'system' and 'none'.",
        SerializedName = @"privateDNSZone",
        PossibleTypes = new [] { typeof(string) })]
        string ApiServerAccessProfilePrivateDnsZone { get; set; }
        /// <summary>
        /// It is required when: 1. creating a new cluster with BYO Vnet; 2. updating an existing cluster to enable apiserver vnet
        /// integration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"It is required when: 1. creating a new cluster with BYO Vnet; 2. updating an existing cluster to enable apiserver vnet integration.",
        SerializedName = @"subnetId",
        PossibleTypes = new [] { typeof(string) })]
        string ApiServerAccessProfileSubnetId { get; set; }
        /// <summary>Indicates if Application Monitoring Auto Instrumentation is enabled or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates if Application Monitoring Auto Instrumentation is enabled or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AutoInstrumentationEnabled { get; set; }
        /// <summary>Valid values are 'true' and 'false'</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Valid values are 'true' and 'false'",
        SerializedName = @"balance-similar-node-groups",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileBalanceSimilarNodeGroup { get; set; }
        /// <summary>
        /// If set to true, all daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot
        /// be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset
        /// pods are deleted or evicted.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, all daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods are deleted or evicted.",
        SerializedName = @"daemonset-eviction-for-empty-nodes",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AutoScalerProfileDaemonsetEvictionForEmptyNode { get; set; }
        /// <summary>
        /// If set to true, all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod
        /// cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring
        /// that daemonset pods are deleted or evicted.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods are deleted or evicted.",
        SerializedName = @"daemonset-eviction-for-occupied-nodes",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AutoScalerProfileDaemonsetEvictionForOccupiedNode { get; set; }
        /// <summary>Available values are: 'least-waste', 'most-pods', 'priority', 'random'.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Available values are: 'least-waste', 'most-pods', 'priority', 'random'.",
        SerializedName = @"expander",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander? AutoScalerProfileExpander { get; set; }
        /// <summary>
        /// If set to true, the resources used by daemonset will be taken into account when making scaling down decisions.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, the resources used by daemonset will be taken into account when making scaling down decisions.",
        SerializedName = @"ignore-daemonsets-utilization",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AutoScalerProfileIgnoreDaemonsetsUtilization { get; set; }
        /// <summary>The default is 10.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 10.",
        SerializedName = @"max-empty-bulk-delete",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileMaxEmptyBulkDelete { get; set; }
        /// <summary>The default is 600.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 600.",
        SerializedName = @"max-graceful-termination-sec",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileMaxGracefulTerminationSec { get; set; }
        /// <summary>
        /// The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"max-node-provision-time",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileMaxNodeProvisionTime { get; set; }
        /// <summary>The default is 45. The maximum is 100 and the minimum is 0.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 45. The maximum is 100 and the minimum is 0.",
        SerializedName = @"max-total-unready-percentage",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileMaxTotalUnreadyPercentage { get; set; }
        /// <summary>
        /// For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all
        /// the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be
        /// an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).",
        SerializedName = @"new-pod-scale-up-delay",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileNewPodScaleUpDelay { get; set; }
        /// <summary>This must be an integer. The default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This must be an integer. The default is 3.",
        SerializedName = @"ok-total-unready-count",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileOkTotalUnreadyCount { get; set; }
        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-add",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownDelayAfterAdd { get; set; }
        /// <summary>
        /// The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m)
        /// is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-delete",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownDelayAfterDelete { get; set; }
        /// <summary>
        /// The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-failure",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownDelayAfterFailure { get; set; }
        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-unneeded-time",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownUnneededTime { get; set; }
        /// <summary>
        /// The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-unready-time",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownUnreadyTime { get; set; }
        /// <summary>The default is '0.5'.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '0.5'.",
        SerializedName = @"scale-down-utilization-threshold",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownUtilizationThreshold { get; set; }
        /// <summary>The default is '10'. Values must be an integer number of seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10'. Values must be an integer number of seconds.",
        SerializedName = @"scan-interval",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScanInterval { get; set; }
        /// <summary>The default is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is true.",
        SerializedName = @"skip-nodes-with-local-storage",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileSkipNodesWithLocalStorage { get; set; }
        /// <summary>The default is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is true.",
        SerializedName = @"skip-nodes-with-system-pods",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileSkipNodesWithSystemPod { get; set; }
        /// <summary>
        /// The default is Unmanaged, but may change to either NodeImage or SecurityPatch at GA.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is Unmanaged, but may change to either NodeImage or SecurityPatch at GA.",
        SerializedName = @"nodeOSUpgradeChannel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeOSUpgradeChannel) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeOSUpgradeChannel? AutoUpgradeProfileNodeOSUpgradeChannel { get; set; }
        /// <summary>
        /// For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).",
        SerializedName = @"upgradeChannel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel? AutoUpgradeProfileUpgradeChannel { get; set; }
        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Azure Key Vault key management service. The default is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AzureKeyVaultKmEnabled { get; set; }
        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.",
        SerializedName = @"keyId",
        PossibleTypes = new [] { typeof(string) })]
        string AzureKeyVaultKmKeyId { get; set; }
        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.",
        SerializedName = @"keyVaultNetworkAccess",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes? AzureKeyVaultKmKeyVaultNetworkAccess { get; set; }
        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.",
        SerializedName = @"keyVaultResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string AzureKeyVaultKmKeyVaultResourceId { get; set; }
        /// <summary>
        /// The Azure Portal requires certain Cross-Origin Resource Sharing (CORS) headers to be sent in some responses, which Kubernetes
        /// APIServer doesn't handle by default. This special FQDN supports CORS, allowing the Azure Portal to function properly.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The Azure Portal requires certain Cross-Origin Resource Sharing (CORS) headers to be sent in some responses, which Kubernetes APIServer doesn't handle by default. This special FQDN supports CORS, allowing the Azure Portal to function properly.",
        SerializedName = @"azurePortalFQDN",
        PossibleTypes = new [] { typeof(string) })]
        string AzurePortalFqdn { get;  }
        /// <summary>Whether to enable AzureBlob CSI Driver. The default value is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureBlob CSI Driver. The default value is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BlobCsiDriverEnabled { get; set; }
        /// <summary>The source where the artifacts are downloaded from.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The source where the artifacts are downloaded from.",
        SerializedName = @"artifactSource",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ArtifactSource) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ArtifactSource? BootstrapProfileArtifactSource { get; set; }
        /// <summary>
        /// The resource Id of Azure Container Registry. The registry must have private network access, premium SKU and zone redundancy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource Id of Azure Container Registry. The registry must have private network access, premium SKU and zone redundancy.",
        SerializedName = @"containerRegistryId",
        PossibleTypes = new [] { typeof(string) })]
        string BootstrapProfileContainerRegistryId { get; set; }
        /// <summary>Istio egress gateways.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Istio egress gateways.",
        SerializedName = @"egressGateways",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioEgressGateway) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioEgressGateway[] ComponentEgressGateway { get; set; }
        /// <summary>Istio ingress gateways.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Istio ingress gateways.",
        SerializedName = @"ingressGateways",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioIngressGateway) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioIngressGateway[] ComponentIngressGateway { get; set; }
        /// <summary>
        /// Indicates whether custom metrics collection has to be disabled or not. If not specified the default is false. No custom
        /// metrics will be emitted if this field is false but the container insights enabled field is false
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether custom metrics collection has to be disabled or not. If not specified the default is false. No custom metrics will be emitted if this field is false but the container insights enabled field is false",
        SerializedName = @"disableCustomMetrics",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ContainerInsightDisableCustomMetric { get; set; }
        /// <summary>
        /// Indicates whether prometheus metrics scraping is disabled or not. If not specified the default is false. No prometheus
        /// metrics will be emitted if this field is false but the container insights enabled field is false
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether prometheus metrics scraping is disabled or not. If not specified the default is false. No prometheus metrics will be emitted if this field is false but the container insights enabled field is false",
        SerializedName = @"disablePrometheusMetricsScraping",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ContainerInsightDisablePrometheusMetricsScraping { get; set; }
        /// <summary>Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ContainerInsightEnabled { get; set; }
        /// <summary>
        /// Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing Azure Monitor Container Insights Logs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing Azure Monitor Container Insights Logs.",
        SerializedName = @"logAnalyticsWorkspaceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string ContainerInsightLogAnalyticsWorkspaceResourceId { get; set; }
        /// <summary>The syslog host port. If not specified, the default port is 28330.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The syslog host port. If not specified, the default port is 28330.",
        SerializedName = @"syslogPort",
        PossibleTypes = new [] { typeof(long) })]
        long? ContainerInsightSyslogPort { get; set; }
        /// <summary>
        /// The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable this feature. Enabling this will add Kubernetes
        /// Namespace and Deployment details to the Cost Analysis views in the Azure portal. If not specified, the default is false.
        /// For more information see aka.ms/aks/docs/cost-analysis.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal. If not specified, the default is false. For more information see aka.ms/aks/docs/cost-analysis.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CostAnalysisEnabled { get; set; }
        /// <summary>This is the ARM ID of the source object to be used to create the target object.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is the ARM ID of the source object to be used to create the target object.",
        SerializedName = @"sourceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string CreationDataSourceResourceId { get; set; }
        /// <summary>The version of Kubernetes the Managed Cluster is running.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The version of Kubernetes the Managed Cluster is running.",
        SerializedName = @"currentKubernetesVersion",
        PossibleTypes = new [] { typeof(string) })]
        string CurrentKubernetesVersion { get;  }
        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.",
        SerializedName = @"logAnalyticsWorkspaceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string DefenderLogAnalyticsWorkspaceResourceId { get; set; }
        /// <summary>
        /// If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters
        /// that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).",
        SerializedName = @"disableLocalAccounts",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DisableLocalAccount { get; set; }
        /// <summary>Whether to enable AzureDisk CSI Driver. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureDisk CSI Driver. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DiskCsiDriverEnabled { get; set; }
        /// <summary>The version of AzureDisk CSI Driver. The default value is v1.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The version of AzureDisk CSI Driver. The default value is v1.",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string DiskCsiDriverVersion { get; set; }
        /// <summary>
        /// This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'",
        SerializedName = @"diskEncryptionSetID",
        PossibleTypes = new [] { typeof(string) })]
        string DiskEncryptionSetId { get; set; }
        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This cannot be updated once the Managed Cluster has been created.",
        SerializedName = @"dnsPrefix",
        PossibleTypes = new [] { typeof(string) })]
        string DnsPrefix { get; set; }
        /// <summary>
        /// The default value is false. It can be enabled/disabled on creation and updating of the managed cluster. See [https://aka.ms/NamespaceARMResource](https://aka.ms/NamespaceARMResource)
        /// for more details on Namespace as a ARM Resource.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default value is false. It can be enabled/disabled on creation and updating of the managed cluster. See [https://aka.ms/NamespaceARMResource](https://aka.ms/NamespaceARMResource) for more details on Namespace as a ARM Resource.",
        SerializedName = @"enableNamespaceResources",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnableNamespaceResource { get; set; }
        /// <summary>Whether to enable Kubernetes Role-Based Access Control.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Kubernetes Role-Based Access Control.",
        SerializedName = @"enableRBAC",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnableRbac { get; set; }
        /// <summary>Whether to enable AzureFile CSI Driver. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureFile CSI Driver. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? FileCsiDriverEnabled { get; set; }
        /// <summary>The FQDN of the master pool.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The FQDN of the master pool.",
        SerializedName = @"fqdn",
        PossibleTypes = new [] { typeof(string) })]
        string Fqdn { get;  }
        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This cannot be updated once the Managed Cluster has been created.",
        SerializedName = @"fqdnSubdomain",
        PossibleTypes = new [] { typeof(string) })]
        string FqdnSubdomain { get; set; }
        /// <summary>
        /// Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet
        /// which is used to create the managed cluster.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.",
        SerializedName = @"dnsServer",
        PossibleTypes = new [] { typeof(string) })]
        string GmsaProfileDnsServer { get; set; }
        /// <summary>Specifies whether to enable Windows gMSA in the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether to enable Windows gMSA in the managed cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? GmsaProfileEnabled { get; set; }
        /// <summary>
        /// Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the
        /// vnet which is used to create the managed cluster.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.",
        SerializedName = @"rootDomainName",
        PossibleTypes = new [] { typeof(string) })]
        string GmsaProfileRootDomainName { get; set; }
        /// <summary>
        /// A read-only list of all endpoints for which traffic should not be sent to the proxy. This list is a superset of noProxy
        /// and values injected by AKS.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"A read-only list of all endpoints for which traffic should not be sent to the proxy. This list is a superset of noProxy and values injected by AKS.",
        SerializedName = @"effectiveNoProxy",
        PossibleTypes = new [] { typeof(string) })]
        string[] HttpProxyConfigEffectiveNoProxy { get;  }
        /// <summary>
        /// Whether to enable HTTP proxy. When disabled, the specified proxy configuration will be not be set on pods and nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable HTTP proxy. When disabled, the specified proxy configuration will be not be set on pods and nodes.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HttpProxyConfigEnabled { get; set; }
        /// <summary>The HTTP proxy server endpoint to use.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The HTTP proxy server endpoint to use.",
        SerializedName = @"httpProxy",
        PossibleTypes = new [] { typeof(string) })]
        string HttpProxyConfigHttpProxy { get; set; }
        /// <summary>The HTTPS proxy server endpoint to use.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The HTTPS proxy server endpoint to use.",
        SerializedName = @"httpsProxy",
        PossibleTypes = new [] { typeof(string) })]
        string HttpProxyConfigHttpsProxy { get; set; }
        /// <summary>The endpoints that should not go through proxy.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoints that should not go through proxy.",
        SerializedName = @"noProxy",
        PossibleTypes = new [] { typeof(string) })]
        string[] HttpProxyConfigNoProxy { get; set; }
        /// <summary>Alternative CA cert to use for connecting to proxy servers.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Alternative CA cert to use for connecting to proxy servers.",
        SerializedName = @"trustedCa",
        PossibleTypes = new [] { typeof(string) })]
        string HttpProxyConfigTrustedCa { get; set; }
        /// <summary>The client ID of the user assigned identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The client ID of the user assigned identity.",
        SerializedName = @"clientId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityClientId { get; set; }
        /// <summary>The object ID of the user assigned identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The object ID of the user assigned identity.",
        SerializedName = @"objectId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityObjectId { get; set; }
        /// <summary>
        /// The user identity associated with the managed cluster. This identity will be used by the kubelet. Only one user assigned
        /// identity is allowed. The only accepted key is "kubeletidentity", with value of "resourceId": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}".
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The user identity associated with the managed cluster. This identity will be used by the kubelet. Only one user assigned identity is allowed. The only accepted key is ""kubeletidentity"", with value of ""resourceId"": ""/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}"".",
        SerializedName = @"identityProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesIdentityProfile) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesIdentityProfile IdentityProfile { get; set; }
        /// <summary>The resource ID of the user assigned identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource ID of the user assigned identity.",
        SerializedName = @"resourceId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityResourceId { get; set; }
        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Image Cleaner on AKS cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ImageCleanerEnabled { get; set; }
        /// <summary>Image Cleaner scanning interval in hours.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Image Cleaner scanning interval in hours.",
        SerializedName = @"intervalHours",
        PossibleTypes = new [] { typeof(int) })]
        int? ImageCleanerIntervalHour { get; set; }
        /// <summary>Whether to enable image integrity. The default value is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable image integrity. The default value is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ImageIntegrityEnabled { get; set; }
        /// <summary>
        /// The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary
        /// upgrade is in progress, this can only hold two consecutive values. For more information, see: https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary upgrade is in progress, this can only hold two consecutive values. For more information, see: https://learn.microsoft.com/en-us/azure/aks/istio-upgrade",
        SerializedName = @"revisions",
        PossibleTypes = new [] { typeof(string) })]
        string[] IstioRevision { get; set; }
        /// <summary>Whether to enable KEDA.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable KEDA.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? KedaEnabled { get; set; }
        /// <summary>
        /// Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.",
        SerializedName = @"metricAnnotationsAllowList",
        PossibleTypes = new [] { typeof(string) })]
        string KubeStateMetricAnnotationsAllowList { get; set; }
        /// <summary>
        /// Comma-separated list of Kubernetes annotations keys that will be used in the resource's labels metric.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Comma-separated list of Kubernetes annotations keys that will be used in the resource's labels metric. ",
        SerializedName = @"metricLabelsAllowlist",
        PossibleTypes = new [] { typeof(string) })]
        string KubeStateMetricLabelsAllowlist { get; set; }
        /// <summary>
        /// When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed
        /// sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed,
        /// however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster)
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed, however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more details.",
        SerializedName = @"kubernetesVersion",
        PossibleTypes = new [] { typeof(string) })]
        string KubernetesVersion { get; set; }
        /// <summary>The administrator username to use for Linux VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The administrator username to use for Linux VMs.",
        SerializedName = @"adminUsername",
        PossibleTypes = new [] { typeof(string) })]
        string LinuxProfileAdminUsername { get; set; }
        /// <summary>The max number of agent pools for the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The max number of agent pools for the managed cluster.",
        SerializedName = @"maxAgentPools",
        PossibleTypes = new [] { typeof(int) })]
        int? MaxAgentPool { get;  }
        /// <summary>Whether to enable the Prometheus collector</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable the Prometheus collector",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? MetricEnabled { get; set; }
        /// <summary>The network configuration profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The network configuration profile.",
        SerializedName = @"networkProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceNetworkProfile) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceNetworkProfile NetworkProfile { get; set; }
        /// <summary>Ingress type for the default NginxIngressController custom resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Ingress type for the default NginxIngressController custom resource",
        SerializedName = @"defaultIngressControllerType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NginxIngressControllerType) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NginxIngressControllerType? NginxDefaultIngressControllerType { get; set; }
        /// <summary>
        /// This field has no effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will cause
        /// the default Karpenter NodePools to be deleted, which will in turn drain and delete the nodes associated with those pools.
        /// It is strongly recommended to not do this unless there are idle nodes ready to take the pods evicted by that action. If
        /// not specified, the default is Auto. For more information see aka.ms/something
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This field has no effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will cause the default Karpenter NodePools to be deleted, which will in turn drain and delete the nodes associated with those pools. It is strongly recommended to not do this unless there are idle nodes ready to take the pods evicted by that action. If not specified, the default is Auto. For more information see aka.ms/something",
        SerializedName = @"defaultNodePools",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningDefaultNodePools) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningDefaultNodePools? NodeProvisioningProfileDefaultNodePool { get; set; }
        /// <summary>Once the mode it set to Auto, it cannot be changed back to Manual.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Once the mode it set to Auto, it cannot be changed back to Manual.",
        SerializedName = @"mode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningMode? NodeProvisioningProfileMode { get; set; }
        /// <summary>The name of the resource group containing agent pool nodes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the resource group containing agent pool nodes.",
        SerializedName = @"nodeResourceGroup",
        PossibleTypes = new [] { typeof(string) })]
        string NodeResourceGroup { get; set; }
        /// <summary>The restriction level applied to the cluster's node resource group</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The restriction level applied to the cluster's node resource group",
        SerializedName = @"restrictionLevel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.RestrictionLevel) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.RestrictionLevel? NodeResourceGroupProfileRestrictionLevel { get; set; }
        /// <summary>Whether to enable Node Restriction</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Node Restriction",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NodeRestrictionEnabled { get; set; }
        /// <summary>Whether the OIDC issuer is enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether the OIDC issuer is enabled.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OidcIssuerProfileEnabled { get; set; }
        /// <summary>The OIDC issuer url of the Managed Cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The OIDC issuer url of the Managed Cluster.",
        SerializedName = @"issuerURL",
        PossibleTypes = new [] { typeof(string) })]
        string OidcIssuerProfileIssuerUrl { get;  }
        /// <summary>
        /// Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OpenTelemetryLogEnabled { get; set; }
        /// <summary>
        /// The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default port is 28331.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default port is 28331.",
        SerializedName = @"port",
        PossibleTypes = new [] { typeof(long) })]
        long? OpenTelemetryLogPort { get; set; }
        /// <summary>Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OpenTelemetryMetricEnabled { get; set; }
        /// <summary>
        /// The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is 28333.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is 28333.",
        SerializedName = @"port",
        PossibleTypes = new [] { typeof(long) })]
        long? OpenTelemetryMetricPort { get; set; }
        /// <summary>
        /// Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade protections
        /// such as checking for deprecated API usage. Enable this option only with caution.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade protections such as checking for deprecated API usage. Enable this option only with caution.",
        SerializedName = @"forceUpgrade",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OverrideSettingForceUpgrade { get; set; }
        /// <summary>
        /// Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the effectiveness
        /// won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set by default.
        /// It must be set for the overrides to take effect.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the effectiveness won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set by default. It must be set for the overrides to take effect.",
        SerializedName = @"until",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? OverrideSettingUntil { get; set; }
        /// <summary>Certificate chain object name in Azure Key Vault.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Certificate chain object name in Azure Key Vault.",
        SerializedName = @"certChainObjectName",
        PossibleTypes = new [] { typeof(string) })]
        string PluginCertChainObjectName { get; set; }
        /// <summary>Intermediate certificate object name in Azure Key Vault.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Intermediate certificate object name in Azure Key Vault.",
        SerializedName = @"certObjectName",
        PossibleTypes = new [] { typeof(string) })]
        string PluginCertObjectName { get; set; }
        /// <summary>Intermediate certificate private key object name in Azure Key Vault.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Intermediate certificate private key object name in Azure Key Vault.",
        SerializedName = @"keyObjectName",
        PossibleTypes = new [] { typeof(string) })]
        string PluginKeyObjectName { get; set; }
        /// <summary>The resource ID of the Key Vault.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource ID of the Key Vault.",
        SerializedName = @"keyVaultId",
        PossibleTypes = new [] { typeof(string) })]
        string PluginKeyVaultId { get; set; }
        /// <summary>Root certificate object name in Azure Key Vault.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Root certificate object name in Azure Key Vault.",
        SerializedName = @"rootCertObjectName",
        PossibleTypes = new [] { typeof(string) })]
        string PluginRootCertObjectName { get; set; }
        /// <summary>
        /// Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing.
        /// See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
        /// for more information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities) for more information.",
        SerializedName = @"allowNetworkPluginKubenet",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PodIdentityProfileAllowNetworkPluginKubenet { get; set; }
        /// <summary>Whether the pod identity addon is enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether the pod identity addon is enabled.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PodIdentityProfileEnabled { get; set; }
        /// <summary>The pod identities to use in the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The pod identities to use in the cluster.",
        SerializedName = @"userAssignedIdentities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentity) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentity[] PodIdentityProfileUserAssignedIdentity { get; set; }
        /// <summary>The pod identity exceptions to allow.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The pod identity exceptions to allow.",
        SerializedName = @"userAssignedIdentityExceptions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityException) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityException[] PodIdentityProfileUserAssignedIdentityException { get; set; }
        /// <summary>Tells whether the cluster is Running or Stopped</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Tells whether the cluster is Running or Stopped",
        SerializedName = @"code",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Code) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Code? PowerStateCode { get; set; }
        /// <summary>The FQDN of private cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The FQDN of private cluster.",
        SerializedName = @"privateFQDN",
        PossibleTypes = new [] { typeof(string) })]
        string PrivateFqdn { get;  }
        /// <summary>Private link resources associated with the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Private link resources associated with the cluster.",
        SerializedName = @"privateLinkResources",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPrivateLinkResource) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPrivateLinkResource[] PrivateLinkResource { get; set; }
        /// <summary>
        /// An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"An identifier for the error. Codes are invariant and are intended to be consumed programmatically.",
        SerializedName = @"code",
        PossibleTypes = new [] { typeof(string) })]
        string ProvisioningErrorCode { get; set; }
        /// <summary>A list of additional details about the error.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A list of additional details about the error.",
        SerializedName = @"details",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICloudErrorBody) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICloudErrorBody[] ProvisioningErrorDetail { get; set; }
        /// <summary>
        /// A message describing the error, intended to be suitable for display in a user interface.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A message describing the error, intended to be suitable for display in a user interface.",
        SerializedName = @"message",
        PossibleTypes = new [] { typeof(string) })]
        string ProvisioningErrorMessage { get; set; }
        /// <summary>
        /// The target of the particular error. For example, the name of the property in error.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The target of the particular error. For example, the name of the property in error.",
        SerializedName = @"target",
        PossibleTypes = new [] { typeof(string) })]
        string ProvisioningErrorTarget { get; set; }
        /// <summary>The current provisioning state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The current provisioning state.",
        SerializedName = @"provisioningState",
        PossibleTypes = new [] { typeof(string) })]
        string ProvisioningState { get;  }
        /// <summary>Allow or deny public network access for AKS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allow or deny public network access for AKS",
        SerializedName = @"publicNetworkAccess",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess? PublicNetworkAccess { get; set; }
        /// <summary>
        /// The resourceUID uniquely identifies ManagedClusters that reuse ARM ResourceIds (i.e: create, delete, create sequence)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The resourceUID uniquely identifies ManagedClusters that reuse ARM ResourceIds (i.e: create, delete, create sequence)",
        SerializedName = @"resourceUID",
        PossibleTypes = new [] { typeof(string) })]
        string ResourceUid { get;  }
        /// <summary>List of namespaces excluded from Safeguards checks</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of namespaces excluded from Safeguards checks",
        SerializedName = @"excludedNamespaces",
        PossibleTypes = new [] { typeof(string) })]
        string[] SafeguardProfileExcludedNamespace { get; set; }
        /// <summary>
        /// The Safeguards level to be used. By default, Safeguards is enabled for all namespaces except those that AKS excludes via
        /// systemExcludedNamespaces
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Safeguards level to be used. By default, Safeguards is enabled for all namespaces except those that AKS excludes via systemExcludedNamespaces",
        SerializedName = @"level",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Level) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Level? SafeguardProfileLevel { get; set; }
        /// <summary>List of namespaces specified by AKS to be excluded from Safeguards</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"List of namespaces specified by AKS to be excluded from Safeguards",
        SerializedName = @"systemExcludedNamespaces",
        PossibleTypes = new [] { typeof(string) })]
        string[] SafeguardProfileSystemExcludedNamespace { get;  }
        /// <summary>The version of constraints to use</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The version of constraints to use",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string SafeguardProfileVersion { get; set; }
        /// <summary>
        /// In use only while registry access granted by secret rather than managed identity. Set whether to grant the Defender gating
        /// agent access to the cluster's secrets for pulling images from registries. If secret access is denied and the registry
        /// requires pull secrets, the add-on will not perform any image validation. Default value is false.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"In use only while registry access granted by secret rather than managed identity. Set whether to grant the Defender gating agent access to the cluster's secrets for pulling images from registries. If secret access is denied and the registry requires pull secrets, the add-on will not perform any image validation. Default value is false.",
        SerializedName = @"allowSecretAccess",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityGatingAllowSecretAccess { get; set; }
        /// <summary>
        /// Whether to enable Defender security gating. When enabled, the gating feature will scan container images and audit or block
        /// the deployment of images that do not meet security standards according to the configured security rules.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Defender security gating. When enabled, the gating feature will scan container images and audit or block the deployment of images that do not meet security standards according to the configured security rules.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityGatingEnabled { get; set; }
        /// <summary>
        /// List of identities that the admission controller will make use of in order to pull security artifacts from the registry.
        /// These are the same identities used by the cluster to pull container images. Each identity provided should have federated
        /// identity credential attached to it.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of identities that the admission controller will make use of in order to pull security artifacts from the registry. These are the same identities used by the cluster to pull container images. Each identity provided should have federated identity credential attached to it.",
        SerializedName = @"identities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem[] SecurityGatingIdentity { get; set; }
        /// <summary>Whether to enable Defender threat detection</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Defender threat detection",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityMonitoringEnabled { get; set; }
        /// <summary>
        /// A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the cluster. For more information
        /// see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the cluster. For more information see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).",
        SerializedName = @"customCATrustCertificates",
        PossibleTypes = new [] { typeof(byte[]) })]
        byte[][] SecurityProfileCustomCaTrustCertificate { get; set; }
        /// <summary>Mode of the service mesh.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Mode of the service mesh.",
        SerializedName = @"mode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ServiceMeshMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ServiceMeshMode? ServiceMeshProfileMode { get; set; }
        /// <summary>The ID for the service principal.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The ID for the service principal.",
        SerializedName = @"clientId",
        PossibleTypes = new [] { typeof(string) })]
        string ServicePrincipalProfileClientId { get; set; }
        /// <summary>The secret password associated with the service principal in plain text.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The secret password associated with the service principal in plain text.",
        SerializedName = @"secret",
        PossibleTypes = new [] { typeof(string) })]
        string ServicePrincipalProfileSecret { get; set; }
        /// <summary>Whether to enable Snapshot Controller. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Snapshot Controller. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotControllerEnabled { get; set; }
        /// <summary>
        /// The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.",
        SerializedName = @"publicKeys",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceSshPublicKey) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceSshPublicKey[] SshPublicKey { get; set; }
        /// <summary>
        /// The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.",
        SerializedName = @"supportPlan",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan? SupportPlan { get; set; }
        /// <summary>Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.",
        SerializedName = @"addonAutoscaling",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AddonAutoscaling) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AddonAutoscaling? VerticalPodAutoscalerAddonAutoscaling { get; set; }
        /// <summary>Whether to enable VPA add-on in cluster. Default value is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable VPA add-on in cluster. Default value is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VerticalPodAutoscalerEnabled { get; set; }
        /// <summary>
        /// Resource IDs of the DNS zones to be associated with the Web App Routing add-on. Used only when Web App Routing is enabled.
        /// Public and private DNS zones can be in different resource groups, but all public DNS zones must be in the same resource
        /// group and all private DNS zones must be in the same resource group.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource IDs of the DNS zones to be associated with the Web App Routing add-on. Used only when Web App Routing is enabled. Public and private DNS zones can be in different resource groups, but all public DNS zones must be in the same resource group and all private DNS zones must be in the same resource group.",
        SerializedName = @"dnsZoneResourceIds",
        PossibleTypes = new [] { typeof(string) })]
        string[] WebAppRoutingDnsZoneResourceId { get; set; }
        /// <summary>Whether to enable Web App Routing.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Web App Routing.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WebAppRoutingEnabled { get; set; }
        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:**
        /// 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters
        /// <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:**
        /// "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** ""abc@123"", ""P@$$w0rd"", ""P@ssw0rd"", ""P@ssword123"", ""Pa$$word"", ""pass@word1"", ""Password!"", ""Password1"", ""Password22"", ""iloveyou!""",
        SerializedName = @"adminPassword",
        PossibleTypes = new [] { typeof(string) })]
        string WindowProfileAdminPassword { get; set; }
        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm",
        /// "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0",
        /// "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in ""."" <br><br> **Disallowed values:** ""administrator"", ""admin"", ""user"", ""user1"", ""test"", ""user2"", ""test1"", ""user3"", ""admin1"", ""1"", ""123"", ""a"", ""actuser"", ""adm"", ""admin2"", ""aspnet"", ""backup"", ""console"", ""david"", ""guest"", ""john"", ""owner"", ""root"", ""server"", ""sql"", ""support"", ""support_388945a0"", ""sys"", ""test2"", ""test3"", ""user4"", ""user5"". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters",
        SerializedName = @"adminUsername",
        PossibleTypes = new [] { typeof(string) })]
        string WindowProfileAdminUsername { get; set; }
        /// <summary>
        /// For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).",
        SerializedName = @"enableCSIProxy",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WindowProfileEnableCsiProxy { get; set; }
        /// <summary>
        /// The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/)
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.",
        SerializedName = @"licenseType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType? WindowProfileLicenseType { get; set; }
        /// <summary>Whether to enable workload identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable workload identity.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WorkloadIdentityEnabled { get; set; }

    }
    /// Properties of the managed cluster.
    internal partial interface IManagedClusterPropertiesInternal

    {
        /// <summary>The Azure Active Directory configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAadProfile AadProfile { get; set; }
        /// <summary>The list of AAD group object IDs that will have admin role of the cluster.</summary>
        string[] AadProfileAdminGroupObjectID { get; set; }
        /// <summary>
        /// (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        string AadProfileClientAppId { get; set; }
        /// <summary>Whether to enable Azure RBAC for Kubernetes authorization.</summary>
        bool? AadProfileEnableAzureRbac { get; set; }
        /// <summary>Whether to enable managed AAD.</summary>
        bool? AadProfileManaged { get; set; }
        /// <summary>
        /// (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        string AadProfileServerAppId { get; set; }
        /// <summary>
        /// (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        string AadProfileServerAppSecret { get; set; }
        /// <summary>
        /// The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
        /// </summary>
        string AadProfileTenantId { get; set; }
        /// <summary>The profile of managed cluster add-on.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAddonProfiles AddonProfile { get; set; }
        /// <summary>The agent pool properties.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAgentPoolProfile[] AgentPoolProfile { get; set; }
        /// <summary>AI toolchain operator settings that apply to the whole cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAiToolchainOperatorProfile AiToolchainOperatorProfile { get; set; }
        /// <summary>Indicates if AI toolchain operator enabled or not.</summary>
        bool? AiToolchainOperatorProfileEnabled { get; set; }
        /// <summary>The access profile for managed cluster API server.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterApiServerAccessProfile ApiServerAccessProfile { get; set; }
        /// <summary>
        /// IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use
        /// Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized
        /// IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
        /// </summary>
        string[] ApiServerAccessProfileAuthorizedIPRange { get; set; }
        /// <summary>Whether to disable run command for the cluster or not.</summary>
        bool? ApiServerAccessProfileDisableRunCommand { get; set; }
        /// <summary>
        /// For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
        /// </summary>
        bool? ApiServerAccessProfileEnablePrivateCluster { get; set; }
        /// <summary>Whether to create additional public FQDN for private cluster or not.</summary>
        bool? ApiServerAccessProfileEnablePrivateClusterPublicFqdn { get; set; }
        /// <summary>Whether to enable apiserver vnet integration for the cluster or not.</summary>
        bool? ApiServerAccessProfileEnableVnetIntegration { get; set; }
        /// <summary>
        /// The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
        /// Allowed values are 'system' and 'none'.
        /// </summary>
        string ApiServerAccessProfilePrivateDnsZone { get; set; }
        /// <summary>
        /// It is required when: 1. creating a new cluster with BYO Vnet; 2. updating an existing cluster to enable apiserver vnet
        /// integration.
        /// </summary>
        string ApiServerAccessProfileSubnetId { get; set; }
        /// <summary>
        /// Application Monitoring Auto Instrumentation for Kubernetes Application Container. Deploys web hook to auto-instrument
        /// Azure Monitor OpenTelemetry based SDKs to collect OpenTelemetry metrics, logs and traces of the application. See aka.ms/AzureMonitorApplicationMonitoring
        /// for an overview.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation AppMonitoringAutoInstrumentation { get; set; }
        /// <summary>
        /// Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Logs and Traces. Collects OpenTelemetry
        /// logs and traces of the application using Azure Monitor OpenTelemetry based SDKs. See aka.ms/AzureMonitorApplicationMonitoring
        /// for an overview.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs AppMonitoringOpenTelemetryLog { get; set; }
        /// <summary>
        /// Application Monitoring Open Telemetry Metrics Profile for Kubernetes Application Container Metrics. Collects OpenTelemetry
        /// metrics of the application using Azure Monitor OpenTelemetry based SDKs. See aka.ms/AzureMonitorApplicationMonitoring
        /// for an overview.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics AppMonitoringOpenTelemetryMetric { get; set; }
        /// <summary>Indicates if Application Monitoring Auto Instrumentation is enabled or not.</summary>
        bool? AutoInstrumentationEnabled { get; set; }
        /// <summary>Parameters to be applied to the cluster-autoscaler when enabled</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesAutoScalerProfile AutoScalerProfile { get; set; }
        /// <summary>Valid values are 'true' and 'false'</summary>
        string AutoScalerProfileBalanceSimilarNodeGroup { get; set; }
        /// <summary>
        /// If set to true, all daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot
        /// be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset
        /// pods are deleted or evicted.
        /// </summary>
        bool? AutoScalerProfileDaemonsetEvictionForEmptyNode { get; set; }
        /// <summary>
        /// If set to true, all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod
        /// cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring
        /// that daemonset pods are deleted or evicted.
        /// </summary>
        bool? AutoScalerProfileDaemonsetEvictionForOccupiedNode { get; set; }
        /// <summary>Available values are: 'least-waste', 'most-pods', 'priority', 'random'.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander? AutoScalerProfileExpander { get; set; }
        /// <summary>
        /// If set to true, the resources used by daemonset will be taken into account when making scaling down decisions.
        /// </summary>
        bool? AutoScalerProfileIgnoreDaemonsetsUtilization { get; set; }
        /// <summary>The default is 10.</summary>
        string AutoScalerProfileMaxEmptyBulkDelete { get; set; }
        /// <summary>The default is 600.</summary>
        string AutoScalerProfileMaxGracefulTerminationSec { get; set; }
        /// <summary>
        /// The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        string AutoScalerProfileMaxNodeProvisionTime { get; set; }
        /// <summary>The default is 45. The maximum is 100 and the minimum is 0.</summary>
        string AutoScalerProfileMaxTotalUnreadyPercentage { get; set; }
        /// <summary>
        /// For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all
        /// the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be
        /// an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).
        /// </summary>
        string AutoScalerProfileNewPodScaleUpDelay { get; set; }
        /// <summary>This must be an integer. The default is 3.</summary>
        string AutoScalerProfileOkTotalUnreadyCount { get; set; }
        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        string AutoScalerProfileScaleDownDelayAfterAdd { get; set; }
        /// <summary>
        /// The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m)
        /// is supported.
        /// </summary>
        string AutoScalerProfileScaleDownDelayAfterDelete { get; set; }
        /// <summary>
        /// The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        string AutoScalerProfileScaleDownDelayAfterFailure { get; set; }
        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        string AutoScalerProfileScaleDownUnneededTime { get; set; }
        /// <summary>
        /// The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        string AutoScalerProfileScaleDownUnreadyTime { get; set; }
        /// <summary>The default is '0.5'.</summary>
        string AutoScalerProfileScaleDownUtilizationThreshold { get; set; }
        /// <summary>The default is '10'. Values must be an integer number of seconds.</summary>
        string AutoScalerProfileScanInterval { get; set; }
        /// <summary>The default is true.</summary>
        string AutoScalerProfileSkipNodesWithLocalStorage { get; set; }
        /// <summary>The default is true.</summary>
        string AutoScalerProfileSkipNodesWithSystemPod { get; set; }
        /// <summary>The auto upgrade configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAutoUpgradeProfile AutoUpgradeProfile { get; set; }
        /// <summary>
        /// The default is Unmanaged, but may change to either NodeImage or SecurityPatch at GA.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeOSUpgradeChannel? AutoUpgradeProfileNodeOSUpgradeChannel { get; set; }
        /// <summary>
        /// For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel? AutoUpgradeProfileUpgradeChannel { get; set; }
        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        bool? AzureKeyVaultKmEnabled { get; set; }
        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        string AzureKeyVaultKmKeyId { get; set; }
        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes? AzureKeyVaultKmKeyVaultNetworkAccess { get; set; }
        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        string AzureKeyVaultKmKeyVaultResourceId { get; set; }
        /// <summary>Prometheus addon profile for the container service cluster</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfile AzureMonitorProfile { get; set; }
        /// <summary>
        /// Application Monitoring Profile for Kubernetes Application Container. Collects application logs, metrics and traces through
        /// auto-instrumentation of the application using Azure Monitor OpenTelemetry based SDKs. See aka.ms/AzureMonitorApplicationMonitoring
        /// for an overview.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileAppMonitoring AzureMonitorProfileAppMonitoring { get; set; }
        /// <summary>
        /// Azure Monitor Container Insights Profile for Kubernetes Events, Inventory and Container stdout & stderr logs etc. See
        /// aka.ms/AzureMonitorContainerInsights for an overview.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileContainerInsights AzureMonitorProfileContainerInsight { get; set; }
        /// <summary>Metrics profile for the prometheus service addon</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileMetrics AzureMonitorProfileMetric { get; set; }
        /// <summary>
        /// The Azure Portal requires certain Cross-Origin Resource Sharing (CORS) headers to be sent in some responses, which Kubernetes
        /// APIServer doesn't handle by default. This special FQDN supports CORS, allowing the Azure Portal to function properly.
        /// </summary>
        string AzurePortalFqdn { get; set; }
        /// <summary>Whether to enable AzureBlob CSI Driver. The default value is false.</summary>
        bool? BlobCsiDriverEnabled { get; set; }
        /// <summary>Profile of the cluster bootstrap configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterBootstrapProfile BootstrapProfile { get; set; }
        /// <summary>The source where the artifacts are downloaded from.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ArtifactSource? BootstrapProfileArtifactSource { get; set; }
        /// <summary>
        /// The resource Id of Azure Container Registry. The registry must have private network access, premium SKU and zone redundancy.
        /// </summary>
        string BootstrapProfileContainerRegistryId { get; set; }
        /// <summary>Plugin certificates information for Service Mesh.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioPluginCertificateAuthority CertificateAuthorityPlugin { get; set; }
        /// <summary>Istio egress gateways.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioEgressGateway[] ComponentEgressGateway { get; set; }
        /// <summary>Istio ingress gateways.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioIngressGateway[] ComponentIngressGateway { get; set; }
        /// <summary>
        /// Indicates whether custom metrics collection has to be disabled or not. If not specified the default is false. No custom
        /// metrics will be emitted if this field is false but the container insights enabled field is false
        /// </summary>
        bool? ContainerInsightDisableCustomMetric { get; set; }
        /// <summary>
        /// Indicates whether prometheus metrics scraping is disabled or not. If not specified the default is false. No prometheus
        /// metrics will be emitted if this field is false but the container insights enabled field is false
        /// </summary>
        bool? ContainerInsightDisablePrometheusMetricsScraping { get; set; }
        /// <summary>Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.</summary>
        bool? ContainerInsightEnabled { get; set; }
        /// <summary>
        /// Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing Azure Monitor Container Insights Logs.
        /// </summary>
        string ContainerInsightLogAnalyticsWorkspaceResourceId { get; set; }
        /// <summary>The syslog host port. If not specified, the default port is 28330.</summary>
        long? ContainerInsightSyslogPort { get; set; }
        /// <summary>
        /// The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable this feature. Enabling this will add Kubernetes
        /// Namespace and Deployment details to the Cost Analysis views in the Azure portal. If not specified, the default is false.
        /// For more information see aka.ms/aks/docs/cost-analysis.
        /// </summary>
        bool? CostAnalysisEnabled { get; set; }
        /// <summary>
        /// CreationData to be used to specify the source Snapshot ID if the cluster will be created/upgraded using a snapshot.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICreationData CreationData { get; set; }
        /// <summary>This is the ARM ID of the source object to be used to create the target object.</summary>
        string CreationDataSourceResourceId { get; set; }
        /// <summary>The version of Kubernetes the Managed Cluster is running.</summary>
        string CurrentKubernetesVersion { get; set; }
        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        string DefenderLogAnalyticsWorkspaceResourceId { get; set; }
        /// <summary>
        /// Microsoft Defender settings for security gating, validates container images eligibility for deployment based on Defender
        /// for Containers security findings. Using Admission Controller, it either audits or prevents the deployment of images that
        /// do not meet security standards.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileDefenderSecurityGating DefenderSecurityGating { get; set; }
        /// <summary>
        /// Microsoft Defender threat detection for Cloud settings for the security profile.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileDefenderSecurityMonitoring DefenderSecurityMonitoring { get; set; }
        /// <summary>
        /// If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters
        /// that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
        /// </summary>
        bool? DisableLocalAccount { get; set; }
        /// <summary>Whether to enable AzureDisk CSI Driver. The default value is true.</summary>
        bool? DiskCsiDriverEnabled { get; set; }
        /// <summary>The version of AzureDisk CSI Driver. The default value is v1.</summary>
        string DiskCsiDriverVersion { get; set; }
        /// <summary>
        /// This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
        /// </summary>
        string DiskEncryptionSetId { get; set; }
        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        string DnsPrefix { get; set; }
        /// <summary>
        /// The default value is false. It can be enabled/disabled on creation and updating of the managed cluster. See [https://aka.ms/NamespaceARMResource](https://aka.ms/NamespaceARMResource)
        /// for more details on Namespace as a ARM Resource.
        /// </summary>
        bool? EnableNamespaceResource { get; set; }
        /// <summary>Whether to enable Kubernetes Role-Based Access Control.</summary>
        bool? EnableRbac { get; set; }
        /// <summary>Whether to enable AzureFile CSI Driver. The default value is true.</summary>
        bool? FileCsiDriverEnabled { get; set; }
        /// <summary>The FQDN of the master pool.</summary>
        string Fqdn { get; set; }
        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        string FqdnSubdomain { get; set; }
        /// <summary>
        /// Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet
        /// which is used to create the managed cluster.
        /// </summary>
        string GmsaProfileDnsServer { get; set; }
        /// <summary>Specifies whether to enable Windows gMSA in the managed cluster.</summary>
        bool? GmsaProfileEnabled { get; set; }
        /// <summary>
        /// Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the
        /// vnet which is used to create the managed cluster.
        /// </summary>
        string GmsaProfileRootDomainName { get; set; }
        /// <summary>Configurations for provisioning the cluster with HTTP proxy servers.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterHttpProxyConfig HttpProxyConfig { get; set; }
        /// <summary>
        /// A read-only list of all endpoints for which traffic should not be sent to the proxy. This list is a superset of noProxy
        /// and values injected by AKS.
        /// </summary>
        string[] HttpProxyConfigEffectiveNoProxy { get; set; }
        /// <summary>
        /// Whether to enable HTTP proxy. When disabled, the specified proxy configuration will be not be set on pods and nodes.
        /// </summary>
        bool? HttpProxyConfigEnabled { get; set; }
        /// <summary>The HTTP proxy server endpoint to use.</summary>
        string HttpProxyConfigHttpProxy { get; set; }
        /// <summary>The HTTPS proxy server endpoint to use.</summary>
        string HttpProxyConfigHttpsProxy { get; set; }
        /// <summary>The endpoints that should not go through proxy.</summary>
        string[] HttpProxyConfigNoProxy { get; set; }
        /// <summary>Alternative CA cert to use for connecting to proxy servers.</summary>
        string HttpProxyConfigTrustedCa { get; set; }
        /// <summary>The client ID of the user assigned identity.</summary>
        string IdentityClientId { get; set; }
        /// <summary>The object ID of the user assigned identity.</summary>
        string IdentityObjectId { get; set; }
        /// <summary>
        /// The user identity associated with the managed cluster. This identity will be used by the kubelet. Only one user assigned
        /// identity is allowed. The only accepted key is "kubeletidentity", with value of "resourceId": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}".
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPropertiesIdentityProfile IdentityProfile { get; set; }
        /// <summary>The resource ID of the user assigned identity.</summary>
        string IdentityResourceId { get; set; }
        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        bool? ImageCleanerEnabled { get; set; }
        /// <summary>Image Cleaner scanning interval in hours.</summary>
        int? ImageCleanerIntervalHour { get; set; }
        /// <summary>Whether to enable image integrity. The default value is false.</summary>
        bool? ImageIntegrityEnabled { get; set; }
        /// <summary>Ingress profile for the managed cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfile IngressProfile { get; set; }
        /// <summary>Web App Routing settings for the ingress profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileWebAppRouting IngressProfileWebAppRouting { get; set; }
        /// <summary>
        /// Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin certificates as described
        /// here https://aka.ms/asm-plugin-ca
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioCertificateAuthority IstioCertificateAuthority { get; set; }
        /// <summary>Istio components configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioComponents IstioComponent { get; set; }
        /// <summary>
        /// The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary
        /// upgrade is in progress, this can only hold two consecutive values. For more information, see: https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
        /// </summary>
        string[] IstioRevision { get; set; }
        /// <summary>Whether to enable KEDA.</summary>
        bool? KedaEnabled { get; set; }
        /// <summary>
        /// Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.
        /// </summary>
        string KubeStateMetricAnnotationsAllowList { get; set; }
        /// <summary>
        /// Comma-separated list of Kubernetes annotations keys that will be used in the resource's labels metric.
        /// </summary>
        string KubeStateMetricLabelsAllowlist { get; set; }
        /// <summary>
        /// When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed
        /// sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed,
        /// however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster)
        /// for more details.
        /// </summary>
        string KubernetesVersion { get; set; }
        /// <summary>The profile for Linux VMs in the Managed Cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceLinuxProfile LinuxProfile { get; set; }
        /// <summary>The administrator username to use for Linux VMs.</summary>
        string LinuxProfileAdminUsername { get; set; }
        /// <summary>The SSH configuration for Linux-based VMs running on Azure.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceSshConfiguration LinuxProfileSsh { get; set; }
        /// <summary>The max number of agent pools for the managed cluster.</summary>
        int? MaxAgentPool { get; set; }
        /// <summary>Whether to enable the Prometheus collector</summary>
        bool? MetricEnabled { get; set; }
        /// <summary>
        /// Kube State Metrics for prometheus addon profile for the container service cluster
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterAzureMonitorProfileKubeStateMetrics MetricKubeStateMetric { get; set; }
        /// <summary>The cost analysis configuration for the cluster</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterCostAnalysis MetricProfileCostAnalysis { get; set; }
        /// <summary>Optional cluster metrics configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterMetricsProfile MetricsProfile { get; set; }
        /// <summary>The network configuration profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceNetworkProfile NetworkProfile { get; set; }
        /// <summary>Ingress type for the default NginxIngressController custom resource</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NginxIngressControllerType? NginxDefaultIngressControllerType { get; set; }
        /// <summary>Node provisioning settings that apply to the whole cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeProvisioningProfile NodeProvisioningProfile { get; set; }
        /// <summary>
        /// This field has no effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will cause
        /// the default Karpenter NodePools to be deleted, which will in turn drain and delete the nodes associated with those pools.
        /// It is strongly recommended to not do this unless there are idle nodes ready to take the pods evicted by that action. If
        /// not specified, the default is Auto. For more information see aka.ms/something
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningDefaultNodePools? NodeProvisioningProfileDefaultNodePool { get; set; }
        /// <summary>Once the mode it set to Auto, it cannot be changed back to Manual.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningMode? NodeProvisioningProfileMode { get; set; }
        /// <summary>The name of the resource group containing agent pool nodes.</summary>
        string NodeResourceGroup { get; set; }
        /// <summary>The node resource group configuration profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterNodeResourceGroupProfile NodeResourceGroupProfile { get; set; }
        /// <summary>The restriction level applied to the cluster's node resource group</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.RestrictionLevel? NodeResourceGroupProfileRestrictionLevel { get; set; }
        /// <summary>Whether to enable Node Restriction</summary>
        bool? NodeRestrictionEnabled { get; set; }
        /// <summary>The OIDC issuer profile of the Managed Cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterOidcIssuerProfile OidcIssuerProfile { get; set; }
        /// <summary>Whether the OIDC issuer is enabled.</summary>
        bool? OidcIssuerProfileEnabled { get; set; }
        /// <summary>The OIDC issuer url of the Managed Cluster.</summary>
        string OidcIssuerProfileIssuerUrl { get; set; }
        /// <summary>
        /// Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not.
        /// </summary>
        bool? OpenTelemetryLogEnabled { get; set; }
        /// <summary>
        /// The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default port is 28331.
        /// </summary>
        long? OpenTelemetryLogPort { get; set; }
        /// <summary>Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.</summary>
        bool? OpenTelemetryMetricEnabled { get; set; }
        /// <summary>
        /// The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is 28333.
        /// </summary>
        long? OpenTelemetryMetricPort { get; set; }
        /// <summary>
        /// Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade protections
        /// such as checking for deprecated API usage. Enable this option only with caution.
        /// </summary>
        bool? OverrideSettingForceUpgrade { get; set; }
        /// <summary>
        /// Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the effectiveness
        /// won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set by default.
        /// It must be set for the overrides to take effect.
        /// </summary>
        global::System.DateTime? OverrideSettingUntil { get; set; }
        /// <summary>Certificate chain object name in Azure Key Vault.</summary>
        string PluginCertChainObjectName { get; set; }
        /// <summary>Intermediate certificate object name in Azure Key Vault.</summary>
        string PluginCertObjectName { get; set; }
        /// <summary>Intermediate certificate private key object name in Azure Key Vault.</summary>
        string PluginKeyObjectName { get; set; }
        /// <summary>The resource ID of the Key Vault.</summary>
        string PluginKeyVaultId { get; set; }
        /// <summary>Root certificate object name in Azure Key Vault.</summary>
        string PluginRootCertObjectName { get; set; }
        /// <summary>
        /// See [use AAD pod identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on AAD pod
        /// identity integration.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityProfile PodIdentityProfile { get; set; }
        /// <summary>
        /// Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing.
        /// See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
        /// for more information.
        /// </summary>
        bool? PodIdentityProfileAllowNetworkPluginKubenet { get; set; }
        /// <summary>Whether the pod identity addon is enabled.</summary>
        bool? PodIdentityProfileEnabled { get; set; }
        /// <summary>The pod identities to use in the cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentity[] PodIdentityProfileUserAssignedIdentity { get; set; }
        /// <summary>The pod identity exceptions to allow.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterPodIdentityException[] PodIdentityProfileUserAssignedIdentityException { get; set; }
        /// <summary>The Power State of the cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPowerState PowerState { get; set; }
        /// <summary>Tells whether the cluster is Running or Stopped</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Code? PowerStateCode { get; set; }
        /// <summary>The FQDN of private cluster.</summary>
        string PrivateFqdn { get; set; }
        /// <summary>Private link resources associated with the cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IPrivateLinkResource[] PrivateLinkResource { get; set; }
        /// <summary>
        /// An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
        /// </summary>
        string ProvisioningErrorCode { get; set; }
        /// <summary>A list of additional details about the error.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICloudErrorBody[] ProvisioningErrorDetail { get; set; }
        /// <summary>
        /// A message describing the error, intended to be suitable for display in a user interface.
        /// </summary>
        string ProvisioningErrorMessage { get; set; }
        /// <summary>
        /// The target of the particular error. For example, the name of the property in error.
        /// </summary>
        string ProvisioningErrorTarget { get; set; }
        /// <summary>The current provisioning state.</summary>
        string ProvisioningState { get; set; }
        /// <summary>Allow or deny public network access for AKS</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess? PublicNetworkAccess { get; set; }
        /// <summary>
        /// The resourceUID uniquely identifies ManagedClusters that reuse ARM ResourceIds (i.e: create, delete, create sequence)
        /// </summary>
        string ResourceUid { get; set; }
        /// <summary>List of namespaces excluded from Safeguards checks</summary>
        string[] SafeguardProfileExcludedNamespace { get; set; }
        /// <summary>
        /// The Safeguards level to be used. By default, Safeguards is enabled for all namespaces except those that AKS excludes via
        /// systemExcludedNamespaces
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Level? SafeguardProfileLevel { get; set; }
        /// <summary>List of namespaces specified by AKS to be excluded from Safeguards</summary>
        string[] SafeguardProfileSystemExcludedNamespace { get; set; }
        /// <summary>The version of constraints to use</summary>
        string SafeguardProfileVersion { get; set; }
        /// <summary>The Safeguards profile holds all the safeguards information for a given cluster</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ISafeguardsProfile SafeguardsProfile { get; set; }
        /// <summary>
        /// In use only while registry access granted by secret rather than managed identity. Set whether to grant the Defender gating
        /// agent access to the cluster's secrets for pulling images from registries. If secret access is denied and the registry
        /// requires pull secrets, the add-on will not perform any image validation. Default value is false.
        /// </summary>
        bool? SecurityGatingAllowSecretAccess { get; set; }
        /// <summary>
        /// Whether to enable Defender security gating. When enabled, the gating feature will scan container images and audit or block
        /// the deployment of images that do not meet security standards according to the configured security rules.
        /// </summary>
        bool? SecurityGatingEnabled { get; set; }
        /// <summary>
        /// List of identities that the admission controller will make use of in order to pull security artifacts from the registry.
        /// These are the same identities used by the cluster to pull container images. Each identity provided should have federated
        /// identity credential attached to it.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem[] SecurityGatingIdentity { get; set; }
        /// <summary>Whether to enable Defender threat detection</summary>
        bool? SecurityMonitoringEnabled { get; set; }
        /// <summary>Security profile for the managed cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfile SecurityProfile { get; set; }
        /// <summary>
        /// Azure Key Vault [key management service](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/) settings for
        /// the security profile.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IAzureKeyVaultKms SecurityProfileAzureKeyVaultKm { get; set; }
        /// <summary>
        /// A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the cluster. For more information
        /// see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
        /// </summary>
        byte[][] SecurityProfileCustomCaTrustCertificate { get; set; }
        /// <summary>Microsoft Defender settings for the security profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileDefender SecurityProfileDefender { get; set; }
        /// <summary>Image Cleaner settings for the security profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileImageCleaner SecurityProfileImageCleaner { get; set; }
        /// <summary>
        /// Image integrity is a feature that works with Azure Policy to verify image integrity by signature. This will not have any
        /// effect unless Azure Policy is applied to enforce image signatures. See https://aka.ms/aks/image-integrity for how to use
        /// this feature via policy.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileImageIntegrity SecurityProfileImageIntegrity { get; set; }
        /// <summary>
        /// [Node Restriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) settings
        /// for the security profile.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileNodeRestriction SecurityProfileNodeRestriction { get; set; }
        /// <summary>
        /// Workload identity settings for the security profile. Workload identity enables Kubernetes applications to access Azure
        /// cloud resources securely with Azure AD. See https://aka.ms/aks/wi for more details.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterSecurityProfileWorkloadIdentity SecurityProfileWorkloadIdentity { get; set; }
        /// <summary>Service mesh profile for a managed cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IServiceMeshProfile ServiceMeshProfile { get; set; }
        /// <summary>Istio service mesh configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IIstioServiceMesh ServiceMeshProfileIstio { get; set; }
        /// <summary>Mode of the service mesh.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ServiceMeshMode? ServiceMeshProfileMode { get; set; }
        /// <summary>
        /// Information about a service principal identity for the cluster to use for manipulating Azure APIs.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterServicePrincipalProfile ServicePrincipalProfile { get; set; }
        /// <summary>The ID for the service principal.</summary>
        string ServicePrincipalProfileClientId { get; set; }
        /// <summary>The secret password associated with the service principal in plain text.</summary>
        string ServicePrincipalProfileSecret { get; set; }
        /// <summary>Whether to enable Snapshot Controller. The default value is true.</summary>
        bool? SnapshotControllerEnabled { get; set; }
        /// <summary>
        /// The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IContainerServiceSshPublicKey[] SshPublicKey { get; set; }
        /// <summary>Contains read-only information about the Managed Cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStatus Status { get; set; }
        /// <summary>
        /// Preserves the detailed info of failure. If there was no error, this field is omitted.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.ICloudErrorBody StatusProvisioningError { get; set; }
        /// <summary>Storage profile for the managed cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfile StorageProfile { get; set; }
        /// <summary>AzureBlob CSI Driver settings for the storage profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileBlobCsiDriver StorageProfileBlobCsiDriver { get; set; }
        /// <summary>AzureDisk CSI Driver settings for the storage profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileDiskCsiDriver StorageProfileDiskCsiDriver { get; set; }
        /// <summary>AzureFile CSI Driver settings for the storage profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileFileCsiDriver StorageProfileFileCsiDriver { get; set; }
        /// <summary>Snapshot Controller settings for the storage profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterStorageProfileSnapshotController StorageProfileSnapshotController { get; set; }
        /// <summary>
        /// The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan? SupportPlan { get; set; }
        /// <summary>Settings for upgrading a cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IClusterUpgradeSettings UpgradeSetting { get; set; }
        /// <summary>Settings for overrides.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IUpgradeOverrideSettings UpgradeSettingOverrideSetting { get; set; }
        /// <summary>Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AddonAutoscaling? VerticalPodAutoscalerAddonAutoscaling { get; set; }
        /// <summary>Whether to enable VPA add-on in cluster. Default value is false.</summary>
        bool? VerticalPodAutoscalerEnabled { get; set; }
        /// <summary>
        /// Resource IDs of the DNS zones to be associated with the Web App Routing add-on. Used only when Web App Routing is enabled.
        /// Public and private DNS zones can be in different resource groups, but all public DNS zones must be in the same resource
        /// group and all private DNS zones must be in the same resource group.
        /// </summary>
        string[] WebAppRoutingDnsZoneResourceId { get; set; }
        /// <summary>Whether to enable Web App Routing.</summary>
        bool? WebAppRoutingEnabled { get; set; }
        /// <summary>
        /// Managed identity of the Web Application Routing add-on. This is the identity that should be granted permissions, for example,
        /// to manage the associated Azure DNS resource and get certificates from Azure Key Vault. See [this overview of the add-on](https://learn.microsoft.com/en-us/azure/aks/web-app-routing?tabs=with-osm)
        /// for more instructions.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IUserAssignedIdentity WebAppRoutingIdentity { get; set; }
        /// <summary>
        /// Configuration for the default NginxIngressController. See more at https://learn.microsoft.com/en-us/azure/aks/app-routing-nginx-configuration#the-default-nginx-ingress-controller.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterIngressProfileNginx WebAppRoutingNginx { get; set; }
        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:**
        /// 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters
        /// <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:**
        /// "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
        /// </summary>
        string WindowProfileAdminPassword { get; set; }
        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm",
        /// "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0",
        /// "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters
        /// </summary>
        string WindowProfileAdminUsername { get; set; }
        /// <summary>
        /// For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).
        /// </summary>
        bool? WindowProfileEnableCsiProxy { get; set; }
        /// <summary>The Windows gMSA Profile in the Managed Cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IWindowsGmsaProfile WindowProfileGmsaProfile { get; set; }
        /// <summary>
        /// The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/)
        /// for more details.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType? WindowProfileLicenseType { get; set; }
        /// <summary>The profile for Windows VMs in the Managed Cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWindowsProfile WindowsProfile { get; set; }
        /// <summary>Workload Auto-scaler profile for the managed cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfile WorkloadAutoScalerProfile { get; set; }
        /// <summary>
        /// KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileKeda WorkloadAutoScalerProfileKeda { get; set; }

        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250302Preview.IManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler WorkloadAutoScalerProfileVerticalPodAutoscaler { get; set; }
        /// <summary>Whether to enable workload identity.</summary>
        bool? WorkloadIdentityEnabled { get; set; }

    }
}
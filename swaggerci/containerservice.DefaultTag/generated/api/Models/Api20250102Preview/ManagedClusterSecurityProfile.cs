// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Extensions;

    /// <summary>Security profile for the container service cluster.</summary>
    public partial class ManagedClusterSecurityProfile :
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfile,
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileInternal
    {

        /// <summary>Backing field for <see cref="AzureKeyVaultKm" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKms _azureKeyVaultKm;

        /// <summary>
        /// Azure Key Vault [key management service](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/) settings for
        /// the security profile.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKms AzureKeyVaultKm { get => (this._azureKeyVaultKm = this._azureKeyVaultKm ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.AzureKeyVaultKms()); set => this._azureKeyVaultKm = value; }

        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? AzureKeyVaultKmEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKmsInternal)AzureKeyVaultKm).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKmsInternal)AzureKeyVaultKm).Enabled = value ?? default(bool); }

        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AzureKeyVaultKmKeyId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKmsInternal)AzureKeyVaultKm).KeyId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKmsInternal)AzureKeyVaultKm).KeyId = value ?? null; }

        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes? AzureKeyVaultKmKeyVaultNetworkAccess { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKmsInternal)AzureKeyVaultKm).KeyVaultNetworkAccess; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKmsInternal)AzureKeyVaultKm).KeyVaultNetworkAccess = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes)""); }

        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string AzureKeyVaultKmKeyVaultResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKmsInternal)AzureKeyVaultKm).KeyVaultResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKmsInternal)AzureKeyVaultKm).KeyVaultResourceId = value ?? null; }

        /// <summary>Backing field for <see cref="CustomCaTrustCertificate" /> property.</summary>
        private byte[][] _customCaTrustCertificate;

        /// <summary>
        /// A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the cluster. For more information
        /// see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        public byte[][] CustomCaTrustCertificate { get => this._customCaTrustCertificate; set => this._customCaTrustCertificate = value; }

        /// <summary>Backing field for <see cref="Defender" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefender _defender;

        /// <summary>Microsoft Defender settings for the security profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefender Defender { get => (this._defender = this._defender ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.ManagedClusterSecurityProfileDefender()); set => this._defender = value; }

        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public string DefenderLogAnalyticsWorkspaceResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).LogAnalyticsWorkspaceResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).LogAnalyticsWorkspaceResourceId = value ?? null; }

        /// <summary>Backing field for <see cref="ImageCleaner" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageCleaner _imageCleaner;

        /// <summary>Image Cleaner settings for the security profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageCleaner ImageCleaner { get => (this._imageCleaner = this._imageCleaner ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.ManagedClusterSecurityProfileImageCleaner()); set => this._imageCleaner = value; }

        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ImageCleanerEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageCleanerInternal)ImageCleaner).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageCleanerInternal)ImageCleaner).Enabled = value ?? default(bool); }

        /// <summary>Image Cleaner scanning interval in hours.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public int? ImageCleanerIntervalHour { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageCleanerInternal)ImageCleaner).IntervalHour; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageCleanerInternal)ImageCleaner).IntervalHour = value ?? default(int); }

        /// <summary>Backing field for <see cref="ImageIntegrity" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageIntegrity _imageIntegrity;

        /// <summary>
        /// Image integrity is a feature that works with Azure Policy to verify image integrity by signature. This will not have any
        /// effect unless Azure Policy is applied to enforce image signatures. See https://aka.ms/aks/image-integrity for how to use
        /// this feature via policy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageIntegrity ImageIntegrity { get => (this._imageIntegrity = this._imageIntegrity ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.ManagedClusterSecurityProfileImageIntegrity()); set => this._imageIntegrity = value; }

        /// <summary>Whether to enable image integrity. The default value is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? ImageIntegrityEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageIntegrityInternal)ImageIntegrity).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageIntegrityInternal)ImageIntegrity).Enabled = value ?? default(bool); }

        /// <summary>Internal Acessors for AzureKeyVaultKm</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKms Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileInternal.AzureKeyVaultKm { get => (this._azureKeyVaultKm = this._azureKeyVaultKm ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.AzureKeyVaultKms()); set { {_azureKeyVaultKm = value;} } }

        /// <summary>Internal Acessors for Defender</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefender Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileInternal.Defender { get => (this._defender = this._defender ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.ManagedClusterSecurityProfileDefender()); set { {_defender = value;} } }

        /// <summary>Internal Acessors for DefenderSecurityGating</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderSecurityGating Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileInternal.DefenderSecurityGating { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityGating; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityGating = value; }

        /// <summary>Internal Acessors for DefenderSecurityMonitoring</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderSecurityMonitoring Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileInternal.DefenderSecurityMonitoring { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityMonitoring; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityMonitoring = value; }

        /// <summary>Internal Acessors for ImageCleaner</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageCleaner Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileInternal.ImageCleaner { get => (this._imageCleaner = this._imageCleaner ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.ManagedClusterSecurityProfileImageCleaner()); set { {_imageCleaner = value;} } }

        /// <summary>Internal Acessors for ImageIntegrity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageIntegrity Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileInternal.ImageIntegrity { get => (this._imageIntegrity = this._imageIntegrity ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.ManagedClusterSecurityProfileImageIntegrity()); set { {_imageIntegrity = value;} } }

        /// <summary>Internal Acessors for NodeRestriction</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileNodeRestriction Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileInternal.NodeRestriction { get => (this._nodeRestriction = this._nodeRestriction ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.ManagedClusterSecurityProfileNodeRestriction()); set { {_nodeRestriction = value;} } }

        /// <summary>Internal Acessors for WorkloadIdentity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileWorkloadIdentity Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileInternal.WorkloadIdentity { get => (this._workloadIdentity = this._workloadIdentity ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.ManagedClusterSecurityProfileWorkloadIdentity()); set { {_workloadIdentity = value;} } }

        /// <summary>Backing field for <see cref="NodeRestriction" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileNodeRestriction _nodeRestriction;

        /// <summary>
        /// [Node Restriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) settings
        /// for the security profile.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileNodeRestriction NodeRestriction { get => (this._nodeRestriction = this._nodeRestriction ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.ManagedClusterSecurityProfileNodeRestriction()); set => this._nodeRestriction = value; }

        /// <summary>Whether to enable Node Restriction</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? NodeRestrictionEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileNodeRestrictionInternal)NodeRestriction).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileNodeRestrictionInternal)NodeRestriction).Enabled = value ?? default(bool); }

        /// <summary>
        /// In use only while registry access granted by secret rather than managed identity. Set whether to grant the Defender gating
        /// agent access to the cluster's secrets for pulling images from registries. If secret access is denied and the registry
        /// requires pull secrets, the add-on will not perform any image validation. Default value is false.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? SecurityGatingAllowSecretAccess { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityGatingAllowSecretAccess; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityGatingAllowSecretAccess = value ?? default(bool); }

        /// <summary>
        /// Whether to enable Defender security gating. When enabled, the gating feature will scan container images and audit or block
        /// the deployment of images that do not meet security standards according to the configured security rules.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? SecurityGatingEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityGatingEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityGatingEnabled = value ?? default(bool); }

        /// <summary>
        /// List of identities that the admission controller will make use of in order to pull security artifacts from the registry.
        /// These are the same identities used by the cluster to pull container images. Each identity provided should have federated
        /// identity credential attached to it.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem[] SecurityGatingIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityGatingIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityGatingIdentity = value ?? null /* arrayOf */; }

        /// <summary>Whether to enable Defender threat detection</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? SecurityMonitoringEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityMonitoringEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderInternal)Defender).SecurityMonitoringEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="WorkloadIdentity" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileWorkloadIdentity _workloadIdentity;

        /// <summary>
        /// Workload identity settings for the security profile. Workload identity enables Kubernetes applications to access Azure
        /// cloud resources securely with Azure AD. See https://aka.ms/aks/wi for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileWorkloadIdentity WorkloadIdentity { get => (this._workloadIdentity = this._workloadIdentity ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.ManagedClusterSecurityProfileWorkloadIdentity()); set => this._workloadIdentity = value; }

        /// <summary>Whether to enable workload identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.PropertyOrigin.Inlined)]
        public bool? WorkloadIdentityEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileWorkloadIdentityInternal)WorkloadIdentity).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileWorkloadIdentityInternal)WorkloadIdentity).Enabled = value ?? default(bool); }

        /// <summary>Creates an new <see cref="ManagedClusterSecurityProfile" /> instance.</summary>
        public ManagedClusterSecurityProfile()
        {

        }
    }
    /// Security profile for the container service cluster.
    public partial interface IManagedClusterSecurityProfile :
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IJsonSerializable
    {
        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Azure Key Vault key management service. The default is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AzureKeyVaultKmEnabled { get; set; }
        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.",
        SerializedName = @"keyId",
        PossibleTypes = new [] { typeof(string) })]
        string AzureKeyVaultKmKeyId { get; set; }
        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.",
        SerializedName = @"keyVaultNetworkAccess",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes? AzureKeyVaultKmKeyVaultNetworkAccess { get; set; }
        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.",
        SerializedName = @"keyVaultResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string AzureKeyVaultKmKeyVaultResourceId { get; set; }
        /// <summary>
        /// A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the cluster. For more information
        /// see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the cluster. For more information see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).",
        SerializedName = @"customCATrustCertificates",
        PossibleTypes = new [] { typeof(byte[]) })]
        byte[][] CustomCaTrustCertificate { get; set; }
        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.",
        SerializedName = @"logAnalyticsWorkspaceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string DefenderLogAnalyticsWorkspaceResourceId { get; set; }
        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Image Cleaner on AKS cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ImageCleanerEnabled { get; set; }
        /// <summary>Image Cleaner scanning interval in hours.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Image Cleaner scanning interval in hours.",
        SerializedName = @"intervalHours",
        PossibleTypes = new [] { typeof(int) })]
        int? ImageCleanerIntervalHour { get; set; }
        /// <summary>Whether to enable image integrity. The default value is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable image integrity. The default value is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ImageIntegrityEnabled { get; set; }
        /// <summary>Whether to enable Node Restriction</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Node Restriction",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NodeRestrictionEnabled { get; set; }
        /// <summary>
        /// In use only while registry access granted by secret rather than managed identity. Set whether to grant the Defender gating
        /// agent access to the cluster's secrets for pulling images from registries. If secret access is denied and the registry
        /// requires pull secrets, the add-on will not perform any image validation. Default value is false.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"In use only while registry access granted by secret rather than managed identity. Set whether to grant the Defender gating agent access to the cluster's secrets for pulling images from registries. If secret access is denied and the registry requires pull secrets, the add-on will not perform any image validation. Default value is false.",
        SerializedName = @"allowSecretAccess",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityGatingAllowSecretAccess { get; set; }
        /// <summary>
        /// Whether to enable Defender security gating. When enabled, the gating feature will scan container images and audit or block
        /// the deployment of images that do not meet security standards according to the configured security rules.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Defender security gating. When enabled, the gating feature will scan container images and audit or block the deployment of images that do not meet security standards according to the configured security rules.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityGatingEnabled { get; set; }
        /// <summary>
        /// List of identities that the admission controller will make use of in order to pull security artifacts from the registry.
        /// These are the same identities used by the cluster to pull container images. Each identity provided should have federated
        /// identity credential attached to it.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of identities that the admission controller will make use of in order to pull security artifacts from the registry. These are the same identities used by the cluster to pull container images. Each identity provided should have federated identity credential attached to it.",
        SerializedName = @"identities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem[] SecurityGatingIdentity { get; set; }
        /// <summary>Whether to enable Defender threat detection</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Defender threat detection",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityMonitoringEnabled { get; set; }
        /// <summary>Whether to enable workload identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable workload identity.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WorkloadIdentityEnabled { get; set; }

    }
    /// Security profile for the container service cluster.
    internal partial interface IManagedClusterSecurityProfileInternal

    {
        /// <summary>
        /// Azure Key Vault [key management service](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/) settings for
        /// the security profile.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IAzureKeyVaultKms AzureKeyVaultKm { get; set; }
        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        bool? AzureKeyVaultKmEnabled { get; set; }
        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        string AzureKeyVaultKmKeyId { get; set; }
        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes? AzureKeyVaultKmKeyVaultNetworkAccess { get; set; }
        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        string AzureKeyVaultKmKeyVaultResourceId { get; set; }
        /// <summary>
        /// A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the cluster. For more information
        /// see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
        /// </summary>
        byte[][] CustomCaTrustCertificate { get; set; }
        /// <summary>Microsoft Defender settings for the security profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefender Defender { get; set; }
        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        string DefenderLogAnalyticsWorkspaceResourceId { get; set; }
        /// <summary>
        /// Microsoft Defender settings for security gating, validates container images eligibility for deployment based on Defender
        /// for Containers security findings. Using Admission Controller, it either audits or prevents the deployment of images that
        /// do not meet security standards.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderSecurityGating DefenderSecurityGating { get; set; }
        /// <summary>
        /// Microsoft Defender threat detection for Cloud settings for the security profile.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderSecurityMonitoring DefenderSecurityMonitoring { get; set; }
        /// <summary>Image Cleaner settings for the security profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageCleaner ImageCleaner { get; set; }
        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        bool? ImageCleanerEnabled { get; set; }
        /// <summary>Image Cleaner scanning interval in hours.</summary>
        int? ImageCleanerIntervalHour { get; set; }
        /// <summary>
        /// Image integrity is a feature that works with Azure Policy to verify image integrity by signature. This will not have any
        /// effect unless Azure Policy is applied to enforce image signatures. See https://aka.ms/aks/image-integrity for how to use
        /// this feature via policy.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileImageIntegrity ImageIntegrity { get; set; }
        /// <summary>Whether to enable image integrity. The default value is false.</summary>
        bool? ImageIntegrityEnabled { get; set; }
        /// <summary>
        /// [Node Restriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) settings
        /// for the security profile.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileNodeRestriction NodeRestriction { get; set; }
        /// <summary>Whether to enable Node Restriction</summary>
        bool? NodeRestrictionEnabled { get; set; }
        /// <summary>
        /// In use only while registry access granted by secret rather than managed identity. Set whether to grant the Defender gating
        /// agent access to the cluster's secrets for pulling images from registries. If secret access is denied and the registry
        /// requires pull secrets, the add-on will not perform any image validation. Default value is false.
        /// </summary>
        bool? SecurityGatingAllowSecretAccess { get; set; }
        /// <summary>
        /// Whether to enable Defender security gating. When enabled, the gating feature will scan container images and audit or block
        /// the deployment of images that do not meet security standards according to the configured security rules.
        /// </summary>
        bool? SecurityGatingEnabled { get; set; }
        /// <summary>
        /// List of identities that the admission controller will make use of in order to pull security artifacts from the registry.
        /// These are the same identities used by the cluster to pull container images. Each identity provided should have federated
        /// identity credential attached to it.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem[] SecurityGatingIdentity { get; set; }
        /// <summary>Whether to enable Defender threat detection</summary>
        bool? SecurityMonitoringEnabled { get; set; }
        /// <summary>
        /// Workload identity settings for the security profile. Workload identity enables Kubernetes applications to access Azure
        /// cloud resources securely with Azure AD. See https://aka.ms/aks/wi for more details.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20250102Preview.IManagedClusterSecurityProfileWorkloadIdentity WorkloadIdentity { get; set; }
        /// <summary>Whether to enable workload identity.</summary>
        bool? WorkloadIdentityEnabled { get; set; }

    }
}
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Cmdlets
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Extensions;
    using System;

    /// <summary>Creates or updates a managed cluster.</summary>
    /// <remarks>
    /// [OpenAPI] CreateOrUpdate=>PUT:"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}"
    /// </remarks>
    [global::System.Management.Automation.Cmdlet(global::System.Management.Automation.VerbsCommon.New, @"AzContainerServiceManagedCluster_CreateExpanded", SupportsShouldProcess = true)]
    [global::System.Management.Automation.OutputType(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedCluster))]
    [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Description(@"Creates or updates a managed cluster.")]
    [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Generated]
    [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.HttpPath(Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}", ApiVersion = "2024-09-02-preview")]
    public partial class NewAzContainerServiceManagedCluster_CreateExpanded : global::System.Management.Automation.PSCmdlet,
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener
    {
        /// <summary>A unique id generatd for the this cmdlet when it is instantiated.</summary>
        private string __correlationId = System.Guid.NewGuid().ToString();

        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        private global::System.Management.Automation.InvocationInfo __invocationInfo;

        /// <summary>A unique id generatd for the this cmdlet when ProcessRecord() is called.</summary>
        private string __processRecordId;

        /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();

        /// <summary>Managed cluster.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedCluster _parametersBody = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.ManagedCluster();

        /// <summary>The list of AAD group object IDs that will have admin role of the cluster.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The list of AAD group object IDs that will have admin role of the cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of AAD group object IDs that will have admin role of the cluster.",
        SerializedName = @"adminGroupObjectIDs",
        PossibleTypes = new [] { typeof(string) })]
        public string[] AadProfileAdminGroupObjectID { get => _parametersBody.AadProfileAdminGroupObjectID ?? null /* arrayOf */; set => _parametersBody.AadProfileAdminGroupObjectID = value; }

        /// <summary>
        /// (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "(DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"clientAppID",
        PossibleTypes = new [] { typeof(string) })]
        public string AadProfileClientAppId { get => _parametersBody.AadProfileClientAppId ?? null; set => _parametersBody.AadProfileClientAppId = value; }

        /// <summary>Whether to enable Azure RBAC for Kubernetes authorization.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Azure RBAC for Kubernetes authorization.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Azure RBAC for Kubernetes authorization.",
        SerializedName = @"enableAzureRBAC",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AadProfileEnableAzureRbac { get => _parametersBody.AadProfileEnableAzureRbac ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AadProfileEnableAzureRbac = value; }

        /// <summary>Whether to enable managed AAD.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable managed AAD.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable managed AAD.",
        SerializedName = @"managed",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AadProfileManaged { get => _parametersBody.AadProfileManaged ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AadProfileManaged = value; }

        /// <summary>
        /// (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "(DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"serverAppID",
        PossibleTypes = new [] { typeof(string) })]
        public string AadProfileServerAppId { get => _parametersBody.AadProfileServerAppId ?? null; set => _parametersBody.AadProfileServerAppId = value; }

        /// <summary>
        /// (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "(DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"serverAppSecret",
        PossibleTypes = new [] { typeof(string) })]
        public string AadProfileServerAppSecret { get => _parametersBody.AadProfileServerAppSecret ?? null; set => _parametersBody.AadProfileServerAppSecret = value; }

        /// <summary>
        /// The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.",
        SerializedName = @"tenantID",
        PossibleTypes = new [] { typeof(string) })]
        public string AadProfileTenantId { get => _parametersBody.AadProfileTenantId ?? null; set => _parametersBody.AadProfileTenantId = value; }

        /// <summary>The profile of managed cluster add-on.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The profile of managed cluster add-on.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The profile of managed cluster add-on.",
        SerializedName = @"addonProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterPropertiesAddonProfiles) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterPropertiesAddonProfiles AddonProfile { get => _parametersBody.AddonProfile ?? null /* object */; set => _parametersBody.AddonProfile = value; }

        /// <summary>The agent pool properties.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The agent pool properties.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The agent pool properties.",
        SerializedName = @"agentPoolProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterAgentPoolProfile) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterAgentPoolProfile[] AgentPoolProfile { get => _parametersBody.AgentPoolProfile ?? null /* arrayOf */; set => _parametersBody.AgentPoolProfile = value; }

        /// <summary>Indicates if AI toolchain operator enabled or not.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates if AI toolchain operator enabled or not.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates if AI toolchain operator enabled or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AiToolchainOperatorProfileEnabled { get => _parametersBody.AiToolchainOperatorProfileEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AiToolchainOperatorProfileEnabled = value; }

        /// <summary>
        /// IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use
        /// Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized
        /// IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).",
        SerializedName = @"authorizedIPRanges",
        PossibleTypes = new [] { typeof(string) })]
        public string[] ApiServerAccessProfileAuthorizedIPRange { get => _parametersBody.ApiServerAccessProfileAuthorizedIPRange ?? null /* arrayOf */; set => _parametersBody.ApiServerAccessProfileAuthorizedIPRange = value; }

        /// <summary>Whether to disable run command for the cluster or not.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to disable run command for the cluster or not.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to disable run command for the cluster or not.",
        SerializedName = @"disableRunCommand",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ApiServerAccessProfileDisableRunCommand { get => _parametersBody.ApiServerAccessProfileDisableRunCommand ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ApiServerAccessProfileDisableRunCommand = value; }

        /// <summary>
        /// For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).",
        SerializedName = @"enablePrivateCluster",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ApiServerAccessProfileEnablePrivateCluster { get => _parametersBody.ApiServerAccessProfileEnablePrivateCluster ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ApiServerAccessProfileEnablePrivateCluster = value; }

        /// <summary>Whether to create additional public FQDN for private cluster or not.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to create additional public FQDN for private cluster or not.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to create additional public FQDN for private cluster or not.",
        SerializedName = @"enablePrivateClusterPublicFQDN",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ApiServerAccessProfileEnablePrivateClusterPublicFqdn { get => _parametersBody.ApiServerAccessProfileEnablePrivateClusterPublicFqdn ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ApiServerAccessProfileEnablePrivateClusterPublicFqdn = value; }

        /// <summary>Whether to enable apiserver vnet integration for the cluster or not.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable apiserver vnet integration for the cluster or not.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable apiserver vnet integration for the cluster or not.",
        SerializedName = @"enableVnetIntegration",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ApiServerAccessProfileEnableVnetIntegration { get => _parametersBody.ApiServerAccessProfileEnableVnetIntegration ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ApiServerAccessProfileEnableVnetIntegration = value; }

        /// <summary>
        /// The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
        /// Allowed values are 'system' and 'none'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are 'system' and 'none'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are 'system' and 'none'.",
        SerializedName = @"privateDNSZone",
        PossibleTypes = new [] { typeof(string) })]
        public string ApiServerAccessProfilePrivateDnsZone { get => _parametersBody.ApiServerAccessProfilePrivateDnsZone ?? null; set => _parametersBody.ApiServerAccessProfilePrivateDnsZone = value; }

        /// <summary>
        /// It is required when: 1. creating a new cluster with BYO Vnet; 2. updating an existing cluster to enable apiserver vnet
        /// integration.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "It is required when: 1. creating a new cluster with BYO Vnet; 2. updating an existing cluster to enable apiserver vnet integration.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"It is required when: 1. creating a new cluster with BYO Vnet; 2. updating an existing cluster to enable apiserver vnet integration.",
        SerializedName = @"subnetId",
        PossibleTypes = new [] { typeof(string) })]
        public string ApiServerAccessProfileSubnetId { get => _parametersBody.ApiServerAccessProfileSubnetId ?? null; set => _parametersBody.ApiServerAccessProfileSubnetId = value; }

        /// <summary>when specified, runs this cmdlet as a PowerShell job</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command as a job")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter AsJob { get; set; }

        /// <summary>Indicates if Application Monitoring Auto Instrumentation is enabled or not.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates if Application Monitoring Auto Instrumentation is enabled or not.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates if Application Monitoring Auto Instrumentation is enabled or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AutoInstrumentationEnabled { get => _parametersBody.AutoInstrumentationEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AutoInstrumentationEnabled = value; }

        /// <summary>Valid values are 'true' and 'false'</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Valid values are 'true' and 'false'")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Valid values are 'true' and 'false'",
        SerializedName = @"balance-similar-node-groups",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileBalanceSimilarNodeGroup { get => _parametersBody.AutoScalerProfileBalanceSimilarNodeGroup ?? null; set => _parametersBody.AutoScalerProfileBalanceSimilarNodeGroup = value; }

        /// <summary>
        /// If set to true, all daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot
        /// be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset
        /// pods are deleted or evicted.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If set to true, all daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods are deleted or evicted.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, all daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods are deleted or evicted.",
        SerializedName = @"daemonset-eviction-for-empty-nodes",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AutoScalerProfileDaemonsetEvictionForEmptyNode { get => _parametersBody.AutoScalerProfileDaemonsetEvictionForEmptyNode ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AutoScalerProfileDaemonsetEvictionForEmptyNode = value; }

        /// <summary>
        /// If set to true, all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod
        /// cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring
        /// that daemonset pods are deleted or evicted.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If set to true, all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods are deleted or evicted.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods are deleted or evicted.",
        SerializedName = @"daemonset-eviction-for-occupied-nodes",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AutoScalerProfileDaemonsetEvictionForOccupiedNode { get => _parametersBody.AutoScalerProfileDaemonsetEvictionForOccupiedNode ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AutoScalerProfileDaemonsetEvictionForOccupiedNode = value; }

        /// <summary>Available values are: 'least-waste', 'most-pods', 'priority', 'random'.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Available values are: 'least-waste', 'most-pods', 'priority', 'random'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Available values are: 'least-waste', 'most-pods', 'priority', 'random'.",
        SerializedName = @"expander",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander AutoScalerProfileExpander { get => _parametersBody.AutoScalerProfileExpander ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander)""); set => _parametersBody.AutoScalerProfileExpander = value; }

        /// <summary>
        /// If set to true, the resources used by daemonset will be taken into account when making scaling down decisions.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If set to true, the resources used by daemonset will be taken into account when making scaling down decisions.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, the resources used by daemonset will be taken into account when making scaling down decisions.",
        SerializedName = @"ignore-daemonsets-utilization",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AutoScalerProfileIgnoreDaemonsetsUtilization { get => _parametersBody.AutoScalerProfileIgnoreDaemonsetsUtilization ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AutoScalerProfileIgnoreDaemonsetsUtilization = value; }

        /// <summary>The default is 10.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is 10.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 10.",
        SerializedName = @"max-empty-bulk-delete",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileMaxEmptyBulkDelete { get => _parametersBody.AutoScalerProfileMaxEmptyBulkDelete ?? null; set => _parametersBody.AutoScalerProfileMaxEmptyBulkDelete = value; }

        /// <summary>The default is 600.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is 600.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 600.",
        SerializedName = @"max-graceful-termination-sec",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileMaxGracefulTerminationSec { get => _parametersBody.AutoScalerProfileMaxGracefulTerminationSec ?? null; set => _parametersBody.AutoScalerProfileMaxGracefulTerminationSec = value; }

        /// <summary>
        /// The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"max-node-provision-time",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileMaxNodeProvisionTime { get => _parametersBody.AutoScalerProfileMaxNodeProvisionTime ?? null; set => _parametersBody.AutoScalerProfileMaxNodeProvisionTime = value; }

        /// <summary>The default is 45. The maximum is 100 and the minimum is 0.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is 45. The maximum is 100 and the minimum is 0.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 45. The maximum is 100 and the minimum is 0.",
        SerializedName = @"max-total-unready-percentage",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileMaxTotalUnreadyPercentage { get => _parametersBody.AutoScalerProfileMaxTotalUnreadyPercentage ?? null; set => _parametersBody.AutoScalerProfileMaxTotalUnreadyPercentage = value; }

        /// <summary>
        /// For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all
        /// the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be
        /// an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).",
        SerializedName = @"new-pod-scale-up-delay",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileNewPodScaleUpDelay { get => _parametersBody.AutoScalerProfileNewPodScaleUpDelay ?? null; set => _parametersBody.AutoScalerProfileNewPodScaleUpDelay = value; }

        /// <summary>This must be an integer. The default is 3.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This must be an integer. The default is 3.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This must be an integer. The default is 3.",
        SerializedName = @"ok-total-unready-count",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileOkTotalUnreadyCount { get => _parametersBody.AutoScalerProfileOkTotalUnreadyCount ?? null; set => _parametersBody.AutoScalerProfileOkTotalUnreadyCount = value; }

        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-add",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownDelayAfterAdd { get => _parametersBody.AutoScalerProfileScaleDownDelayAfterAdd ?? null; set => _parametersBody.AutoScalerProfileScaleDownDelayAfterAdd = value; }

        /// <summary>
        /// The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m)
        /// is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-delete",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownDelayAfterDelete { get => _parametersBody.AutoScalerProfileScaleDownDelayAfterDelete ?? null; set => _parametersBody.AutoScalerProfileScaleDownDelayAfterDelete = value; }

        /// <summary>
        /// The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-failure",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownDelayAfterFailure { get => _parametersBody.AutoScalerProfileScaleDownDelayAfterFailure ?? null; set => _parametersBody.AutoScalerProfileScaleDownDelayAfterFailure = value; }

        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-unneeded-time",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownUnneededTime { get => _parametersBody.AutoScalerProfileScaleDownUnneededTime ?? null; set => _parametersBody.AutoScalerProfileScaleDownUnneededTime = value; }

        /// <summary>
        /// The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-unready-time",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownUnreadyTime { get => _parametersBody.AutoScalerProfileScaleDownUnreadyTime ?? null; set => _parametersBody.AutoScalerProfileScaleDownUnreadyTime = value; }

        /// <summary>The default is '0.5'.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '0.5'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '0.5'.",
        SerializedName = @"scale-down-utilization-threshold",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownUtilizationThreshold { get => _parametersBody.AutoScalerProfileScaleDownUtilizationThreshold ?? null; set => _parametersBody.AutoScalerProfileScaleDownUtilizationThreshold = value; }

        /// <summary>The default is '10'. Values must be an integer number of seconds.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '10'. Values must be an integer number of seconds.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10'. Values must be an integer number of seconds.",
        SerializedName = @"scan-interval",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScanInterval { get => _parametersBody.AutoScalerProfileScanInterval ?? null; set => _parametersBody.AutoScalerProfileScanInterval = value; }

        /// <summary>The default is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is true.",
        SerializedName = @"skip-nodes-with-local-storage",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileSkipNodesWithLocalStorage { get => _parametersBody.AutoScalerProfileSkipNodesWithLocalStorage ?? null; set => _parametersBody.AutoScalerProfileSkipNodesWithLocalStorage = value; }

        /// <summary>The default is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is true.",
        SerializedName = @"skip-nodes-with-system-pods",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileSkipNodesWithSystemPod { get => _parametersBody.AutoScalerProfileSkipNodesWithSystemPod ?? null; set => _parametersBody.AutoScalerProfileSkipNodesWithSystemPod = value; }

        /// <summary>
        /// The default is Unmanaged, but may change to either NodeImage or SecurityPatch at GA.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is Unmanaged, but may change to either NodeImage or SecurityPatch at GA.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is Unmanaged, but may change to either NodeImage or SecurityPatch at GA.",
        SerializedName = @"nodeOSUpgradeChannel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeOSUpgradeChannel) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeOSUpgradeChannel))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeOSUpgradeChannel AutoUpgradeProfileNodeOSUpgradeChannel { get => _parametersBody.AutoUpgradeProfileNodeOSUpgradeChannel ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeOSUpgradeChannel)""); set => _parametersBody.AutoUpgradeProfileNodeOSUpgradeChannel = value; }

        /// <summary>
        /// For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).",
        SerializedName = @"upgradeChannel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel AutoUpgradeProfileUpgradeChannel { get => _parametersBody.AutoUpgradeProfileUpgradeChannel ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel)""); set => _parametersBody.AutoUpgradeProfileUpgradeChannel = value; }

        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Azure Key Vault key management service. The default is false.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Azure Key Vault key management service. The default is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AzureKeyVaultKmEnabled { get => _parametersBody.AzureKeyVaultKmEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AzureKeyVaultKmEnabled = value; }

        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.",
        SerializedName = @"keyId",
        PossibleTypes = new [] { typeof(string) })]
        public string AzureKeyVaultKmKeyId { get => _parametersBody.AzureKeyVaultKmKeyId ?? null; set => _parametersBody.AzureKeyVaultKmKeyId = value; }

        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.",
        SerializedName = @"keyVaultNetworkAccess",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes AzureKeyVaultKmKeyVaultNetworkAccess { get => _parametersBody.AzureKeyVaultKmKeyVaultNetworkAccess ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes)""); set => _parametersBody.AzureKeyVaultKmKeyVaultNetworkAccess = value; }

        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.",
        SerializedName = @"keyVaultResourceId",
        PossibleTypes = new [] { typeof(string) })]
        public string AzureKeyVaultKmKeyVaultResourceId { get => _parametersBody.AzureKeyVaultKmKeyVaultResourceId ?? null; set => _parametersBody.AzureKeyVaultKmKeyVaultResourceId = value; }

        /// <summary>Whether to enable AzureBlob CSI Driver. The default value is false.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable AzureBlob CSI Driver. The default value is false.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureBlob CSI Driver. The default value is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter BlobCsiDriverEnabled { get => _parametersBody.BlobCsiDriverEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.BlobCsiDriverEnabled = value; }

        /// <summary>The source where the artifacts are downloaded from.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The source where the artifacts are downloaded from.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The source where the artifacts are downloaded from.",
        SerializedName = @"artifactSource",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ArtifactSource) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ArtifactSource))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ArtifactSource BootstrapProfileArtifactSource { get => _parametersBody.BootstrapProfileArtifactSource ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ArtifactSource)""); set => _parametersBody.BootstrapProfileArtifactSource = value; }

        /// <summary>
        /// The resource Id of Azure Container Registry. The registry must have private network access, premium SKU and zone redundancy.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The resource Id of Azure Container Registry. The registry must have private network access, premium SKU and zone redundancy.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource Id of Azure Container Registry. The registry must have private network access, premium SKU and zone redundancy.",
        SerializedName = @"containerRegistryId",
        PossibleTypes = new [] { typeof(string) })]
        public string BootstrapProfileContainerRegistryId { get => _parametersBody.BootstrapProfileContainerRegistryId ?? null; set => _parametersBody.BootstrapProfileContainerRegistryId = value; }

        /// <summary>Wait for .NET debugger to attach</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter Break { get; set; }

        /// <summary>The reference to the client API class.</summary>
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ContainerServiceClient Client => Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.ClientAPI;

        /// <summary>Istio egress gateways.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Istio egress gateways.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Istio egress gateways.",
        SerializedName = @"egressGateways",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IIstioEgressGateway) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IIstioEgressGateway[] ComponentEgressGateway { get => _parametersBody.ComponentEgressGateway ?? null /* arrayOf */; set => _parametersBody.ComponentEgressGateway = value; }

        /// <summary>Istio ingress gateways.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Istio ingress gateways.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Istio ingress gateways.",
        SerializedName = @"ingressGateways",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IIstioIngressGateway) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IIstioIngressGateway[] ComponentIngressGateway { get => _parametersBody.ComponentIngressGateway ?? null /* arrayOf */; set => _parametersBody.ComponentIngressGateway = value; }

        /// <summary>
        /// Indicates whether custom metrics collection has to be disabled or not. If not specified the default is false. No custom
        /// metrics will be emitted if this field is false but the container insights enabled field is false
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates whether custom metrics collection has to be disabled or not. If not specified the default is false. No custom metrics will be emitted if this field is false but the container insights enabled field is false")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether custom metrics collection has to be disabled or not. If not specified the default is false. No custom metrics will be emitted if this field is false but the container insights enabled field is false",
        SerializedName = @"disableCustomMetrics",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ContainerInsightDisableCustomMetric { get => _parametersBody.ContainerInsightDisableCustomMetric ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ContainerInsightDisableCustomMetric = value; }

        /// <summary>
        /// Indicates whether prometheus metrics scraping is disabled or not. If not specified the default is false. No prometheus
        /// metrics will be emitted if this field is false but the container insights enabled field is false
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates whether prometheus metrics scraping is disabled or not. If not specified the default is false. No prometheus metrics will be emitted if this field is false but the container insights enabled field is false")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether prometheus metrics scraping is disabled or not. If not specified the default is false. No prometheus metrics will be emitted if this field is false but the container insights enabled field is false",
        SerializedName = @"disablePrometheusMetricsScraping",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ContainerInsightDisablePrometheusMetricsScraping { get => _parametersBody.ContainerInsightDisablePrometheusMetricsScraping ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ContainerInsightDisablePrometheusMetricsScraping = value; }

        /// <summary>Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates if Azure Monitor Container Insights Logs Addon is enabled or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ContainerInsightEnabled { get => _parametersBody.ContainerInsightEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ContainerInsightEnabled = value; }

        /// <summary>
        /// Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing Azure Monitor Container Insights Logs.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing Azure Monitor Container Insights Logs.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Fully Qualified ARM Resource Id of Azure Log Analytics Workspace for storing Azure Monitor Container Insights Logs.",
        SerializedName = @"logAnalyticsWorkspaceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        public string ContainerInsightLogAnalyticsWorkspaceResourceId { get => _parametersBody.ContainerInsightLogAnalyticsWorkspaceResourceId ?? null; set => _parametersBody.ContainerInsightLogAnalyticsWorkspaceResourceId = value; }

        /// <summary>The syslog host port. If not specified, the default port is 28330.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The syslog host port. If not specified, the default port is 28330.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The syslog host port. If not specified, the default port is 28330.",
        SerializedName = @"syslogPort",
        PossibleTypes = new [] { typeof(long) })]
        public long ContainerInsightSyslogPort { get => _parametersBody.ContainerInsightSyslogPort ?? default(long); set => _parametersBody.ContainerInsightSyslogPort = value; }

        /// <summary>
        /// The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable this feature. Enabling this will add Kubernetes
        /// Namespace and Deployment details to the Cost Analysis views in the Azure portal. If not specified, the default is false.
        /// For more information see aka.ms/aks/docs/cost-analysis.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal. If not specified, the default is false. For more information see aka.ms/aks/docs/cost-analysis.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal. If not specified, the default is false. For more information see aka.ms/aks/docs/cost-analysis.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter CostAnalysisEnabled { get => _parametersBody.CostAnalysisEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.CostAnalysisEnabled = value; }

        /// <summary>This is the ARM ID of the source object to be used to create the target object.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This is the ARM ID of the source object to be used to create the target object.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is the ARM ID of the source object to be used to create the target object.",
        SerializedName = @"sourceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        public string CreationDataSourceResourceId { get => _parametersBody.CreationDataSourceResourceId ?? null; set => _parametersBody.CreationDataSourceResourceId = value; }

        /// <summary>
        /// The DefaultProfile parameter is not functional. Use the SubscriptionId parameter when available if executing the cmdlet
        /// against a different subscription
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The DefaultProfile parameter is not functional. Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::System.Management.Automation.Alias("AzureRMContext", "AzureCredential")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Azure)]
        public global::System.Management.Automation.PSObject DefaultProfile { get; set; }

        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.",
        SerializedName = @"logAnalyticsWorkspaceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        public string DefenderLogAnalyticsWorkspaceResourceId { get => _parametersBody.DefenderLogAnalyticsWorkspaceResourceId ?? null; set => _parametersBody.DefenderLogAnalyticsWorkspaceResourceId = value; }

        /// <summary>
        /// If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters
        /// that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).",
        SerializedName = @"disableLocalAccounts",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter DisableLocalAccount { get => _parametersBody.DisableLocalAccount ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.DisableLocalAccount = value; }

        /// <summary>Whether to enable AzureDisk CSI Driver. The default value is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable AzureDisk CSI Driver. The default value is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureDisk CSI Driver. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter DiskCsiDriverEnabled { get => _parametersBody.DiskCsiDriverEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.DiskCsiDriverEnabled = value; }

        /// <summary>The version of AzureDisk CSI Driver. The default value is v1.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The version of AzureDisk CSI Driver. The default value is v1.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The version of AzureDisk CSI Driver. The default value is v1.",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        public string DiskCsiDriverVersion { get => _parametersBody.DiskCsiDriverVersion ?? null; set => _parametersBody.DiskCsiDriverVersion = value; }

        /// <summary>
        /// This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'",
        SerializedName = @"diskEncryptionSetID",
        PossibleTypes = new [] { typeof(string) })]
        public string DiskEncryptionSetId { get => _parametersBody.DiskEncryptionSetId ?? null; set => _parametersBody.DiskEncryptionSetId = value; }

        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This cannot be updated once the Managed Cluster has been created.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This cannot be updated once the Managed Cluster has been created.",
        SerializedName = @"dnsPrefix",
        PossibleTypes = new [] { typeof(string) })]
        public string DnsPrefix { get => _parametersBody.DnsPrefix ?? null; set => _parametersBody.DnsPrefix = value; }

        /// <summary>
        /// The default value is false. It can be enabled/disabled on creation and updating of the managed cluster. See [https://aka.ms/NamespaceARMResource](https://aka.ms/NamespaceARMResource)
        /// for more details on Namespace as a ARM Resource.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default value is false. It can be enabled/disabled on creation and updating of the managed cluster. See [https://aka.ms/NamespaceARMResource](https://aka.ms/NamespaceARMResource) for more details on Namespace as a ARM Resource.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default value is false. It can be enabled/disabled on creation and updating of the managed cluster. See [https://aka.ms/NamespaceARMResource](https://aka.ms/NamespaceARMResource) for more details on Namespace as a ARM Resource.",
        SerializedName = @"enableNamespaceResources",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnableNamespaceResource { get => _parametersBody.EnableNamespaceResource ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnableNamespaceResource = value; }

        /// <summary>
        /// (DEPRECATED) Whether to enable Kubernetes pod security policy (preview). PodSecurityPolicy was deprecated in Kubernetes
        /// v1.21, and removed from Kubernetes in v1.25. Learn more at https://aka.ms/k8s/psp and https://aka.ms/aks/psp.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "(DEPRECATED) Whether to enable Kubernetes pod security policy (preview). PodSecurityPolicy was deprecated in Kubernetes v1.21, and removed from Kubernetes in v1.25. Learn more at https://aka.ms/k8s/psp and https://aka.ms/aks/psp.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) Whether to enable Kubernetes pod security policy (preview). PodSecurityPolicy was deprecated in Kubernetes v1.21, and removed from Kubernetes in v1.25. Learn more at https://aka.ms/k8s/psp and https://aka.ms/aks/psp.",
        SerializedName = @"enablePodSecurityPolicy",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnablePodSecurityPolicy { get => _parametersBody.EnablePodSecurityPolicy ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnablePodSecurityPolicy = value; }

        /// <summary>Whether to enable Kubernetes Role-Based Access Control.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Kubernetes Role-Based Access Control.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Kubernetes Role-Based Access Control.",
        SerializedName = @"enableRBAC",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnableRbac { get => _parametersBody.EnableRbac ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnableRbac = value; }

        /// <summary>The name of the extended location.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of the extended location.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the extended location.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        public string ExtendedLocationName { get => _parametersBody.ExtendedLocationName ?? null; set => _parametersBody.ExtendedLocationName = value; }

        /// <summary>The type of the extended location.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The type of the extended location.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of the extended location.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ExtendedLocationTypes) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ExtendedLocationTypes))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ExtendedLocationTypes ExtendedLocationType { get => _parametersBody.ExtendedLocationType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ExtendedLocationTypes)""); set => _parametersBody.ExtendedLocationType = value; }

        /// <summary>Whether to enable AzureFile CSI Driver. The default value is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable AzureFile CSI Driver. The default value is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureFile CSI Driver. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter FileCsiDriverEnabled { get => _parametersBody.FileCsiDriverEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.FileCsiDriverEnabled = value; }

        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This cannot be updated once the Managed Cluster has been created.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This cannot be updated once the Managed Cluster has been created.",
        SerializedName = @"fqdnSubdomain",
        PossibleTypes = new [] { typeof(string) })]
        public string FqdnSubdomain { get => _parametersBody.FqdnSubdomain ?? null; set => _parametersBody.FqdnSubdomain = value; }

        /// <summary>
        /// Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet
        /// which is used to create the managed cluster.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.",
        SerializedName = @"dnsServer",
        PossibleTypes = new [] { typeof(string) })]
        public string GmsaProfileDnsServer { get => _parametersBody.GmsaProfileDnsServer ?? null; set => _parametersBody.GmsaProfileDnsServer = value; }

        /// <summary>Specifies whether to enable Windows gMSA in the managed cluster.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies whether to enable Windows gMSA in the managed cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether to enable Windows gMSA in the managed cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter GmsaProfileEnabled { get => _parametersBody.GmsaProfileEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.GmsaProfileEnabled = value; }

        /// <summary>
        /// Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the
        /// vnet which is used to create the managed cluster.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.",
        SerializedName = @"rootDomainName",
        PossibleTypes = new [] { typeof(string) })]
        public string GmsaProfileRootDomainName { get => _parametersBody.GmsaProfileRootDomainName ?? null; set => _parametersBody.GmsaProfileRootDomainName = value; }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>The HTTP proxy server endpoint to use.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The HTTP proxy server endpoint to use.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The HTTP proxy server endpoint to use.",
        SerializedName = @"httpProxy",
        PossibleTypes = new [] { typeof(string) })]
        public string HttpProxyConfigHttpProxy { get => _parametersBody.HttpProxyConfigHttpProxy ?? null; set => _parametersBody.HttpProxyConfigHttpProxy = value; }

        /// <summary>The HTTPS proxy server endpoint to use.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The HTTPS proxy server endpoint to use.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The HTTPS proxy server endpoint to use.",
        SerializedName = @"httpsProxy",
        PossibleTypes = new [] { typeof(string) })]
        public string HttpProxyConfigHttpsProxy { get => _parametersBody.HttpProxyConfigHttpsProxy ?? null; set => _parametersBody.HttpProxyConfigHttpsProxy = value; }

        /// <summary>The endpoints that should not go through proxy.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The endpoints that should not go through proxy.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoints that should not go through proxy.",
        SerializedName = @"noProxy",
        PossibleTypes = new [] { typeof(string) })]
        public string[] HttpProxyConfigNoProxy { get => _parametersBody.HttpProxyConfigNoProxy ?? null /* arrayOf */; set => _parametersBody.HttpProxyConfigNoProxy = value; }

        /// <summary>Alternative CA cert to use for connecting to proxy servers.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Alternative CA cert to use for connecting to proxy servers.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Alternative CA cert to use for connecting to proxy servers.",
        SerializedName = @"trustedCa",
        PossibleTypes = new [] { typeof(string) })]
        public string HttpProxyConfigTrustedCa { get => _parametersBody.HttpProxyConfigTrustedCa ?? null; set => _parametersBody.HttpProxyConfigTrustedCa = value; }

        /// <summary>
        /// The delegated identity resources assigned to this managed cluster. This can only be set by another Azure Resource Provider,
        /// and managed cluster only accept one delegated identity resource. Internal use only.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The delegated identity resources assigned to this managed cluster. This can only be set by another Azure Resource Provider, and managed cluster only accept one delegated identity resource. Internal use only.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The delegated identity resources assigned to this managed cluster. This can only be set by another Azure Resource Provider, and managed cluster only accept one delegated identity resource. Internal use only.",
        SerializedName = @"delegatedResources",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api40.IDelegatedResources) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api40.IDelegatedResources IdentityDelegatedResource { get => _parametersBody.IdentityDelegatedResource ?? null /* object */; set => _parametersBody.IdentityDelegatedResource = value; }

        /// <summary>
        /// The user identity associated with the managed cluster. This identity will be used by the kubelet. Only one user assigned
        /// identity is allowed. The only accepted key is "kubeletidentity", with value of "resourceId": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}".
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The user identity associated with the managed cluster. This identity will be used by the kubelet. Only one user assigned identity is allowed. The only accepted key is \"kubeletidentity\", with value of \"resourceId\": \"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}\".")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The user identity associated with the managed cluster. This identity will be used by the kubelet. Only one user assigned identity is allowed. The only accepted key is ""kubeletidentity"", with value of ""resourceId"": ""/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}"".",
        SerializedName = @"identityProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterPropertiesIdentityProfile) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterPropertiesIdentityProfile IdentityProfile { get => _parametersBody.IdentityProfile ?? null /* object */; set => _parametersBody.IdentityProfile = value; }

        /// <summary>
        /// For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ResourceIdentityType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ResourceIdentityType))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ResourceIdentityType IdentityType { get => _parametersBody.IdentityType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ResourceIdentityType)""); set => _parametersBody.IdentityType = value; }

        /// <summary>
        /// The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.",
        SerializedName = @"userAssignedIdentities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterIdentityUserAssignedIdentities) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterIdentityUserAssignedIdentities IdentityUserAssignedIdentity { get => _parametersBody.IdentityUserAssignedIdentity ?? null /* object */; set => _parametersBody.IdentityUserAssignedIdentity = value; }

        /// <summary>Backing field for <see cref="IfMatch" /> property.</summary>
        private string _ifMatch;

        /// <summary>The request should only proceed if an entity matches this string.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The request should only proceed if an entity matches this string.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The request should only proceed if an entity matches this string.",
        SerializedName = @"If-Match",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Header)]
        public string IfMatch { get => this._ifMatch; set => this._ifMatch = value; }

        /// <summary>Backing field for <see cref="IfNoneMatch" /> property.</summary>
        private string _ifNoneMatch;

        /// <summary>The request should only proceed if no entity matches this string.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The request should only proceed if no entity matches this string.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The request should only proceed if no entity matches this string.",
        SerializedName = @"If-None-Match",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Header)]
        public string IfNoneMatch { get => this._ifNoneMatch; set => this._ifNoneMatch = value; }

        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Image Cleaner on AKS cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Image Cleaner on AKS cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ImageCleanerEnabled { get => _parametersBody.ImageCleanerEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ImageCleanerEnabled = value; }

        /// <summary>Image Cleaner scanning interval in hours.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Image Cleaner scanning interval in hours.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Image Cleaner scanning interval in hours.",
        SerializedName = @"intervalHours",
        PossibleTypes = new [] { typeof(int) })]
        public int ImageCleanerIntervalHour { get => _parametersBody.ImageCleanerIntervalHour ?? default(int); set => _parametersBody.ImageCleanerIntervalHour = value; }

        /// <summary>Whether to enable image integrity. The default value is false.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable image integrity. The default value is false.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable image integrity. The default value is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ImageIntegrityEnabled { get => _parametersBody.ImageIntegrityEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ImageIntegrityEnabled = value; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public global::System.Management.Automation.InvocationInfo InvocationInformation { get => __invocationInfo = __invocationInfo ?? this.MyInvocation ; set { __invocationInfo = value; } }

        /// <summary>
        /// The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary
        /// upgrade is in progress, this can only hold two consecutive values. For more information, see: https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary upgrade is in progress, this can only hold two consecutive values. For more information, see: https://learn.microsoft.com/en-us/azure/aks/istio-upgrade")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary upgrade is in progress, this can only hold two consecutive values. For more information, see: https://learn.microsoft.com/en-us/azure/aks/istio-upgrade",
        SerializedName = @"revisions",
        PossibleTypes = new [] { typeof(string) })]
        public string[] IstioRevision { get => _parametersBody.IstioRevision ?? null /* arrayOf */; set => _parametersBody.IstioRevision = value; }

        /// <summary>Whether to enable KEDA.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable KEDA.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable KEDA.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter KedaEnabled { get => _parametersBody.KedaEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.KedaEnabled = value; }

        /// <summary>
        /// This is primarily used to expose different UI experiences in the portal for different kinds
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This is primarily used to expose different UI experiences in the portal for different kinds")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is primarily used to expose different UI experiences in the portal for different kinds",
        SerializedName = @"kind",
        PossibleTypes = new [] { typeof(string) })]
        public string Kind { get => _parametersBody.Kind ?? null; set => _parametersBody.Kind = value; }

        /// <summary>
        /// Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.",
        SerializedName = @"metricAnnotationsAllowList",
        PossibleTypes = new [] { typeof(string) })]
        public string KubeStateMetricAnnotationsAllowList { get => _parametersBody.KubeStateMetricAnnotationsAllowList ?? null; set => _parametersBody.KubeStateMetricAnnotationsAllowList = value; }

        /// <summary>
        /// Comma-separated list of Kubernetes annotations keys that will be used in the resource's labels metric.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Comma-separated list of Kubernetes annotations keys that will be used in the resource's labels metric. ")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Comma-separated list of Kubernetes annotations keys that will be used in the resource's labels metric. ",
        SerializedName = @"metricLabelsAllowlist",
        PossibleTypes = new [] { typeof(string) })]
        public string KubeStateMetricLabelsAllowlist { get => _parametersBody.KubeStateMetricLabelsAllowlist ?? null; set => _parametersBody.KubeStateMetricLabelsAllowlist = value; }

        /// <summary>
        /// When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed
        /// sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed,
        /// however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster)
        /// for more details.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed, however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more details.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed, however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more details.",
        SerializedName = @"kubernetesVersion",
        PossibleTypes = new [] { typeof(string) })]
        public string KubernetesVersion { get => _parametersBody.KubernetesVersion ?? null; set => _parametersBody.KubernetesVersion = value; }

        /// <summary>The administrator username to use for Linux VMs.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The administrator username to use for Linux VMs.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The administrator username to use for Linux VMs.",
        SerializedName = @"adminUsername",
        PossibleTypes = new [] { typeof(string) })]
        public string LinuxProfileAdminUsername { get => _parametersBody.LinuxProfileAdminUsername ?? null; set => _parametersBody.LinuxProfileAdminUsername = value; }

        /// <summary>The geo-location where the resource lives</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The geo-location where the resource lives")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The geo-location where the resource lives",
        SerializedName = @"location",
        PossibleTypes = new [] { typeof(string) })]
        public string Location { get => _parametersBody.Location ?? null; set => _parametersBody.Location = value; }

        /// <summary>Whether to enable the Prometheus collector</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable the Prometheus collector")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable the Prometheus collector",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter MetricEnabled { get => _parametersBody.MetricEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.MetricEnabled = value; }

        /// <summary>
        /// <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        /// <summary><see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener.Token => _cancellationTokenSource.Token;

        /// <summary>The network configuration profile.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The network configuration profile.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The network configuration profile.",
        SerializedName = @"networkProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IContainerServiceNetworkProfile) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IContainerServiceNetworkProfile NetworkProfile { get => _parametersBody.NetworkProfile ?? null /* object */; set => _parametersBody.NetworkProfile = value; }

        /// <summary>Ingress type for the default NginxIngressController custom resource</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Ingress type for the default NginxIngressController custom resource")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Ingress type for the default NginxIngressController custom resource",
        SerializedName = @"defaultIngressControllerType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NginxIngressControllerType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NginxIngressControllerType))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NginxIngressControllerType NginxDefaultIngressControllerType { get => _parametersBody.NginxDefaultIngressControllerType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NginxIngressControllerType)""); set => _parametersBody.NginxDefaultIngressControllerType = value; }

        /// <summary>
        /// when specified, will make the remote call, and return an AsyncOperationResponse, letting the remote operation continue
        /// asynchronously.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command asynchronously")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter NoWait { get; set; }

        /// <summary>Once the mode it set to Auto, it cannot be changed back to Manual.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Once the mode it set to Auto, it cannot be changed back to Manual.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Once the mode it set to Auto, it cannot be changed back to Manual.",
        SerializedName = @"mode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningMode) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningMode))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningMode NodeProvisioningProfileMode { get => _parametersBody.NodeProvisioningProfileMode ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.NodeProvisioningMode)""); set => _parametersBody.NodeProvisioningProfileMode = value; }

        /// <summary>The name of the resource group containing agent pool nodes.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of the resource group containing agent pool nodes.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the resource group containing agent pool nodes.",
        SerializedName = @"nodeResourceGroup",
        PossibleTypes = new [] { typeof(string) })]
        public string NodeResourceGroup { get => _parametersBody.NodeResourceGroup ?? null; set => _parametersBody.NodeResourceGroup = value; }

        /// <summary>The restriction level applied to the cluster's node resource group</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The restriction level applied to the cluster's node resource group")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The restriction level applied to the cluster's node resource group",
        SerializedName = @"restrictionLevel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.RestrictionLevel) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.RestrictionLevel))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.RestrictionLevel NodeResourceGroupProfileRestrictionLevel { get => _parametersBody.NodeResourceGroupProfileRestrictionLevel ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.RestrictionLevel)""); set => _parametersBody.NodeResourceGroupProfileRestrictionLevel = value; }

        /// <summary>Whether to enable Node Restriction</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Node Restriction")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Node Restriction",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter NodeRestrictionEnabled { get => _parametersBody.NodeRestrictionEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.NodeRestrictionEnabled = value; }

        /// <summary>Whether the OIDC issuer is enabled.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether the OIDC issuer is enabled.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether the OIDC issuer is enabled.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter OidcIssuerProfileEnabled { get => _parametersBody.OidcIssuerProfileEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.OidcIssuerProfileEnabled = value; }

        /// <summary>
        /// Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates if Application Monitoring Open Telemetry Logs and traces is enabled or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter OpenTelemetryLogEnabled { get => _parametersBody.OpenTelemetryLogEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.OpenTelemetryLogEnabled = value; }

        /// <summary>
        /// The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default port is 28331.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default port is 28331.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Open Telemetry host port for Open Telemetry logs and traces. If not specified, the default port is 28331.",
        SerializedName = @"port",
        PossibleTypes = new [] { typeof(long) })]
        public long OpenTelemetryLogPort { get => _parametersBody.OpenTelemetryLogPort ?? default(long); set => _parametersBody.OpenTelemetryLogPort = value; }

        /// <summary>Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates if Application Monitoring Open Telemetry Metrics is enabled or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter OpenTelemetryMetricEnabled { get => _parametersBody.OpenTelemetryMetricEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.OpenTelemetryMetricEnabled = value; }

        /// <summary>
        /// The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is 28333.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is 28333.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Open Telemetry host port for Open Telemetry metrics. If not specified, the default port is 28333.",
        SerializedName = @"port",
        PossibleTypes = new [] { typeof(long) })]
        public long OpenTelemetryMetricPort { get => _parametersBody.OpenTelemetryMetricPort ?? default(long); set => _parametersBody.OpenTelemetryMetricPort = value; }

        /// <summary>
        /// Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade protections
        /// such as checking for deprecated API usage. Enable this option only with caution.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade protections such as checking for deprecated API usage. Enable this option only with caution.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade protections such as checking for deprecated API usage. Enable this option only with caution.",
        SerializedName = @"forceUpgrade",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter OverrideSettingForceUpgrade { get => _parametersBody.OverrideSettingForceUpgrade ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.OverrideSettingForceUpgrade = value; }

        /// <summary>
        /// Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the effectiveness
        /// won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set by default.
        /// It must be set for the overrides to take effect.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the effectiveness won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set by default. It must be set for the overrides to take effect.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the effectiveness won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set by default. It must be set for the overrides to take effect.",
        SerializedName = @"until",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        public global::System.DateTime OverrideSettingUntil { get => _parametersBody.OverrideSettingUntil ?? default(global::System.DateTime); set => _parametersBody.OverrideSettingUntil = value; }

        /// <summary>
        /// The instance of the <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.HttpPipeline" /> that the remote call will use.
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.HttpPipeline Pipeline { get; set; }

        /// <summary>Certificate chain object name in Azure Key Vault.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Certificate chain object name in Azure Key Vault.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Certificate chain object name in Azure Key Vault.",
        SerializedName = @"certChainObjectName",
        PossibleTypes = new [] { typeof(string) })]
        public string PluginCertChainObjectName { get => _parametersBody.PluginCertChainObjectName ?? null; set => _parametersBody.PluginCertChainObjectName = value; }

        /// <summary>Intermediate certificate object name in Azure Key Vault.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Intermediate certificate object name in Azure Key Vault.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Intermediate certificate object name in Azure Key Vault.",
        SerializedName = @"certObjectName",
        PossibleTypes = new [] { typeof(string) })]
        public string PluginCertObjectName { get => _parametersBody.PluginCertObjectName ?? null; set => _parametersBody.PluginCertObjectName = value; }

        /// <summary>Intermediate certificate private key object name in Azure Key Vault.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Intermediate certificate private key object name in Azure Key Vault.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Intermediate certificate private key object name in Azure Key Vault.",
        SerializedName = @"keyObjectName",
        PossibleTypes = new [] { typeof(string) })]
        public string PluginKeyObjectName { get => _parametersBody.PluginKeyObjectName ?? null; set => _parametersBody.PluginKeyObjectName = value; }

        /// <summary>The resource ID of the Key Vault.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The resource ID of the Key Vault.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource ID of the Key Vault.",
        SerializedName = @"keyVaultId",
        PossibleTypes = new [] { typeof(string) })]
        public string PluginKeyVaultId { get => _parametersBody.PluginKeyVaultId ?? null; set => _parametersBody.PluginKeyVaultId = value; }

        /// <summary>Root certificate object name in Azure Key Vault.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Root certificate object name in Azure Key Vault.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Root certificate object name in Azure Key Vault.",
        SerializedName = @"rootCertObjectName",
        PossibleTypes = new [] { typeof(string) })]
        public string PluginRootCertObjectName { get => _parametersBody.PluginRootCertObjectName ?? null; set => _parametersBody.PluginRootCertObjectName = value; }

        /// <summary>
        /// Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing.
        /// See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
        /// for more information.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities) for more information.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities) for more information.",
        SerializedName = @"allowNetworkPluginKubenet",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter PodIdentityProfileAllowNetworkPluginKubenet { get => _parametersBody.PodIdentityProfileAllowNetworkPluginKubenet ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.PodIdentityProfileAllowNetworkPluginKubenet = value; }

        /// <summary>Whether the pod identity addon is enabled.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether the pod identity addon is enabled.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether the pod identity addon is enabled.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter PodIdentityProfileEnabled { get => _parametersBody.PodIdentityProfileEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.PodIdentityProfileEnabled = value; }

        /// <summary>The pod identities to use in the cluster.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The pod identities to use in the cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The pod identities to use in the cluster.",
        SerializedName = @"userAssignedIdentities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterPodIdentity) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterPodIdentity[] PodIdentityProfileUserAssignedIdentity { get => _parametersBody.PodIdentityProfileUserAssignedIdentity ?? null /* arrayOf */; set => _parametersBody.PodIdentityProfileUserAssignedIdentity = value; }

        /// <summary>The pod identity exceptions to allow.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The pod identity exceptions to allow.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The pod identity exceptions to allow.",
        SerializedName = @"userAssignedIdentityExceptions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterPodIdentityException) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedClusterPodIdentityException[] PodIdentityProfileUserAssignedIdentityException { get => _parametersBody.PodIdentityProfileUserAssignedIdentityException ?? null /* arrayOf */; set => _parametersBody.PodIdentityProfileUserAssignedIdentityException = value; }

        /// <summary>Private link resources associated with the cluster.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Private link resources associated with the cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Private link resources associated with the cluster.",
        SerializedName = @"privateLinkResources",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IPrivateLinkResource) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IPrivateLinkResource[] PrivateLinkResource { get => _parametersBody.PrivateLinkResource ?? null /* arrayOf */; set => _parametersBody.PrivateLinkResource = value; }

        /// <summary>The URI for the proxy server to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>Allow or deny public network access for AKS</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Allow or deny public network access for AKS")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allow or deny public network access for AKS",
        SerializedName = @"publicNetworkAccess",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess PublicNetworkAccess { get => _parametersBody.PublicNetworkAccess ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess)""); set => _parametersBody.PublicNetworkAccess = value; }

        /// <summary>Backing field for <see cref="ResourceGroupName" /> property.</summary>
        private string _resourceGroupName;

        /// <summary>The name of the resource group. The name is case insensitive.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the resource group. The name is case insensitive.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the resource group. The name is case insensitive.",
        SerializedName = @"resourceGroupName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Path)]
        public string ResourceGroupName { get => this._resourceGroupName; set => this._resourceGroupName = value; }

        /// <summary>Backing field for <see cref="ResourceName" /> property.</summary>
        private string _resourceName;

        /// <summary>The name of the managed cluster resource.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the managed cluster resource.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the managed cluster resource.",
        SerializedName = @"resourceName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Path)]
        public string ResourceName { get => this._resourceName; set => this._resourceName = value; }

        /// <summary>List of namespaces excluded from Safeguards checks</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "List of namespaces excluded from Safeguards checks")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of namespaces excluded from Safeguards checks",
        SerializedName = @"excludedNamespaces",
        PossibleTypes = new [] { typeof(string) })]
        public string[] SafeguardProfileExcludedNamespace { get => _parametersBody.SafeguardProfileExcludedNamespace ?? null /* arrayOf */; set => _parametersBody.SafeguardProfileExcludedNamespace = value; }

        /// <summary>
        /// The Safeguards level to be used. By default, Safeguards is enabled for all namespaces except those that AKS excludes via
        /// systemExcludedNamespaces
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The Safeguards level to be used. By default, Safeguards is enabled for all namespaces except those that AKS excludes via systemExcludedNamespaces")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Safeguards level to be used. By default, Safeguards is enabled for all namespaces except those that AKS excludes via systemExcludedNamespaces",
        SerializedName = @"level",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Level) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Level))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Level SafeguardProfileLevel { get => _parametersBody.SafeguardProfileLevel ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Level)""); set => _parametersBody.SafeguardProfileLevel = value; }

        /// <summary>The version of constraints to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The version of constraints to use")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The version of constraints to use",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        public string SafeguardProfileVersion { get => _parametersBody.SafeguardProfileVersion ?? null; set => _parametersBody.SafeguardProfileVersion = value; }

        /// <summary>Whether to enable Defender threat detection</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Defender threat detection")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Defender threat detection",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter SecurityMonitoringEnabled { get => _parametersBody.SecurityMonitoringEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.SecurityMonitoringEnabled = value; }

        /// <summary>
        /// A list of up to 10 base64 encoded CAs that will be added to the trust store on nodes with the Custom CA Trust feature
        /// enabled. For more information see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority)
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A list of up to 10 base64 encoded CAs that will be added to the trust store on nodes with the Custom CA Trust feature enabled. For more information see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority)")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A list of up to 10 base64 encoded CAs that will be added to the trust store on nodes with the Custom CA Trust feature enabled. For more information see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority)",
        SerializedName = @"customCATrustCertificates",
        PossibleTypes = new [] { typeof(byte[]) })]
        public byte[][] SecurityProfileCustomCaTrustCertificate { get => _parametersBody.SecurityProfileCustomCaTrustCertificate ?? null /* arrayOf */; set => _parametersBody.SecurityProfileCustomCaTrustCertificate = value; }

        /// <summary>Mode of the service mesh.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Mode of the service mesh.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Mode of the service mesh.",
        SerializedName = @"mode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ServiceMeshMode) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ServiceMeshMode))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ServiceMeshMode ServiceMeshProfileMode { get => _parametersBody.ServiceMeshProfileMode ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ServiceMeshMode)""); set => _parametersBody.ServiceMeshProfileMode = value; }

        /// <summary>The ID for the service principal.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The ID for the service principal.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The ID for the service principal.",
        SerializedName = @"clientId",
        PossibleTypes = new [] { typeof(string) })]
        public string ServicePrincipalProfileClientId { get => _parametersBody.ServicePrincipalProfileClientId ?? null; set => _parametersBody.ServicePrincipalProfileClientId = value; }

        /// <summary>The secret password associated with the service principal in plain text.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The secret password associated with the service principal in plain text.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The secret password associated with the service principal in plain text.",
        SerializedName = @"secret",
        PossibleTypes = new [] { typeof(string) })]
        public string ServicePrincipalProfileSecret { get => _parametersBody.ServicePrincipalProfileSecret ?? null; set => _parametersBody.ServicePrincipalProfileSecret = value; }

        /// <summary>The name of a managed cluster SKU.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of a managed cluster SKU.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of a managed cluster SKU.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuName) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuName))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuName SkuName { get => _parametersBody.SkuName ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuName)""); set => _parametersBody.SkuName = value; }

        /// <summary>
        /// If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers)
        /// for more details.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.",
        SerializedName = @"tier",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuTier) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuTier))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuTier SkuTier { get => _parametersBody.SkuTier ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuTier)""); set => _parametersBody.SkuTier = value; }

        /// <summary>Whether to enable Snapshot Controller. The default value is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Snapshot Controller. The default value is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Snapshot Controller. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter SnapshotControllerEnabled { get => _parametersBody.SnapshotControllerEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.SnapshotControllerEnabled = value; }

        /// <summary>
        /// The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.",
        SerializedName = @"publicKeys",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IContainerServiceSshPublicKey) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IContainerServiceSshPublicKey[] SshPublicKey { get => _parametersBody.SshPublicKey ?? null /* arrayOf */; set => _parametersBody.SshPublicKey = value; }

        /// <summary>Backing field for <see cref="SubscriptionId" /> property.</summary>
        private string _subscriptionId;

        /// <summary>The ID of the target subscription. The value must be an UUID.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The ID of the target subscription. The value must be an UUID.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The ID of the target subscription. The value must be an UUID.",
        SerializedName = @"subscriptionId",
        PossibleTypes = new [] { typeof(string) })]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.DefaultInfo(
        Name = @"",
        Description =@"",
        Script = @"(Get-AzContext).Subscription.Id")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Path)]
        public string SubscriptionId { get => this._subscriptionId; set => this._subscriptionId = value; }

        /// <summary>
        /// The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.",
        SerializedName = @"supportPlan",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan SupportPlan { get => _parametersBody.SupportPlan ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan)""); set => _parametersBody.SupportPlan = value; }

        /// <summary>Resource tags.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Resource tags.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource tags.",
        SerializedName = @"tags",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api50.ITrackedResourceTags) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api50.ITrackedResourceTags Tag { get => _parametersBody.Tag ?? null /* object */; set => _parametersBody.Tag = value; }

        /// <summary>Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether VPA add-on is enabled and configured to scale AKS-managed add-ons.",
        SerializedName = @"addonAutoscaling",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AddonAutoscaling) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AddonAutoscaling))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AddonAutoscaling VerticalPodAutoscalerAddonAutoscaling { get => _parametersBody.VerticalPodAutoscalerAddonAutoscaling ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AddonAutoscaling)""); set => _parametersBody.VerticalPodAutoscalerAddonAutoscaling = value; }

        /// <summary>Whether to enable VPA add-on in cluster. Default value is false.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable VPA add-on in cluster. Default value is false.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable VPA add-on in cluster. Default value is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter VerticalPodAutoscalerEnabled { get => _parametersBody.VerticalPodAutoscalerEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.VerticalPodAutoscalerEnabled = value; }

        /// <summary>
        /// Resource IDs of the DNS zones to be associated with the Web App Routing add-on. Used only when Web App Routing is enabled.
        /// Public and private DNS zones can be in different resource groups, but all public DNS zones must be in the same resource
        /// group and all private DNS zones must be in the same resource group.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Resource IDs of the DNS zones to be associated with the Web App Routing add-on. Used only when Web App Routing is enabled. Public and private DNS zones can be in different resource groups, but all public DNS zones must be in the same resource group and all private DNS zones must be in the same resource group.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource IDs of the DNS zones to be associated with the Web App Routing add-on. Used only when Web App Routing is enabled. Public and private DNS zones can be in different resource groups, but all public DNS zones must be in the same resource group and all private DNS zones must be in the same resource group.",
        SerializedName = @"dnsZoneResourceIds",
        PossibleTypes = new [] { typeof(string) })]
        public string[] WebAppRoutingDnsZoneResourceId { get => _parametersBody.WebAppRoutingDnsZoneResourceId ?? null /* arrayOf */; set => _parametersBody.WebAppRoutingDnsZoneResourceId = value; }

        /// <summary>Whether to enable Web App Routing.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Web App Routing.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Web App Routing.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter WebAppRoutingEnabled { get => _parametersBody.WebAppRoutingEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.WebAppRoutingEnabled = value; }

        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:**
        /// 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters
        /// <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:**
        /// "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\\W_]) <br><br> **Disallowed values:** \"abc@123\", \"P@$$w0rd\", \"P@ssw0rd\", \"P@ssword123\", \"Pa$$word\", \"pass@word1\", \"Password!\", \"Password1\", \"Password22\", \"iloveyou!\"")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** ""abc@123"", ""P@$$w0rd"", ""P@ssw0rd"", ""P@ssword123"", ""Pa$$word"", ""pass@word1"", ""Password!"", ""Password1"", ""Password22"", ""iloveyou!""",
        SerializedName = @"adminPassword",
        PossibleTypes = new [] { typeof(string) })]
        public string WindowProfileAdminPassword { get => _parametersBody.WindowProfileAdminPassword ?? null; set => _parametersBody.WindowProfileAdminPassword = value; }

        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm",
        /// "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0",
        /// "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in \".\" <br><br> **Disallowed values:** \"administrator\", \"admin\", \"user\", \"user1\", \"test\", \"user2\", \"test1\", \"user3\", \"admin1\", \"1\", \"123\", \"a\", \"actuser\", \"adm\", \"admin2\", \"aspnet\", \"backup\", \"console\", \"david\", \"guest\", \"john\", \"owner\", \"root\", \"server\", \"sql\", \"support\", \"support_388945a0\", \"sys\", \"test2\", \"test3\", \"user4\", \"user5\". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in ""."" <br><br> **Disallowed values:** ""administrator"", ""admin"", ""user"", ""user1"", ""test"", ""user2"", ""test1"", ""user3"", ""admin1"", ""1"", ""123"", ""a"", ""actuser"", ""adm"", ""admin2"", ""aspnet"", ""backup"", ""console"", ""david"", ""guest"", ""john"", ""owner"", ""root"", ""server"", ""sql"", ""support"", ""support_388945a0"", ""sys"", ""test2"", ""test3"", ""user4"", ""user5"". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters",
        SerializedName = @"adminUsername",
        PossibleTypes = new [] { typeof(string) })]
        public string WindowProfileAdminUsername { get => _parametersBody.WindowProfileAdminUsername ?? null; set => _parametersBody.WindowProfileAdminUsername = value; }

        /// <summary>
        /// For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).",
        SerializedName = @"enableCSIProxy",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter WindowProfileEnableCsiProxy { get => _parametersBody.WindowProfileEnableCsiProxy ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.WindowProfileEnableCsiProxy = value; }

        /// <summary>
        /// The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/)
        /// for more details.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.",
        SerializedName = @"licenseType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType WindowProfileLicenseType { get => _parametersBody.WindowProfileLicenseType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType)""); set => _parametersBody.WindowProfileLicenseType = value; }

        /// <summary>Whether to enable workload identity.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable workload identity.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable workload identity.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter WorkloadIdentityEnabled { get => _parametersBody.WorkloadIdentityEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.WorkloadIdentityEnabled = value; }

        /// <summary>
        /// <c>overrideOnDefault</c> will be called before the regular onDefault has been processed, allowing customization of what
        /// happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.ICloudError">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.ICloudError</see>
        /// from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onDefault method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.ICloudError> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnOk</c> will be called before the regular onOk has been processed, allowing customization of what happens
        /// on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedCluster">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedCluster</see>
        /// from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onOk method should be processed, or if the method should return
        /// immediately (set to true to skip further processing )</param>

        partial void overrideOnOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedCluster> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            var telemetryId = Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.GetTelemetryId.Invoke();
            if (telemetryId != "" && telemetryId != "internal")
            {
                __correlationId = telemetryId;
            }
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break)
            {
                Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.AttachDebugger.Break();
            }
            ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletBeginProcessing).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Creates a duplicate instance of this cmdlet (via JSON serialization).</summary>
        /// <returns>a duplicate instance of NewAzContainerServiceManagedCluster_CreateExpanded</returns>
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Cmdlets.NewAzContainerServiceManagedCluster_CreateExpanded Clone()
        {
            var clone = new NewAzContainerServiceManagedCluster_CreateExpanded();
            clone.__correlationId = this.__correlationId;
            clone.__processRecordId = this.__processRecordId;
            clone.DefaultProfile = this.DefaultProfile;
            clone.InvocationInformation = this.InvocationInformation;
            clone.Proxy = this.Proxy;
            clone.Pipeline = this.Pipeline;
            clone.AsJob = this.AsJob;
            clone.Break = this.Break;
            clone.ProxyCredential = this.ProxyCredential;
            clone.ProxyUseDefaultCredentials = this.ProxyUseDefaultCredentials;
            clone.HttpPipelinePrepend = this.HttpPipelinePrepend;
            clone.HttpPipelineAppend = this.HttpPipelineAppend;
            clone._parametersBody = this._parametersBody;
            clone.SubscriptionId = this.SubscriptionId;
            clone.ResourceGroupName = this.ResourceGroupName;
            clone.ResourceName = this.ResourceName;
            clone.IfMatch = this.IfMatch;
            clone.IfNoneMatch = this.IfNoneMatch;
            return clone;
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {
            var telemetryInfo = Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.GetTelemetryInfo?.Invoke(__correlationId);
            if (telemetryInfo != null)
            {
                telemetryInfo.TryGetValue("ShowSecretsWarning", out var showSecretsWarning);
                telemetryInfo.TryGetValue("SanitizedProperties", out var sanitizedProperties);
                telemetryInfo.TryGetValue("InvocationName", out var invocationName);
                if (showSecretsWarning == "true")
                {
                    if (string.IsNullOrEmpty(sanitizedProperties))
                    {
                        WriteWarning($"The output of cmdlet {invocationName} may compromise security by showing secrets. Learn more at https://go.microsoft.com/fwlink/?linkid=2258844");
                    }
                    else
                    {
                        WriteWarning($"The output of cmdlet {invocationName} may compromise security by showing the following secrets: {sanitizedProperties}. Learn more at https://go.microsoft.com/fwlink/?linkid=2258844");
                    }
                }
            }
        }

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the message is completed.
        /// </returns>
         async global::System.Threading.Tasks.Task Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Warning:
                    {
                        WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Information:
                    {
                        // When an operation supports asjob, Information messages must go thru verbose.
                        WriteVerbose($"INFORMATION: {(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Debug:
                    {
                        WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Error:
                    {
                        WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.DelayBeforePolling:
                    {
                        if (true == MyInvocation?.BoundParameters?.ContainsKey("NoWait"))
                        {
                            var data = messageData();
                            if (data.ResponseMessage is System.Net.Http.HttpResponseMessage response)
                            {
                                var asyncOperation = response.GetFirstHeader(@"Azure-AsyncOperation");
                                var location = response.GetFirstHeader(@"Location");
                                var uri = global::System.String.IsNullOrEmpty(asyncOperation) ? global::System.String.IsNullOrEmpty(location) ? response.RequestMessage.RequestUri.AbsoluteUri : location : asyncOperation;
                                WriteObject(new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.AsyncOperationResponse { Target = uri });
                                // do nothing more.
                                data.Cancel();
                                return;
                            }
                        }
                        break;
                    }
                }
                await Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.Signal(id, token, messageData, (i,t,m) => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(i,t,()=> Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.EventDataConverter.ConvertFrom( m() ) as Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.EventData ), InvocationInformation, this.ParameterSetName, __correlationId, __processRecordId, null );
                if (token.IsCancellationRequested)
                {
                    return ;
                }
                WriteDebug($"{id}: {(messageData().Message ?? global::System.String.Empty)}");
            }
        }

        /// <summary>
        /// Intializes a new instance of the <see cref="NewAzContainerServiceManagedCluster_CreateExpanded" /> cmdlet class.
        /// </summary>
        public NewAzContainerServiceManagedCluster_CreateExpanded()
        {

        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletProcessRecordStart).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
            __processRecordId = System.Guid.NewGuid().ToString();
            try
            {
                // work
                if (ShouldProcess($"Call remote 'ManagedClustersCreateOrUpdate' operation"))
                {
                    if (true == MyInvocation?.BoundParameters?.ContainsKey("AsJob"))
                    {
                        var instance = this.Clone();
                        var job = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.AsyncJob(instance, this.MyInvocation.Line, this.MyInvocation.MyCommand.Name, this._cancellationTokenSource.Token, this._cancellationTokenSource.Cancel);
                        JobRepository.Add(job);
                        var task = instance.ProcessRecordAsync();
                        job.Monitor(task);
                        WriteObject(job);
                    }
                    else
                    {
                        using( var asyncCommandRuntime = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.AsyncCommandRuntime(this, ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token) )
                        {
                            asyncCommandRuntime.Wait( ProcessRecordAsync(),((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token);
                        }
                    }
                }
            }
            catch (global::System.AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach( var innerException in aggregateException.Flatten().InnerExceptions )
                {
                    ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletException, $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // Write exception out to error channel.
                    WriteError( new global::System.Management.Automation.ErrorRecord(innerException,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
                }
            }
            catch (global::System.Exception exception) when ((exception as System.Management.Automation.PipelineStoppedException)== null || (exception as System.Management.Automation.PipelineStoppedException).InnerException != null)
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletException, $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                // Write exception out to error channel.
                WriteError( new global::System.Management.Automation.ErrorRecord(exception,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
            }
            finally
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }

        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async global::System.Threading.Tasks.Task ProcessRecordAsync()
        {
            using( NoSynchronizationContext )
            {
                await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletGetPipeline); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                Pipeline = Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.CreatePipeline(InvocationInformation, __correlationId, __processRecordId, this.ParameterSetName);
                if (null != HttpPipelinePrepend)
                {
                    Pipeline.Prepend((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ?? HttpPipelinePrepend);
                }
                if (null != HttpPipelineAppend)
                {
                    Pipeline.Append((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ?? HttpPipelineAppend);
                }
                // get the client instance
                try
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletBeforeAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    await this.Client.ManagedClustersCreateOrUpdate(SubscriptionId, ResourceGroupName, ResourceName, this.InvocationInformation.BoundParameters.ContainsKey("IfMatch") ? IfMatch : null, this.InvocationInformation.BoundParameters.ContainsKey("IfNoneMatch") ? IfNoneMatch : null, _parametersBody, onOk, onDefault, this, Pipeline);
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletAfterAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                }
                catch (Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.UndeclaredResponseException urexception)
                {
                    WriteError(new global::System.Management.Automation.ErrorRecord(urexception, urexception.StatusCode.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  SubscriptionId=SubscriptionId,ResourceGroupName=ResourceGroupName,ResourceName=ResourceName,IfMatch=this.InvocationInformation.BoundParameters.ContainsKey("IfMatch") ? IfMatch : null,IfNoneMatch=this.InvocationInformation.BoundParameters.ContainsKey("IfNoneMatch") ? IfNoneMatch : null,body=_parametersBody})
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(urexception.Message) { RecommendedAction = urexception.Action }
                    });
                }
                finally
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Cancel();
            base.StopProcessing();
        }

        /// <param name="sendToPipeline"></param>
        new protected void WriteObject(object sendToPipeline)
        {
            Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.SanitizeOutput?.Invoke(sendToPipeline, __correlationId);
            base.WriteObject(sendToPipeline);
        }

        /// <param name="sendToPipeline"></param>
        /// <param name="enumerateCollection"></param>
        new protected void WriteObject(object sendToPipeline, bool enumerateCollection)
        {
            Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.SanitizeOutput?.Invoke(sendToPipeline, __correlationId);
            base.WriteObject(sendToPipeline, enumerateCollection);
        }

        /// <summary>
        /// a delegate that is called when the remote service returns default (any response code not handled elsewhere).
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.ICloudError">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.ICloudError</see>
        /// from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.ICloudError> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnDefault(responseMessage, response, ref _returnNow);
                // if overrideOnDefault has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // Error Response : default
                var code = (await response)?.Code;
                var message = (await response)?.Message;
                if ((null == code || null == message))
                {
                    // Unrecognized Response. Create an error record based on what we have.
                    var ex = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.ICloudError>(responseMessage, await response);
                    WriteError( new global::System.Management.Automation.ErrorRecord(ex, ex.Code, global::System.Management.Automation.ErrorCategory.InvalidOperation, new { SubscriptionId=SubscriptionId, ResourceGroupName=ResourceGroupName, ResourceName=ResourceName, IfMatch=this.InvocationInformation.BoundParameters.ContainsKey("IfMatch") ? IfMatch : null, IfNoneMatch=this.InvocationInformation.BoundParameters.ContainsKey("IfNoneMatch") ? IfNoneMatch : null, body=_parametersBody })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(ex.Message) { RecommendedAction = ex.Action }
                    });
                }
                else
                {
                    WriteError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception($"[{code}] : {message}"), code?.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new { SubscriptionId=SubscriptionId, ResourceGroupName=ResourceGroupName, ResourceName=ResourceName, IfMatch=this.InvocationInformation.BoundParameters.ContainsKey("IfMatch") ? IfMatch : null, IfNoneMatch=this.InvocationInformation.BoundParameters.ContainsKey("IfNoneMatch") ? IfNoneMatch : null, body=_parametersBody })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(message) { RecommendedAction = global::System.String.Empty }
                    });
                }
            }
        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedCluster">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedCluster</see>
        /// from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedCluster> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnOk(responseMessage, response, ref _returnNow);
                // if overrideOnOk has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onOk - response for 200 / application/json
                // (await response) // should be Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20240902Preview.IManagedCluster
                WriteObject((await response));
            }
        }
    }
}
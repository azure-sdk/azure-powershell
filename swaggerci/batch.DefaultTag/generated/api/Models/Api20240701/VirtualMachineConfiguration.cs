// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Extensions;

    /// <summary>
    /// The configuration for compute nodes in a pool based on the Azure Virtual Machines infrastructure.
    /// </summary>
    public partial class VirtualMachineConfiguration :
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfiguration,
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal
    {

        /// <summary>Backing field for <see cref="ContainerConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerConfiguration _containerConfiguration;

        /// <summary>
        /// If specified, setup is performed on each node in the pool to allow tasks to run in containers. All regular tasks and job
        /// manager tasks run on this pool must specify the containerSettings property, and all other tasks may specify it.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerConfiguration ContainerConfiguration { get => (this._containerConfiguration = this._containerConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ContainerConfiguration()); set => this._containerConfiguration = value; }

        /// <summary>
        /// This is the full image reference, as would be specified to "docker pull". An image will be sourced from the default Docker
        /// registry unless the image is fully qualified with an alternative registry.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string[] ContainerConfigurationContainerImageName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerConfigurationInternal)ContainerConfiguration).ContainerImageName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerConfigurationInternal)ContainerConfiguration).ContainerImageName = value ?? null /* arrayOf */; }

        /// <summary>
        /// If any images must be downloaded from a private registry which requires credentials, then those credentials must be provided
        /// here.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerRegistry[] ContainerConfigurationContainerRegistry { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerConfigurationInternal)ContainerConfiguration).ContainerRegistry; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerConfigurationInternal)ContainerConfiguration).ContainerRegistry = value ?? null /* arrayOf */; }

        /// <summary>The container technology to be used.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ContainerType? ContainerConfigurationType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerConfigurationInternal)ContainerConfiguration).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerConfigurationInternal)ContainerConfiguration).Type = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ContainerType)""); }

        /// <summary>Backing field for <see cref="DataDisk" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDataDisk[] _dataDisk;

        /// <summary>
        /// This property must be specified if the compute nodes in the pool need to have empty data disks attached to them.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDataDisk[] DataDisk { get => this._dataDisk; set => this._dataDisk = value; }

        /// <summary>Backing field for <see cref="DiskEncryptionConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDiskEncryptionConfiguration _diskEncryptionConfiguration;

        /// <summary>
        /// If specified, encryption is performed on each node in the pool during node provisioning.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDiskEncryptionConfiguration DiskEncryptionConfiguration { get => (this._diskEncryptionConfiguration = this._diskEncryptionConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.DiskEncryptionConfiguration()); set => this._diskEncryptionConfiguration = value; }

        /// <summary>
        /// On Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and "TemporaryDisk" must be specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.DiskEncryptionTarget[] DiskEncryptionConfigurationTarget { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDiskEncryptionConfigurationInternal)DiskEncryptionConfiguration).Target; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDiskEncryptionConfigurationInternal)DiskEncryptionConfiguration).Target = value ?? null /* arrayOf */; }

        /// <summary>
        /// This property can be used by user in the request to choose which location the operating system should be in. e.g., cache
        /// disk space for Ephemeral OS disk provisioning. For more information on Ephemeral OS disk size requirements, please refer
        /// to Ephemeral OS disk size requirements for Windows VMs at https://learn.microsoft.com/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements
        /// and Linux VMs at https://learn.microsoft.com/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.DiffDiskPlacement? EphemeralOSDiskSettingPlacement { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).EphemeralOSDiskSettingPlacement; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).EphemeralOSDiskSettingPlacement = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.DiffDiskPlacement)""); }

        /// <summary>Backing field for <see cref="Extension" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVMExtension[] _extension;

        /// <summary>
        /// If specified, the extensions mentioned in this configuration will be installed on each node.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVMExtension[] Extension { get => this._extension; set => this._extension = value; }

        /// <summary>Backing field for <see cref="ImageReference" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReference _imageReference;

        /// <summary>
        /// A reference to an Azure Virtual Machines Marketplace image or the Azure Image resource of a custom Virtual Machine. To
        /// get the list of all imageReferences verified by Azure Batch, see the 'List supported node agent SKUs' operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReference ImageReference { get => (this._imageReference = this._imageReference ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ImageReference()); set => this._imageReference = value; }

        /// <summary>
        /// This property is mutually exclusive with other properties and can be fetched from community gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceCommunityGalleryImageId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).CommunityGalleryImageId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).CommunityGalleryImageId = value ?? null; }

        /// <summary>
        /// This property is mutually exclusive with other properties. The Azure Compute Gallery Image must have replicas in the same
        /// region as the Azure Batch account. For information about the firewall settings for the Batch node agent to communicate
        /// with the Batch service see https://learn.microsoft.com/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).Id = value ?? null; }

        /// <summary>For example, UbuntuServer or WindowsServer.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceOffer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).Offer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).Offer = value ?? null; }

        /// <summary>For example, Canonical or MicrosoftWindowsServer.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferencePublisher { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).Publisher; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).Publisher = value ?? null; }

        /// <summary>
        /// This property is mutually exclusive with other properties and can be fetched from shared gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceSharedGalleryImageId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).SharedGalleryImageId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).SharedGalleryImageId = value ?? null; }

        /// <summary>For example, 18.04-LTS or 2022-datacenter.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceSku { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).Sku; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).Sku = value ?? null; }

        /// <summary>
        /// A value of 'latest' can be specified to select the latest version of an image. If omitted, the default is 'latest'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).Version; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReferenceInternal)ImageReference).Version = value ?? null; }

        /// <summary>Backing field for <see cref="LicenseType" /> property.</summary>
        private string _licenseType;

        /// <summary>
        /// This only applies to images that contain the Windows operating system, and should only be used when you hold valid on-premises
        /// licenses for the nodes which will be deployed. If omitted, no on-premises licensing discount is applied. Values are:
        /// Windows_Server - The on-premises license is for Windows Server.
        /// Windows_Client - The on-premises license is for Windows Client.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string LicenseType { get => this._licenseType; set => this._licenseType = value; }

        /// <summary>The storage account type for use in creating data disks or OS disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.StorageAccountType? ManagedDiskStorageAccountType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).ManagedDiskStorageAccountType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).ManagedDiskStorageAccountType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.StorageAccountType)""); }

        /// <summary>Internal Acessors for ContainerConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerConfiguration Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.ContainerConfiguration { get => (this._containerConfiguration = this._containerConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ContainerConfiguration()); set { {_containerConfiguration = value;} } }

        /// <summary>Internal Acessors for DiskEncryptionConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDiskEncryptionConfiguration Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.DiskEncryptionConfiguration { get => (this._diskEncryptionConfiguration = this._diskEncryptionConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.DiskEncryptionConfiguration()); set { {_diskEncryptionConfiguration = value;} } }

        /// <summary>Internal Acessors for ImageReference</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReference Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.ImageReference { get => (this._imageReference = this._imageReference ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ImageReference()); set { {_imageReference = value;} } }

        /// <summary>Internal Acessors for ManagedDiskSecurityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVMDiskSecurityProfile Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.ManagedDiskSecurityProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).ManagedDiskSecurityProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).ManagedDiskSecurityProfile = value; }

        /// <summary>Internal Acessors for NodePlacementConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.INodePlacementConfiguration Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.NodePlacementConfiguration { get => (this._nodePlacementConfiguration = this._nodePlacementConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.NodePlacementConfiguration()); set { {_nodePlacementConfiguration = value;} } }

        /// <summary>Internal Acessors for OSDisk</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDisk Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.OSDisk { get => (this._oSDisk = this._oSDisk ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.OSDisk()); set { {_oSDisk = value;} } }

        /// <summary>Internal Acessors for OSDiskEphemeralOsdiskSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDiffDiskSettings Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.OSDiskEphemeralOsdiskSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).EphemeralOSDiskSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).EphemeralOSDiskSetting = value; }

        /// <summary>Internal Acessors for OSDiskManagedDisk</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IManagedDisk Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.OSDiskManagedDisk { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).ManagedDisk; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).ManagedDisk = value; }

        /// <summary>Internal Acessors for SecurityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfile Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.SecurityProfile { get => (this._securityProfile = this._securityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.SecurityProfile()); set { {_securityProfile = value;} } }

        /// <summary>Internal Acessors for SecurityProfileUefiSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IUefiSettings Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.SecurityProfileUefiSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfileInternal)SecurityProfile).UefiSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfileInternal)SecurityProfile).UefiSetting = value; }

        /// <summary>Internal Acessors for ServiceArtifactReference</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IServiceArtifactReference Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.ServiceArtifactReference { get => (this._serviceArtifactReference = this._serviceArtifactReference ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ServiceArtifactReference()); set { {_serviceArtifactReference = value;} } }

        /// <summary>Internal Acessors for WindowsConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IWindowsConfiguration Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVirtualMachineConfigurationInternal.WindowsConfiguration { get => (this._windowsConfiguration = this._windowsConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.WindowsConfiguration()); set { {_windowsConfiguration = value;} } }

        /// <summary>Backing field for <see cref="NodeAgentSkuId" /> property.</summary>
        private string _nodeAgentSkuId;

        /// <summary>
        /// The Batch node agent is a program that runs on each node in the pool, and provides the command-and-control interface between
        /// the node and the Batch service. There are different implementations of the node agent, known as SKUs, for different operating
        /// systems. You must specify a node agent SKU which matches the selected image reference. To get the list of supported node
        /// agent SKUs along with their list of verified image references, see the 'List supported node agent SKUs' operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string NodeAgentSkuId { get => this._nodeAgentSkuId; set => this._nodeAgentSkuId = value; }

        /// <summary>Backing field for <see cref="NodePlacementConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.INodePlacementConfiguration _nodePlacementConfiguration;

        /// <summary>
        /// This configuration will specify rules on how nodes in the pool will be physically allocated.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.INodePlacementConfiguration NodePlacementConfiguration { get => (this._nodePlacementConfiguration = this._nodePlacementConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.NodePlacementConfiguration()); set => this._nodePlacementConfiguration = value; }

        /// <summary>
        /// Allocation policy used by Batch Service to provision the nodes. If not specified, Batch will use the regional policy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.NodePlacementPolicyType? NodePlacementConfigurationPolicy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.INodePlacementConfigurationInternal)NodePlacementConfiguration).Policy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.INodePlacementConfigurationInternal)NodePlacementConfiguration).Policy = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.NodePlacementPolicyType)""); }

        /// <summary>Backing field for <see cref="OSDisk" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDisk _oSDisk;

        /// <summary>Contains configuration for ephemeral OSDisk settings.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDisk OSDisk { get => (this._oSDisk = this._oSDisk ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.OSDisk()); set => this._oSDisk = value; }

        /// <summary>The type of caching to enable for the disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.CachingType? OSDiskCaching { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).Caching; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).Caching = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.CachingType)""); }

        /// <summary>The initial disk size in GB when creating new OS disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public int? OSDiskSizeGb { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).DiskSizeGb; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).DiskSizeGb = value ?? default(int); }

        /// <summary>Specifies whether writeAccelerator should be enabled or disabled on the disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? OSDiskWriteAcceleratorEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).WriteAcceleratorEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).WriteAcceleratorEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="SecurityProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfile _securityProfile;

        /// <summary>
        /// Specifies the security profile settings for the virtual machine or virtual machine scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfile SecurityProfile { get => (this._securityProfile = this._securityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.SecurityProfile()); set => this._securityProfile = value; }

        /// <summary>
        /// This property can be used by user in the request to enable or disable the Host Encryption for the virtual machine or virtual
        /// machine scale set. This will enable the encryption for all the disks including Resource/Temp disk at host itself.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? SecurityProfileEncryptionAtHost { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfileInternal)SecurityProfile).EncryptionAtHost; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfileInternal)SecurityProfile).EncryptionAtHost = value ?? default(bool); }

        /// <summary>
        /// Specifies the EncryptionType of the managed disk. It is set to VMGuestStateOnly for encryption of just the VMGuestState
        /// blob, and NonPersistedTPM for not persisting firmware state in the VMGuestState blob. **Note**: It can be set for only
        /// Confidential VMs and required when using Confidential VMs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.SecurityEncryptionTypes? SecurityProfileSecurityEncryptionType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).SecurityProfileSecurityEncryptionType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDiskInternal)OSDisk).SecurityProfileSecurityEncryptionType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.SecurityEncryptionTypes)""); }

        /// <summary>
        /// Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable UefiSettings.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.SecurityTypes? SecurityProfileSecurityType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfileInternal)SecurityProfile).SecurityType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfileInternal)SecurityProfile).SecurityType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.SecurityTypes)""); }

        /// <summary>Backing field for <see cref="ServiceArtifactReference" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IServiceArtifactReference _serviceArtifactReference;

        /// <summary>
        /// The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IServiceArtifactReference ServiceArtifactReference { get => (this._serviceArtifactReference = this._serviceArtifactReference ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ServiceArtifactReference()); set => this._serviceArtifactReference = value; }

        /// <summary>
        /// The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ServiceArtifactReferenceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IServiceArtifactReferenceInternal)ServiceArtifactReference).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IServiceArtifactReferenceInternal)ServiceArtifactReference).Id = value ?? null; }

        /// <summary>Specifies whether secure boot should be enabled on the virtual machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? UefiSettingSecureBootEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfileInternal)SecurityProfile).UefiSettingSecureBootEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfileInternal)SecurityProfile).UefiSettingSecureBootEnabled = value ?? default(bool); }

        /// <summary>Specifies whether vTPM should be enabled on the virtual machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? UefiSettingVTpmEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfileInternal)SecurityProfile).UefiSettingVTpmEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfileInternal)SecurityProfile).UefiSettingVTpmEnabled = value ?? default(bool); }

        /// <summary>If omitted, the default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? WindowConfigurationEnableAutomaticUpdate { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IWindowsConfigurationInternal)WindowsConfiguration).EnableAutomaticUpdate; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IWindowsConfigurationInternal)WindowsConfiguration).EnableAutomaticUpdate = value ?? default(bool); }

        /// <summary>Backing field for <see cref="WindowsConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IWindowsConfiguration _windowsConfiguration;

        /// <summary>
        /// This property must not be specified if the imageReference specifies a Linux OS image.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IWindowsConfiguration WindowsConfiguration { get => (this._windowsConfiguration = this._windowsConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.WindowsConfiguration()); set => this._windowsConfiguration = value; }

        /// <summary>Creates an new <see cref="VirtualMachineConfiguration" /> instance.</summary>
        public VirtualMachineConfiguration()
        {

        }
    }
    /// The configuration for compute nodes in a pool based on the Azure Virtual Machines infrastructure.
    public partial interface IVirtualMachineConfiguration :
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IJsonSerializable
    {
        /// <summary>
        /// This is the full image reference, as would be specified to "docker pull". An image will be sourced from the default Docker
        /// registry unless the image is fully qualified with an alternative registry.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is the full image reference, as would be specified to ""docker pull"". An image will be sourced from the default Docker registry unless the image is fully qualified with an alternative registry.",
        SerializedName = @"containerImageNames",
        PossibleTypes = new [] { typeof(string) })]
        string[] ContainerConfigurationContainerImageName { get; set; }
        /// <summary>
        /// If any images must be downloaded from a private registry which requires credentials, then those credentials must be provided
        /// here.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If any images must be downloaded from a private registry which requires credentials, then those credentials must be provided here.",
        SerializedName = @"containerRegistries",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerRegistry) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerRegistry[] ContainerConfigurationContainerRegistry { get; set; }
        /// <summary>The container technology to be used.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The container technology to be used.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ContainerType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ContainerType? ContainerConfigurationType { get; set; }
        /// <summary>
        /// This property must be specified if the compute nodes in the pool need to have empty data disks attached to them.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This property must be specified if the compute nodes in the pool need to have empty data disks attached to them.",
        SerializedName = @"dataDisks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDataDisk) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDataDisk[] DataDisk { get; set; }
        /// <summary>
        /// On Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and "TemporaryDisk" must be specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"On Linux pool, only ""TemporaryDisk"" is supported; on Windows pool, ""OsDisk"" and ""TemporaryDisk"" must be specified.",
        SerializedName = @"targets",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.DiskEncryptionTarget) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.DiskEncryptionTarget[] DiskEncryptionConfigurationTarget { get; set; }
        /// <summary>
        /// This property can be used by user in the request to choose which location the operating system should be in. e.g., cache
        /// disk space for Ephemeral OS disk provisioning. For more information on Ephemeral OS disk size requirements, please refer
        /// to Ephemeral OS disk size requirements for Windows VMs at https://learn.microsoft.com/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements
        /// and Linux VMs at https://learn.microsoft.com/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This property can be used by user in the request to choose which location the operating system should be in. e.g., cache disk space for Ephemeral OS disk provisioning. For more information on Ephemeral OS disk size requirements, please refer to Ephemeral OS disk size requirements for Windows VMs at https://learn.microsoft.com/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements and Linux VMs at https://learn.microsoft.com/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.",
        SerializedName = @"placement",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.DiffDiskPlacement) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.DiffDiskPlacement? EphemeralOSDiskSettingPlacement { get; set; }
        /// <summary>
        /// If specified, the extensions mentioned in this configuration will be installed on each node.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If specified, the extensions mentioned in this configuration will be installed on each node.",
        SerializedName = @"extensions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVMExtension) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVMExtension[] Extension { get; set; }
        /// <summary>
        /// This property is mutually exclusive with other properties and can be fetched from community gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This property is mutually exclusive with other properties and can be fetched from community gallery image GET call.",
        SerializedName = @"communityGalleryImageId",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceCommunityGalleryImageId { get; set; }
        /// <summary>
        /// This property is mutually exclusive with other properties. The Azure Compute Gallery Image must have replicas in the same
        /// region as the Azure Batch account. For information about the firewall settings for the Batch node agent to communicate
        /// with the Batch service see https://learn.microsoft.com/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This property is mutually exclusive with other properties. The Azure Compute Gallery Image must have replicas in the same region as the Azure Batch account. For information about the firewall settings for the Batch node agent to communicate with the Batch service see https://learn.microsoft.com/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceId { get; set; }
        /// <summary>For example, UbuntuServer or WindowsServer.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For example, UbuntuServer or WindowsServer.",
        SerializedName = @"offer",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceOffer { get; set; }
        /// <summary>For example, Canonical or MicrosoftWindowsServer.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For example, Canonical or MicrosoftWindowsServer.",
        SerializedName = @"publisher",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferencePublisher { get; set; }
        /// <summary>
        /// This property is mutually exclusive with other properties and can be fetched from shared gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This property is mutually exclusive with other properties and can be fetched from shared gallery image GET call.",
        SerializedName = @"sharedGalleryImageId",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceSharedGalleryImageId { get; set; }
        /// <summary>For example, 18.04-LTS or 2022-datacenter.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For example, 18.04-LTS or 2022-datacenter.",
        SerializedName = @"sku",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceSku { get; set; }
        /// <summary>
        /// A value of 'latest' can be specified to select the latest version of an image. If omitted, the default is 'latest'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A value of 'latest' can be specified to select the latest version of an image. If omitted, the default is 'latest'.",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceVersion { get; set; }
        /// <summary>
        /// This only applies to images that contain the Windows operating system, and should only be used when you hold valid on-premises
        /// licenses for the nodes which will be deployed. If omitted, no on-premises licensing discount is applied. Values are:
        /// Windows_Server - The on-premises license is for Windows Server.
        /// Windows_Client - The on-premises license is for Windows Client.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This only applies to images that contain the Windows operating system, and should only be used when you hold valid on-premises licenses for the nodes which will be deployed. If omitted, no on-premises licensing discount is applied. Values are:

         Windows_Server - The on-premises license is for Windows Server.
         Windows_Client - The on-premises license is for Windows Client.
        ",
        SerializedName = @"licenseType",
        PossibleTypes = new [] { typeof(string) })]
        string LicenseType { get; set; }
        /// <summary>The storage account type for use in creating data disks or OS disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The storage account type for use in creating data disks or OS disk.",
        SerializedName = @"storageAccountType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.StorageAccountType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.StorageAccountType? ManagedDiskStorageAccountType { get; set; }
        /// <summary>
        /// The Batch node agent is a program that runs on each node in the pool, and provides the command-and-control interface between
        /// the node and the Batch service. There are different implementations of the node agent, known as SKUs, for different operating
        /// systems. You must specify a node agent SKU which matches the selected image reference. To get the list of supported node
        /// agent SKUs along with their list of verified image references, see the 'List supported node agent SKUs' operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The Batch node agent is a program that runs on each node in the pool, and provides the command-and-control interface between the node and the Batch service. There are different implementations of the node agent, known as SKUs, for different operating systems. You must specify a node agent SKU which matches the selected image reference. To get the list of supported node agent SKUs along with their list of verified image references, see the 'List supported node agent SKUs' operation.",
        SerializedName = @"nodeAgentSkuId",
        PossibleTypes = new [] { typeof(string) })]
        string NodeAgentSkuId { get; set; }
        /// <summary>
        /// Allocation policy used by Batch Service to provision the nodes. If not specified, Batch will use the regional policy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allocation policy used by Batch Service to provision the nodes. If not specified, Batch will use the regional policy.",
        SerializedName = @"policy",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.NodePlacementPolicyType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.NodePlacementPolicyType? NodePlacementConfigurationPolicy { get; set; }
        /// <summary>The type of caching to enable for the disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of caching to enable for the disk.",
        SerializedName = @"caching",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.CachingType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.CachingType? OSDiskCaching { get; set; }
        /// <summary>The initial disk size in GB when creating new OS disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The initial disk size in GB when creating new OS disk.",
        SerializedName = @"diskSizeGB",
        PossibleTypes = new [] { typeof(int) })]
        int? OSDiskSizeGb { get; set; }
        /// <summary>Specifies whether writeAccelerator should be enabled or disabled on the disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether writeAccelerator should be enabled or disabled on the disk.",
        SerializedName = @"writeAcceleratorEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OSDiskWriteAcceleratorEnabled { get; set; }
        /// <summary>
        /// This property can be used by user in the request to enable or disable the Host Encryption for the virtual machine or virtual
        /// machine scale set. This will enable the encryption for all the disks including Resource/Temp disk at host itself.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This property can be used by user in the request to enable or disable the Host Encryption for the virtual machine or virtual machine scale set. This will enable the encryption for all the disks including Resource/Temp disk at host itself.",
        SerializedName = @"encryptionAtHost",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityProfileEncryptionAtHost { get; set; }
        /// <summary>
        /// Specifies the EncryptionType of the managed disk. It is set to VMGuestStateOnly for encryption of just the VMGuestState
        /// blob, and NonPersistedTPM for not persisting firmware state in the VMGuestState blob. **Note**: It can be set for only
        /// Confidential VMs and required when using Confidential VMs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the EncryptionType of the managed disk. It is set to VMGuestStateOnly for encryption of just the VMGuestState blob, and NonPersistedTPM for not persisting firmware state in the VMGuestState blob. **Note**: It can be set for only Confidential VMs and required when using Confidential VMs.",
        SerializedName = @"securityEncryptionType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.SecurityEncryptionTypes) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.SecurityEncryptionTypes? SecurityProfileSecurityEncryptionType { get; set; }
        /// <summary>
        /// Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable UefiSettings.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable UefiSettings.",
        SerializedName = @"securityType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.SecurityTypes) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.SecurityTypes? SecurityProfileSecurityType { get; set; }
        /// <summary>
        /// The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string ServiceArtifactReferenceId { get; set; }
        /// <summary>Specifies whether secure boot should be enabled on the virtual machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether secure boot should be enabled on the virtual machine.",
        SerializedName = @"secureBootEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? UefiSettingSecureBootEnabled { get; set; }
        /// <summary>Specifies whether vTPM should be enabled on the virtual machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether vTPM should be enabled on the virtual machine.",
        SerializedName = @"vTpmEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? UefiSettingVTpmEnabled { get; set; }
        /// <summary>If omitted, the default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If omitted, the default value is true.",
        SerializedName = @"enableAutomaticUpdates",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WindowConfigurationEnableAutomaticUpdate { get; set; }

    }
    /// The configuration for compute nodes in a pool based on the Azure Virtual Machines infrastructure.
    internal partial interface IVirtualMachineConfigurationInternal

    {
        /// <summary>
        /// If specified, setup is performed on each node in the pool to allow tasks to run in containers. All regular tasks and job
        /// manager tasks run on this pool must specify the containerSettings property, and all other tasks may specify it.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerConfiguration ContainerConfiguration { get; set; }
        /// <summary>
        /// This is the full image reference, as would be specified to "docker pull". An image will be sourced from the default Docker
        /// registry unless the image is fully qualified with an alternative registry.
        /// </summary>
        string[] ContainerConfigurationContainerImageName { get; set; }
        /// <summary>
        /// If any images must be downloaded from a private registry which requires credentials, then those credentials must be provided
        /// here.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IContainerRegistry[] ContainerConfigurationContainerRegistry { get; set; }
        /// <summary>The container technology to be used.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ContainerType? ContainerConfigurationType { get; set; }
        /// <summary>
        /// This property must be specified if the compute nodes in the pool need to have empty data disks attached to them.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDataDisk[] DataDisk { get; set; }
        /// <summary>
        /// If specified, encryption is performed on each node in the pool during node provisioning.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDiskEncryptionConfiguration DiskEncryptionConfiguration { get; set; }
        /// <summary>
        /// On Linux pool, only "TemporaryDisk" is supported; on Windows pool, "OsDisk" and "TemporaryDisk" must be specified.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.DiskEncryptionTarget[] DiskEncryptionConfigurationTarget { get; set; }
        /// <summary>
        /// This property can be used by user in the request to choose which location the operating system should be in. e.g., cache
        /// disk space for Ephemeral OS disk provisioning. For more information on Ephemeral OS disk size requirements, please refer
        /// to Ephemeral OS disk size requirements for Windows VMs at https://learn.microsoft.com/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements
        /// and Linux VMs at https://learn.microsoft.com/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.DiffDiskPlacement? EphemeralOSDiskSettingPlacement { get; set; }
        /// <summary>
        /// If specified, the extensions mentioned in this configuration will be installed on each node.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVMExtension[] Extension { get; set; }
        /// <summary>
        /// A reference to an Azure Virtual Machines Marketplace image or the Azure Image resource of a custom Virtual Machine. To
        /// get the list of all imageReferences verified by Azure Batch, see the 'List supported node agent SKUs' operation.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IImageReference ImageReference { get; set; }
        /// <summary>
        /// This property is mutually exclusive with other properties and can be fetched from community gallery image GET call.
        /// </summary>
        string ImageReferenceCommunityGalleryImageId { get; set; }
        /// <summary>
        /// This property is mutually exclusive with other properties. The Azure Compute Gallery Image must have replicas in the same
        /// region as the Azure Batch account. For information about the firewall settings for the Batch node agent to communicate
        /// with the Batch service see https://learn.microsoft.com/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
        /// </summary>
        string ImageReferenceId { get; set; }
        /// <summary>For example, UbuntuServer or WindowsServer.</summary>
        string ImageReferenceOffer { get; set; }
        /// <summary>For example, Canonical or MicrosoftWindowsServer.</summary>
        string ImageReferencePublisher { get; set; }
        /// <summary>
        /// This property is mutually exclusive with other properties and can be fetched from shared gallery image GET call.
        /// </summary>
        string ImageReferenceSharedGalleryImageId { get; set; }
        /// <summary>For example, 18.04-LTS or 2022-datacenter.</summary>
        string ImageReferenceSku { get; set; }
        /// <summary>
        /// A value of 'latest' can be specified to select the latest version of an image. If omitted, the default is 'latest'.
        /// </summary>
        string ImageReferenceVersion { get; set; }
        /// <summary>
        /// This only applies to images that contain the Windows operating system, and should only be used when you hold valid on-premises
        /// licenses for the nodes which will be deployed. If omitted, no on-premises licensing discount is applied. Values are:
        /// Windows_Server - The on-premises license is for Windows Server.
        /// Windows_Client - The on-premises license is for Windows Client.
        /// </summary>
        string LicenseType { get; set; }
        /// <summary>
        /// Specifies the security profile settings for the managed disk. **Note**: It can only be set for Confidential VMs and is
        /// required when using Confidential VMs.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IVMDiskSecurityProfile ManagedDiskSecurityProfile { get; set; }
        /// <summary>The storage account type for use in creating data disks or OS disk.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.StorageAccountType? ManagedDiskStorageAccountType { get; set; }
        /// <summary>
        /// The Batch node agent is a program that runs on each node in the pool, and provides the command-and-control interface between
        /// the node and the Batch service. There are different implementations of the node agent, known as SKUs, for different operating
        /// systems. You must specify a node agent SKU which matches the selected image reference. To get the list of supported node
        /// agent SKUs along with their list of verified image references, see the 'List supported node agent SKUs' operation.
        /// </summary>
        string NodeAgentSkuId { get; set; }
        /// <summary>
        /// This configuration will specify rules on how nodes in the pool will be physically allocated.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.INodePlacementConfiguration NodePlacementConfiguration { get; set; }
        /// <summary>
        /// Allocation policy used by Batch Service to provision the nodes. If not specified, Batch will use the regional policy.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.NodePlacementPolicyType? NodePlacementConfigurationPolicy { get; set; }
        /// <summary>Contains configuration for ephemeral OSDisk settings.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IOSDisk OSDisk { get; set; }
        /// <summary>The type of caching to enable for the disk.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.CachingType? OSDiskCaching { get; set; }
        /// <summary>
        /// Specifies the ephemeral Disk Settings for the operating system disk used by the virtual machine.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IDiffDiskSettings OSDiskEphemeralOsdiskSetting { get; set; }

        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IManagedDisk OSDiskManagedDisk { get; set; }
        /// <summary>The initial disk size in GB when creating new OS disk.</summary>
        int? OSDiskSizeGb { get; set; }
        /// <summary>Specifies whether writeAccelerator should be enabled or disabled on the disk.</summary>
        bool? OSDiskWriteAcceleratorEnabled { get; set; }
        /// <summary>
        /// Specifies the security profile settings for the virtual machine or virtual machine scale set.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.ISecurityProfile SecurityProfile { get; set; }
        /// <summary>
        /// This property can be used by user in the request to enable or disable the Host Encryption for the virtual machine or virtual
        /// machine scale set. This will enable the encryption for all the disks including Resource/Temp disk at host itself.
        /// </summary>
        bool? SecurityProfileEncryptionAtHost { get; set; }
        /// <summary>
        /// Specifies the EncryptionType of the managed disk. It is set to VMGuestStateOnly for encryption of just the VMGuestState
        /// blob, and NonPersistedTPM for not persisting firmware state in the VMGuestState blob. **Note**: It can be set for only
        /// Confidential VMs and required when using Confidential VMs.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.SecurityEncryptionTypes? SecurityProfileSecurityEncryptionType { get; set; }
        /// <summary>
        /// Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable UefiSettings.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.SecurityTypes? SecurityProfileSecurityType { get; set; }
        /// <summary>
        /// Specifies the security settings like secure boot and vTPM used while creating the virtual machine.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IUefiSettings SecurityProfileUefiSetting { get; set; }
        /// <summary>
        /// The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IServiceArtifactReference ServiceArtifactReference { get; set; }
        /// <summary>
        /// The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        string ServiceArtifactReferenceId { get; set; }
        /// <summary>Specifies whether secure boot should be enabled on the virtual machine.</summary>
        bool? UefiSettingSecureBootEnabled { get; set; }
        /// <summary>Specifies whether vTPM should be enabled on the virtual machine.</summary>
        bool? UefiSettingVTpmEnabled { get; set; }
        /// <summary>If omitted, the default value is true.</summary>
        bool? WindowConfigurationEnableAutomaticUpdate { get; set; }
        /// <summary>
        /// This property must not be specified if the imageReference specifies a Linux OS image.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api20240701.IWindowsConfiguration WindowsConfiguration { get; set; }

    }
}
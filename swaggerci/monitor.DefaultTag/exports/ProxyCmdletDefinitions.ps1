
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Returns the specific pipeline group instance.
.Description
Returns the specific pipeline group instance.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.IMonitorPipelinesIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IPipelineGroup
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IMonitorPipelinesIdentity>: Identity Parameter
  [Id <String>]: Resource identity path
  [PipelineGroupName <String>]: The name of pipeline group. The name is case insensitive.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
.Link
https://learn.microsoft.com/powershell/module/az.monitorpipelines/get-azmonitorpipelinespipelinegroup
#>
function Get-AzMonitorPipelinesPipelineGroup {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IPipelineGroup])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('PipelineGroupName')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [System.String]
    # The name of pipeline group.
    # The name is case insensitive.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Parameter(ParameterSetName='List1')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.IMonitorPipelinesIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.MonitorPipelines.private\Get-AzMonitorPipelinesPipelineGroup_Get';
            GetViaIdentity = 'Az.MonitorPipelines.private\Get-AzMonitorPipelinesPipelineGroup_GetViaIdentity';
            List = 'Az.MonitorPipelines.private\Get-AzMonitorPipelinesPipelineGroup_List';
            List1 = 'Az.MonitorPipelines.private\Get-AzMonitorPipelinesPipelineGroup_List1';
        }
        if (('Get', 'List', 'List1') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId')) {
            $testPlayback = $false
            $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create or update a pipeline group instance.
.Description
Create or update a pipeline group instance.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IPipelineGroup
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

EXPORTER <IExporter[]>: The exporters specified for a pipeline group instance.
  Name <String>: The name of exporter.
  Type <ExporterType>: The type of exporter.
  [ApiDataCollectionEndpointUrl <String>]: Data collection endpoint ingestion url.
  [ApiDataCollectionRule <String>]: Data Collection Rule (DCR) immutable id.
  [ApiStream <String>]: Stream name in destination. Azure Monitor stream is related to the destination table.
  [CacheMaxStorageUsage <Int32?>]: Max storage usage in megabytes.
  [CacheRetentionPeriod <Int32?>]: Retention period in minutes.
  [ConcurrencyBatchQueueSize <Int32?>]: Size of the queue for log batches.
  [ConcurrencyWorkerCount <Int32?>]: Number of parallel workers processing the log queues.
  [SchemaRecordMap <IRecordMap[]>]: Record Map.
    From <String>: Record Map Key.
    To <String>: Record Map Value.
  [SchemaResourceMap <IResourceMap[]>]: Resource Map captures information about the entity for which telemetry is recorded. For example, metrics exposed by a Kubernetes container can be linked to a resource that specifies the cluster, namespace, pod, and container name.Resource may capture an entire hierarchy of entity identification. It may describe the host in the cloud and specific container or an application running in the process.
    From <String>: Resource Map Key.
    To <String>: Resource Map Value.
  [SchemaScopeMap <IScopeMap[]>]: A scope map is a logical unit of the application code with which the emitted telemetry can be associated.
    From <String>: Scope Map Key.
    To <String>: Scope Map Value.
  [TcpUrl <String>]: TCP url to export.

NETWORKINGCONFIGURATION <INetworkingConfiguration[]>: Networking configurations for the pipeline group instance.
  Route <INetworkingRoute[]>: Networking routes configuration.
    Receiver <String>: The name of the previously defined receiver.
    [Path <String>]: Route path.
    [Port <Int32?>]: The port that will be configured externally. If not specified, it will use the port from the receiver definition.
    [Subdomain <String>]: Route subdomain.
  [Host <String>]: The address exposed on the cluster. Example: azuremonitorpipeline.contoso.com.

PROCESSOR <IProcessor[]>: The processors specified for a pipeline group instance.
  Name <String>: The name of processor.
  [BatchSize <Int32?>]: Size of the batch.
  [BatchTimeout <Int32?>]: Timeout in milliseconds.

RECEIVER <IReceiver[]>: The receivers specified for a pipeline group instance.
  Name <String>: The name of receiver.
  Type <ReceiverType>: The type of receiver.
  [DestinationFieldDestination <JsonMapperElement?>]: Define the destination's element. The element is the body or the attributes of the message, to which the json array mapper will write the output map.
  [DestinationFieldName <String>]: Define a destination field name under the given element. Leaving this empty, means the root of the element. In case element=attributes and fieldName is empty, the object's attributes themselves will contain the key value output pairs.
  [JsonArrayMapperKey <String[]>]: Define the names of the keys in the resulting map. The input json array elements are mapped in order, one for every key.
  [OtlpEndpoint <String>]: OTLP GRPC endpoint definition. Example: 0.0.0.0:<port>.
  [SourceFieldName <String>]: Define a source field name from which the json array mapper will read the json array. Leaving this empty, means reading the body of the message itself.
  [SyslogEndpoint <String>]: Syslog receiver endpoint definition. Example: 0.0.0.0:<port>.
  [SyslogProtocol <SyslogProtocol?>]: Protocol to parse syslog messages. Default rfc3164
  [UdpEncoding <StreamEncodingType?>]: The encoding of the stream being received.
  [UdpEndpoint <String>]: TCP endpoint definition. Example: 0.0.0.0:<port>.
  [UdpReadQueueLength <Int32?>]: Max read queue length.

SERVICEPIPELINE <IPipeline[]>: Pipelines belonging to a given pipeline group.
  Exporter <String[]>: Reference to exporters configured for the pipeline.
  Name <String>: Name of the pipeline.
  Receiver <String[]>: Reference to receivers configured for the pipeline.
  [Processor <String[]>]: Reference to processors configured for the pipeline.
.Link
https://learn.microsoft.com/powershell/module/az.monitorpipelines/new-azmonitorpipelinespipelinegroup
#>
function New-AzMonitorPipelinesPipelineGroup {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IPipelineGroup])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('PipelineGroupName')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [System.String]
    # The name of pipeline group.
    # The name is case insensitive.
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IExporter[]]
    # The exporters specified for a pipeline group instance.
    # To construct, see NOTES section for EXPORTER properties and create a hash table.
    ${Exporter},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [System.String]
    # The name of the extended location.
    ${ExtendedLocationName},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Support.ExtendedLocationType])]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Support.ExtendedLocationType]
    # The type of the extended location.
    ${ExtendedLocationType},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.INetworkingConfiguration[]]
    # Networking configurations for the pipeline group instance.
    # To construct, see NOTES section for NETWORKINGCONFIGURATION properties and create a hash table.
    ${NetworkingConfiguration},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [System.String]
    # The name of the mounted persistent volume.
    ${PersistencePersistentVolumeName},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IProcessor[]]
    # The processors specified for a pipeline group instance.
    # To construct, see NOTES section for PROCESSOR properties and create a hash table.
    ${Processor},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IReceiver[]]
    # The receivers specified for a pipeline group instance.
    # To construct, see NOTES section for RECEIVER properties and create a hash table.
    ${Receiver},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [System.Int32]
    # Defines the amount of replicas of the pipeline group instance.
    ${Replica},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IPipeline[]]
    # Pipelines belonging to a given pipeline group.
    # To construct, see NOTES section for SERVICEPIPELINE properties and create a hash table.
    ${ServicePipeline},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api50.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.MonitorPipelines.private\New-AzMonitorPipelinesPipelineGroup_CreateExpanded';
        }
        if (('CreateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId')) {
            $testPlayback = $false
            $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a pipeline group instance.
.Description
Delete a pipeline group instance.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.IMonitorPipelinesIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IMonitorPipelinesIdentity>: Identity Parameter
  [Id <String>]: Resource identity path
  [PipelineGroupName <String>]: The name of pipeline group. The name is case insensitive.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
.Link
https://learn.microsoft.com/powershell/module/az.monitorpipelines/remove-azmonitorpipelinespipelinegroup
#>
function Remove-AzMonitorPipelinesPipelineGroup {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Alias('PipelineGroupName')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [System.String]
    # The name of pipeline group.
    # The name is case insensitive.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.IMonitorPipelinesIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.MonitorPipelines.private\Remove-AzMonitorPipelinesPipelineGroup_Delete';
            DeleteViaIdentity = 'Az.MonitorPipelines.private\Remove-AzMonitorPipelinesPipelineGroup_DeleteViaIdentity';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId')) {
            $testPlayback = $false
            $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Updates a pipeline group instance
.Description
Updates a pipeline group instance
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.IMonitorPipelinesIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IPipelineGroup
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

EXPORTER <IExporter[]>: The exporters specified for a pipeline group instance.
  Name <String>: The name of exporter.
  Type <ExporterType>: The type of exporter.
  [ApiDataCollectionEndpointUrl <String>]: Data collection endpoint ingestion url.
  [ApiDataCollectionRule <String>]: Data Collection Rule (DCR) immutable id.
  [ApiStream <String>]: Stream name in destination. Azure Monitor stream is related to the destination table.
  [CacheMaxStorageUsage <Int32?>]: Max storage usage in megabytes.
  [CacheRetentionPeriod <Int32?>]: Retention period in minutes.
  [ConcurrencyBatchQueueSize <Int32?>]: Size of the queue for log batches.
  [ConcurrencyWorkerCount <Int32?>]: Number of parallel workers processing the log queues.
  [SchemaRecordMap <IRecordMap[]>]: Record Map.
    From <String>: Record Map Key.
    To <String>: Record Map Value.
  [SchemaResourceMap <IResourceMap[]>]: Resource Map captures information about the entity for which telemetry is recorded. For example, metrics exposed by a Kubernetes container can be linked to a resource that specifies the cluster, namespace, pod, and container name.Resource may capture an entire hierarchy of entity identification. It may describe the host in the cloud and specific container or an application running in the process.
    From <String>: Resource Map Key.
    To <String>: Resource Map Value.
  [SchemaScopeMap <IScopeMap[]>]: A scope map is a logical unit of the application code with which the emitted telemetry can be associated.
    From <String>: Scope Map Key.
    To <String>: Scope Map Value.
  [TcpUrl <String>]: TCP url to export.

INPUTOBJECT <IMonitorPipelinesIdentity>: Identity Parameter
  [Id <String>]: Resource identity path
  [PipelineGroupName <String>]: The name of pipeline group. The name is case insensitive.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.

NETWORKINGCONFIGURATION <INetworkingConfiguration[]>: Networking configurations for the pipeline group instance.
  Route <INetworkingRoute[]>: Networking routes configuration.
    Receiver <String>: The name of the previously defined receiver.
    [Path <String>]: Route path.
    [Port <Int32?>]: The port that will be configured externally. If not specified, it will use the port from the receiver definition.
    [Subdomain <String>]: Route subdomain.
  [Host <String>]: The address exposed on the cluster. Example: azuremonitorpipeline.contoso.com.

PROCESSOR <IProcessor[]>: The processors specified for a pipeline group instance.
  Name <String>: The name of processor.
  [BatchSize <Int32?>]: Size of the batch.
  [BatchTimeout <Int32?>]: Timeout in milliseconds.

RECEIVER <IReceiver[]>: The receivers specified for a pipeline group instance.
  Name <String>: The name of receiver.
  Type <ReceiverType>: The type of receiver.
  [DestinationFieldDestination <JsonMapperElement?>]: Define the destination's element. The element is the body or the attributes of the message, to which the json array mapper will write the output map.
  [DestinationFieldName <String>]: Define a destination field name under the given element. Leaving this empty, means the root of the element. In case element=attributes and fieldName is empty, the object's attributes themselves will contain the key value output pairs.
  [JsonArrayMapperKey <String[]>]: Define the names of the keys in the resulting map. The input json array elements are mapped in order, one for every key.
  [OtlpEndpoint <String>]: OTLP GRPC endpoint definition. Example: 0.0.0.0:<port>.
  [SourceFieldName <String>]: Define a source field name from which the json array mapper will read the json array. Leaving this empty, means reading the body of the message itself.
  [SyslogEndpoint <String>]: Syslog receiver endpoint definition. Example: 0.0.0.0:<port>.
  [SyslogProtocol <SyslogProtocol?>]: Protocol to parse syslog messages. Default rfc3164
  [UdpEncoding <StreamEncodingType?>]: The encoding of the stream being received.
  [UdpEndpoint <String>]: TCP endpoint definition. Example: 0.0.0.0:<port>.
  [UdpReadQueueLength <Int32?>]: Max read queue length.

SERVICEPIPELINE <IPipeline[]>: Pipelines belonging to a given pipeline group.
  Exporter <String[]>: Reference to exporters configured for the pipeline.
  Name <String>: Name of the pipeline.
  Receiver <String[]>: Reference to receivers configured for the pipeline.
  [Processor <String[]>]: Reference to processors configured for the pipeline.
.Link
https://learn.microsoft.com/powershell/module/az.monitorpipelines/update-azmonitorpipelinespipelinegroup
#>
function Update-AzMonitorPipelinesPipelineGroup {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IPipelineGroup])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Alias('PipelineGroupName')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [System.String]
    # The name of pipeline group.
    # The name is case insensitive.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.IMonitorPipelinesIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IExporter[]]
    # The exporters specified for a pipeline group instance.
    # To construct, see NOTES section for EXPORTER properties and create a hash table.
    ${Exporter},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.INetworkingConfiguration[]]
    # Networking configurations for the pipeline group instance.
    # To construct, see NOTES section for NETWORKINGCONFIGURATION properties and create a hash table.
    ${NetworkingConfiguration},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [System.String]
    # The name of the mounted persistent volume.
    ${PersistencePersistentVolumeName},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IProcessor[]]
    # The processors specified for a pipeline group instance.
    # To construct, see NOTES section for PROCESSOR properties and create a hash table.
    ${Processor},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IReceiver[]]
    # The receivers specified for a pipeline group instance.
    # To construct, see NOTES section for RECEIVER properties and create a hash table.
    ${Receiver},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [System.Int32]
    # Defines the amount of replicas of the pipeline group instance.
    ${Replica},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IPipeline[]]
    # Pipelines belonging to a given pipeline group.
    # To construct, see NOTES section for SERVICEPIPELINE properties and create a hash table.
    ${ServicePipeline},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Models.Api20241001Preview.IAzureResourceManagerCommonTypesTrackedResourceUpdateTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.MonitorPipelines.private\Update-AzMonitorPipelinesPipelineGroup_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.MonitorPipelines.private\Update-AzMonitorPipelinesPipelineGroup_UpdateViaIdentityExpanded';
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId')) {
            $testPlayback = $false
            $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.MonitorPipelines.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

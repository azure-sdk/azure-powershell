// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101
{
    using static Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Extensions;

    /// <summary>The live event track event.</summary>
    public partial class LiveEventTrackEvent :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEvent,
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventInternal
    {

        /// <summary>Backing field for <see cref="Data" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventData _data;

        /// <summary>Event data.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventData Data { get => (this._data = this._data ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.LiveEventTrackEventData()); set => this._data = value; }

        /// <summary>Bitrate of the track.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public long? DataBitrate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).Bitrate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).Bitrate = value ?? default(long); }

        /// <summary>Number of discontinuities detected in the last 20 seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public long? DataDiscontinuityCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).DiscontinuityCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).DiscontinuityCount = value ?? default(long); }

        /// <summary>Indicates whether ingest is healthy.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? DataHealthy { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).Healthy; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).Healthy = value ?? default(bool); }

        /// <summary>Calculated bitrate based on data chunks coming from encoder.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public long? DataIncomingBitrate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).IncomingBitrate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).IncomingBitrate = value ?? default(long); }

        /// <summary>
        /// Indicates the speed of delay, in seconds-per-minute, of the incoming audio or video data during the last minute. The value
        /// is greater than zero if data is arriving to the live event slower than expected in the last minute; zero if data arrived
        /// with no delay; and "n/a" if no audio or video data was received. For example, if you have a contribution encoder sending
        /// in live content, and it is slowing down due to processing issues, or network latency, it may be only able to deliver a
        /// total of 58 seconds of audio or video in a one-minute period. This would be reported as two seconds-per-minute of drift.
        /// If the encoder is able to catch up and send all 60 seconds or more of data every minute, you will see this value reported
        /// as 0. If there was a disconnection or discontinuity from the encoder, this value may still display as 0, as it does not
        /// account for breaks in the data - only data that is delayed in timestamps.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DataIngestDriftValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).IngestDriftValue; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).IngestDriftValue = value ?? null; }

        /// <summary>The last timestamp in UTC that a fragment arrived at the ingest endpoint.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public global::System.DateTime? DataLastFragmentArrivalTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).LastFragmentArrivalTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).LastFragmentArrivalTime = value ?? default(global::System.DateTime); }

        /// <summary>Latest timestamp received for a track in last 20 seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DataLastTimestamp { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).LastTimestamp; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).LastTimestamp = value ?? null; }

        /// <summary>
        /// Number of data chunks with timestamps in the past that were received in last 20 seconds.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public long? DataNonincreasingCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).NonincreasingCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).NonincreasingCount = value ?? default(long); }

        /// <summary>Number of data chunks that had overlapped timestamps in last 20 seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public long? DataOverlapCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).OverlapCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).OverlapCount = value ?? default(long); }

        /// <summary>State of the live event.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DataState { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).State; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).State = value ?? null; }

        /// <summary>Timescale in which timestamps are expressed.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DataTimescale { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).Timescale; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).Timescale = value ?? null; }

        /// <summary>Name of the track.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DataTrackName { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).TrackName; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).TrackName = value ?? null; }

        /// <summary>Type of the track.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventTrackType? DataTrackType { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).TrackType; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).TrackType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventTrackType)""); }

        /// <summary>
        /// The language code (in BCP-47 format) of the transcription language. For example, "de-de" indicates German (Germany). The
        /// value is empty for the video track heartbeats, or when live transcription is turned off.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DataTranscriptionLanguage { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).TranscriptionLanguage; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).TranscriptionLanguage = value ?? null; }

        /// <summary>
        /// This value is "On" for audio track heartbeats if live transcription is turned on, otherwise you will see an empty string.
        /// This state is only applicable to track type of "audio" for Live transcription. All other tracks will have an empty value.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DataTranscriptionState { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).TranscriptionState; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).TranscriptionState = value ?? null; }

        /// <summary>
        /// If expected and actual bitrates differ by more than allowed limit in last 20 seconds.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? DataUnexpectedBitrate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).UnexpectedBitrate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventDataInternal)Data).UnexpectedBitrate = value ?? default(bool); }

        /// <summary>Backing field for <see cref="EventTime" /> property.</summary>
        private global::System.DateTime? _eventTime;

        /// <summary>The time event raised.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        public global::System.DateTime? EventTime { get => this._eventTime; set => this._eventTime = value; }

        /// <summary>Backing field for <see cref="EventType" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventTrackEventType? _eventType;

        /// <summary>The type of the track event.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventTrackEventType? EventType { get => this._eventType; set => this._eventType = value; }

        /// <summary>Internal Acessors for Data</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventData Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventInternal.Data { get => (this._data = this._data ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.LiveEventTrackEventData()); set { {_data = value;} } }

        /// <summary>Creates an new <see cref="LiveEventTrackEvent" /> instance.</summary>
        public LiveEventTrackEvent()
        {

        }
    }
    /// The live event track event.
    public partial interface ILiveEventTrackEvent :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IJsonSerializable
    {
        /// <summary>Bitrate of the track.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Bitrate of the track.",
        SerializedName = @"bitrate",
        PossibleTypes = new [] { typeof(long) })]
        long? DataBitrate { get; set; }
        /// <summary>Number of discontinuities detected in the last 20 seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of discontinuities detected in the last 20 seconds.",
        SerializedName = @"discontinuityCount",
        PossibleTypes = new [] { typeof(long) })]
        long? DataDiscontinuityCount { get; set; }
        /// <summary>Indicates whether ingest is healthy.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether ingest is healthy.",
        SerializedName = @"healthy",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DataHealthy { get; set; }
        /// <summary>Calculated bitrate based on data chunks coming from encoder.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Calculated bitrate based on data chunks coming from encoder.",
        SerializedName = @"incomingBitrate",
        PossibleTypes = new [] { typeof(long) })]
        long? DataIncomingBitrate { get; set; }
        /// <summary>
        /// Indicates the speed of delay, in seconds-per-minute, of the incoming audio or video data during the last minute. The value
        /// is greater than zero if data is arriving to the live event slower than expected in the last minute; zero if data arrived
        /// with no delay; and "n/a" if no audio or video data was received. For example, if you have a contribution encoder sending
        /// in live content, and it is slowing down due to processing issues, or network latency, it may be only able to deliver a
        /// total of 58 seconds of audio or video in a one-minute period. This would be reported as two seconds-per-minute of drift.
        /// If the encoder is able to catch up and send all 60 seconds or more of data every minute, you will see this value reported
        /// as 0. If there was a disconnection or discontinuity from the encoder, this value may still display as 0, as it does not
        /// account for breaks in the data - only data that is delayed in timestamps.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates the speed of delay, in seconds-per-minute, of the incoming audio or video data during the last minute. The value is greater than zero if data is arriving to the live event slower than expected in the last minute; zero if data arrived with no delay; and ""n/a"" if no audio or video data was received. For example, if you have a contribution encoder sending in live content, and it is slowing down due to processing issues, or network latency, it may be only able to deliver a total of 58 seconds of audio or video in a one-minute period. This would be reported as two seconds-per-minute of drift. If the encoder is able to catch up and send all 60 seconds or more of data every minute, you will see this value reported as 0. If there was a disconnection or discontinuity from the encoder, this value may still display as 0, as it does not account for breaks in the data - only data that is delayed in timestamps.",
        SerializedName = @"ingestDriftValue",
        PossibleTypes = new [] { typeof(string) })]
        string DataIngestDriftValue { get; set; }
        /// <summary>The last timestamp in UTC that a fragment arrived at the ingest endpoint.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The last timestamp in UTC that a fragment arrived at the ingest endpoint.",
        SerializedName = @"lastFragmentArrivalTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? DataLastFragmentArrivalTime { get; set; }
        /// <summary>Latest timestamp received for a track in last 20 seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Latest timestamp received for a track in last 20 seconds.",
        SerializedName = @"lastTimestamp",
        PossibleTypes = new [] { typeof(string) })]
        string DataLastTimestamp { get; set; }
        /// <summary>
        /// Number of data chunks with timestamps in the past that were received in last 20 seconds.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of data chunks with timestamps in the past that were received in last 20 seconds.",
        SerializedName = @"nonincreasingCount",
        PossibleTypes = new [] { typeof(long) })]
        long? DataNonincreasingCount { get; set; }
        /// <summary>Number of data chunks that had overlapped timestamps in last 20 seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of data chunks that had overlapped timestamps in last 20 seconds.",
        SerializedName = @"overlapCount",
        PossibleTypes = new [] { typeof(long) })]
        long? DataOverlapCount { get; set; }
        /// <summary>State of the live event.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"State of the live event.",
        SerializedName = @"state",
        PossibleTypes = new [] { typeof(string) })]
        string DataState { get; set; }
        /// <summary>Timescale in which timestamps are expressed.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Timescale in which timestamps are expressed.",
        SerializedName = @"timescale",
        PossibleTypes = new [] { typeof(string) })]
        string DataTimescale { get; set; }
        /// <summary>Name of the track.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Name of the track.",
        SerializedName = @"trackName",
        PossibleTypes = new [] { typeof(string) })]
        string DataTrackName { get; set; }
        /// <summary>Type of the track.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Type of the track.",
        SerializedName = @"trackType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventTrackType) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventTrackType? DataTrackType { get; set; }
        /// <summary>
        /// The language code (in BCP-47 format) of the transcription language. For example, "de-de" indicates German (Germany). The
        /// value is empty for the video track heartbeats, or when live transcription is turned off.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The language code (in BCP-47 format) of the transcription language. For example, ""de-de"" indicates German (Germany). The value is empty for the video track heartbeats, or when live transcription is turned off.",
        SerializedName = @"transcriptionLanguage",
        PossibleTypes = new [] { typeof(string) })]
        string DataTranscriptionLanguage { get; set; }
        /// <summary>
        /// This value is "On" for audio track heartbeats if live transcription is turned on, otherwise you will see an empty string.
        /// This state is only applicable to track type of "audio" for Live transcription. All other tracks will have an empty value.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This value is ""On"" for audio track heartbeats if live transcription is turned on, otherwise you will see an empty string. This state is only applicable to track type of ""audio"" for Live transcription. All other tracks will have an empty value.",
        SerializedName = @"transcriptionState",
        PossibleTypes = new [] { typeof(string) })]
        string DataTranscriptionState { get; set; }
        /// <summary>
        /// If expected and actual bitrates differ by more than allowed limit in last 20 seconds.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If expected and actual bitrates differ by more than allowed limit in last 20 seconds.",
        SerializedName = @"unexpectedBitrate",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DataUnexpectedBitrate { get; set; }
        /// <summary>The time event raised.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The time event raised.",
        SerializedName = @"eventTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? EventTime { get; set; }
        /// <summary>The type of the track event.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of the track event.",
        SerializedName = @"eventType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventTrackEventType) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventTrackEventType? EventType { get; set; }

    }
    /// The live event track event.
    internal partial interface ILiveEventTrackEventInternal

    {
        /// <summary>Event data.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20221101.ILiveEventTrackEventData Data { get; set; }
        /// <summary>Bitrate of the track.</summary>
        long? DataBitrate { get; set; }
        /// <summary>Number of discontinuities detected in the last 20 seconds.</summary>
        long? DataDiscontinuityCount { get; set; }
        /// <summary>Indicates whether ingest is healthy.</summary>
        bool? DataHealthy { get; set; }
        /// <summary>Calculated bitrate based on data chunks coming from encoder.</summary>
        long? DataIncomingBitrate { get; set; }
        /// <summary>
        /// Indicates the speed of delay, in seconds-per-minute, of the incoming audio or video data during the last minute. The value
        /// is greater than zero if data is arriving to the live event slower than expected in the last minute; zero if data arrived
        /// with no delay; and "n/a" if no audio or video data was received. For example, if you have a contribution encoder sending
        /// in live content, and it is slowing down due to processing issues, or network latency, it may be only able to deliver a
        /// total of 58 seconds of audio or video in a one-minute period. This would be reported as two seconds-per-minute of drift.
        /// If the encoder is able to catch up and send all 60 seconds or more of data every minute, you will see this value reported
        /// as 0. If there was a disconnection or discontinuity from the encoder, this value may still display as 0, as it does not
        /// account for breaks in the data - only data that is delayed in timestamps.
        /// </summary>
        string DataIngestDriftValue { get; set; }
        /// <summary>The last timestamp in UTC that a fragment arrived at the ingest endpoint.</summary>
        global::System.DateTime? DataLastFragmentArrivalTime { get; set; }
        /// <summary>Latest timestamp received for a track in last 20 seconds.</summary>
        string DataLastTimestamp { get; set; }
        /// <summary>
        /// Number of data chunks with timestamps in the past that were received in last 20 seconds.
        /// </summary>
        long? DataNonincreasingCount { get; set; }
        /// <summary>Number of data chunks that had overlapped timestamps in last 20 seconds.</summary>
        long? DataOverlapCount { get; set; }
        /// <summary>State of the live event.</summary>
        string DataState { get; set; }
        /// <summary>Timescale in which timestamps are expressed.</summary>
        string DataTimescale { get; set; }
        /// <summary>Name of the track.</summary>
        string DataTrackName { get; set; }
        /// <summary>Type of the track.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventTrackType? DataTrackType { get; set; }
        /// <summary>
        /// The language code (in BCP-47 format) of the transcription language. For example, "de-de" indicates German (Germany). The
        /// value is empty for the video track heartbeats, or when live transcription is turned off.
        /// </summary>
        string DataTranscriptionLanguage { get; set; }
        /// <summary>
        /// This value is "On" for audio track heartbeats if live transcription is turned on, otherwise you will see an empty string.
        /// This state is only applicable to track type of "audio" for Live transcription. All other tracks will have an empty value.
        /// </summary>
        string DataTranscriptionState { get; set; }
        /// <summary>
        /// If expected and actual bitrates differ by more than allowed limit in last 20 seconds.
        /// </summary>
        bool? DataUnexpectedBitrate { get; set; }
        /// <summary>The time event raised.</summary>
        global::System.DateTime? EventTime { get; set; }
        /// <summary>The type of the track event.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventTrackEventType? EventType { get; set; }

    }
}
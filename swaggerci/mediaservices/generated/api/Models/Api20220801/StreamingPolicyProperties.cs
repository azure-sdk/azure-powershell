// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801
{
    using static Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Extensions;

    /// <summary>Class to specify properties of Streaming Policy</summary>
    public partial class StreamingPolicyProperties :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyProperties,
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal
    {

        /// <summary>Backing field for <see cref="CommonEncryptionCbc" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcs _commonEncryptionCbc;

        /// <summary>Configuration of CommonEncryptionCbcs</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcs CommonEncryptionCbc { get => (this._commonEncryptionCbc = this._commonEncryptionCbc ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.CommonEncryptionCbcs()); set => this._commonEncryptionCbc = value; }

        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection[] CommonEncryptionCbcClearTrack { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ClearTrack; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ClearTrack = value ?? null /* arrayOf */; }

        /// <summary>
        /// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure
        /// Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime
        /// with the value specific to the request. The currently supported token value is {AlternativeMediaId}, which is replaced
        /// with the value of StreamingLocatorId.AlternativeMediaId.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsClearKeyEncryptionConfigurationCustomKeysAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ClearKeyEncryptionConfigurationCustomKeysAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ClearKeyEncryptionConfigurationCustomKeysAcquisitionUrlTemplate = value ?? null; }

        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsContentKeysDefaultKeyLabel { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).DefaultKeyLabel; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).DefaultKeyLabel = value ?? null; }

        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsContentKeysDefaultKeyPolicyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).DefaultKeyPolicyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).DefaultKeyPolicyName = value ?? null; }

        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey[] CommonEncryptionCbcsContentKeysKeyToTrackMapping { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ContentKeyToTrackMapping; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ContentKeyToTrackMapping = value ?? null /* arrayOf */; }

        /// <summary>Custom attributes for PlayReady</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsDrmPlayReadyCustomAttribute { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).PlayReadyCustomAttribute; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).PlayReadyCustomAttribute = value ?? null; }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).PlayReadyCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).PlayReadyCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsDrmWidevineCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).WidevineCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).WidevineCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCbcsEnabledProtocolsDash { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).EnabledProtocolDash; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).EnabledProtocolDash = value ?? default(bool); }

        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCbcsEnabledProtocolsDownload { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).EnabledProtocolDownload; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).EnabledProtocolDownload = value ?? default(bool); }

        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCbcsEnabledProtocolsHl { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).EnabledProtocolHl; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).EnabledProtocolHl = value ?? default(bool); }

        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCbcsEnabledProtocolsSmoothStreaming { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).EnabledProtocolSmoothStreaming; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).EnabledProtocolSmoothStreaming = value ?? default(bool); }

        /// <summary>Backing field for <see cref="CommonEncryptionCenc" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCenc _commonEncryptionCenc;

        /// <summary>Configuration of CommonEncryptionCenc</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCenc CommonEncryptionCenc { get => (this._commonEncryptionCenc = this._commonEncryptionCenc ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.CommonEncryptionCenc()); set => this._commonEncryptionCenc = value; }

        /// <summary>
        /// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure
        /// Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime
        /// with the value specific to the request. The currently supported token value is {AlternativeMediaId}, which is replaced
        /// with the value of StreamingLocatorId.AlternativeMediaId.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencClearKeyEncryptionConfigurationCustomKeysAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ClearKeyEncryptionConfigurationCustomKeysAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ClearKeyEncryptionConfigurationCustomKeysAcquisitionUrlTemplate = value ?? null; }

        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection[] CommonEncryptionCencClearTrack { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ClearTrack; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ClearTrack = value ?? null /* arrayOf */; }

        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencContentKeysDefaultKeyLabel { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).DefaultKeyLabel; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).DefaultKeyLabel = value ?? null; }

        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencContentKeysDefaultKeyPolicyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).DefaultKeyPolicyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).DefaultKeyPolicyName = value ?? null; }

        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey[] CommonEncryptionCencContentKeysKeyToTrackMapping { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ContentKeyToTrackMapping; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ContentKeyToTrackMapping = value ?? null /* arrayOf */; }

        /// <summary>Custom attributes for PlayReady</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencDrmPlayReadyCustomAttribute { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).PlayReadyCustomAttribute; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).PlayReadyCustomAttribute = value ?? null; }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).PlayReadyCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).PlayReadyCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencDrmWidevineCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).WidevineCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).WidevineCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCencEnabledProtocolsDash { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).EnabledProtocolDash; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).EnabledProtocolDash = value ?? default(bool); }

        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCencEnabledProtocolsDownload { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).EnabledProtocolDownload; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).EnabledProtocolDownload = value ?? default(bool); }

        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCencEnabledProtocolsHl { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).EnabledProtocolHl; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).EnabledProtocolHl = value ?? default(bool); }

        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCencEnabledProtocolsSmoothStreaming { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).EnabledProtocolSmoothStreaming; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).EnabledProtocolSmoothStreaming = value ?? default(bool); }

        /// <summary>Backing field for <see cref="Created" /> property.</summary>
        private global::System.DateTime? _created;

        /// <summary>Creation time of Streaming Policy</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        public global::System.DateTime? Created { get => this._created; }

        /// <summary>Backing field for <see cref="DefaultContentKeyPolicyName" /> property.</summary>
        private string _defaultContentKeyPolicyName;

        /// <summary>Default ContentKey used by current Streaming Policy</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        public string DefaultContentKeyPolicyName { get => this._defaultContentKeyPolicyName; set => this._defaultContentKeyPolicyName = value; }

        /// <summary>Backing field for <see cref="EnvelopeEncryption" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryption _envelopeEncryption;

        /// <summary>Configuration of EnvelopeEncryption</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryption EnvelopeEncryption { get => (this._envelopeEncryption = this._envelopeEncryption ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.EnvelopeEncryption()); set => this._envelopeEncryption = value; }

        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection[] EnvelopeEncryptionClearTrack { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).ClearTrack; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).ClearTrack = value ?? null /* arrayOf */; }

        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string EnvelopeEncryptionContentKeysDefaultKeyLabel { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).DefaultKeyLabel; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).DefaultKeyLabel = value ?? null; }

        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string EnvelopeEncryptionContentKeysDefaultKeyPolicyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).DefaultKeyPolicyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).DefaultKeyPolicyName = value ?? null; }

        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey[] EnvelopeEncryptionContentKeysKeyToTrackMapping { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).ContentKeyToTrackMapping; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).ContentKeyToTrackMapping = value ?? null /* arrayOf */; }

        /// <summary>
        /// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services
        /// for issuing keys. The template supports replaceable tokens that the service will update at runtime with the value specific
        /// to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId,
        /// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string EnvelopeEncryptionCustomKeyAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).CustomKeyAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).CustomKeyAcquisitionUrlTemplate = value ?? null; }

        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnvelopeEncryptionEnabledProtocolsDash { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).EnabledProtocolDash; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).EnabledProtocolDash = value ?? default(bool); }

        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnvelopeEncryptionEnabledProtocolsDownload { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).EnabledProtocolDownload; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).EnabledProtocolDownload = value ?? default(bool); }

        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnvelopeEncryptionEnabledProtocolsHl { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).EnabledProtocolHl; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).EnabledProtocolHl = value ?? default(bool); }

        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnvelopeEncryptionEnabledProtocolsSmoothStreaming { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).EnabledProtocolSmoothStreaming; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).EnabledProtocolSmoothStreaming = value ?? default(bool); }

        /// <summary>All license to be persistent or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? FairPlayAllowPersistentLicense { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).FairPlayAllowPersistentLicense; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).FairPlayAllowPersistentLicense = value ?? default(bool); }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string FairPlayCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).FairPlayCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).FairPlayCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>Internal Acessors for CommonEncryptionCbc</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcs Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCbc { get => (this._commonEncryptionCbc = this._commonEncryptionCbc ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.CommonEncryptionCbcs()); set { {_commonEncryptionCbc = value;} } }

        /// <summary>Internal Acessors for CommonEncryptionCbcClearKeyEncryptionConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IClearKeyEncryptionConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCbcClearKeyEncryptionConfiguration { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ClearKeyEncryptionConfiguration; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ClearKeyEncryptionConfiguration = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcContentKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKeys Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCbcContentKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ContentKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ContentKey = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcDrm</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICbcsDrmConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCbcDrm { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).Drm; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).Drm = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcEnabledProtocol</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnabledProtocols Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCbcEnabledProtocol { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).EnabledProtocol; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).EnabledProtocol = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcsContentKeysDefaultKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IDefaultKey Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCbcsContentKeysDefaultKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ContentKeyDefaultKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).ContentKeyDefaultKey = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcsDrmPlayReady</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPlayReadyConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCbcsDrmPlayReady { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).DrmPlayReady; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).DrmPlayReady = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcsDrmWidevine</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyWidevineConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCbcsDrmWidevine { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).DrmWidevine; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).DrmWidevine = value; }

        /// <summary>Internal Acessors for CommonEncryptionCenc</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCenc Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCenc { get => (this._commonEncryptionCenc = this._commonEncryptionCenc ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.CommonEncryptionCenc()); set { {_commonEncryptionCenc = value;} } }

        /// <summary>Internal Acessors for CommonEncryptionCencClearKeyEncryptionConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IClearKeyEncryptionConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCencClearKeyEncryptionConfiguration { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ClearKeyEncryptionConfiguration; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ClearKeyEncryptionConfiguration = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencContentKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKeys Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCencContentKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ContentKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ContentKey = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencContentKeysDefaultKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IDefaultKey Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCencContentKeysDefaultKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ContentKeyDefaultKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).ContentKeyDefaultKey = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencDrm</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICencDrmConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCencDrm { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).Drm; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).Drm = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencDrmPlayReady</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPlayReadyConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCencDrmPlayReady { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).DrmPlayReady; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).DrmPlayReady = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencDrmWidevine</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyWidevineConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCencDrmWidevine { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).DrmWidevine; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).DrmWidevine = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencEnabledProtocol</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnabledProtocols Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.CommonEncryptionCencEnabledProtocol { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).EnabledProtocol; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCencInternal)CommonEncryptionCenc).EnabledProtocol = value; }

        /// <summary>Internal Acessors for Created</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.Created { get => this._created; set { {_created = value;} } }

        /// <summary>Internal Acessors for DrmFairPlay</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyFairPlayConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.DrmFairPlay { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).DrmFairPlay; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcsInternal)CommonEncryptionCbc).DrmFairPlay = value; }

        /// <summary>Internal Acessors for EnvelopeEncryption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryption Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.EnvelopeEncryption { get => (this._envelopeEncryption = this._envelopeEncryption ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.EnvelopeEncryption()); set { {_envelopeEncryption = value;} } }

        /// <summary>Internal Acessors for EnvelopeEncryptionContentKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKeys Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.EnvelopeEncryptionContentKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).ContentKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).ContentKey = value; }

        /// <summary>Internal Acessors for EnvelopeEncryptionContentKeysDefaultKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IDefaultKey Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.EnvelopeEncryptionContentKeysDefaultKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).ContentKeyDefaultKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).ContentKeyDefaultKey = value; }

        /// <summary>Internal Acessors for EnvelopeEncryptionEnabledProtocol</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnabledProtocols Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.EnvelopeEncryptionEnabledProtocol { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).EnabledProtocol; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryptionInternal)EnvelopeEncryption).EnabledProtocol = value; }

        /// <summary>Internal Acessors for NoEncryption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryption Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.NoEncryption { get => (this._noEncryption = this._noEncryption ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.NoEncryption()); set { {_noEncryption = value;} } }

        /// <summary>Internal Acessors for NoEncryptionEnabledProtocol</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnabledProtocols Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPropertiesInternal.NoEncryptionEnabledProtocol { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryptionInternal)NoEncryption).EnabledProtocol; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryptionInternal)NoEncryption).EnabledProtocol = value; }

        /// <summary>Backing field for <see cref="NoEncryption" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryption _noEncryption;

        /// <summary>Configurations of NoEncryption</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryption NoEncryption { get => (this._noEncryption = this._noEncryption ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.NoEncryption()); set => this._noEncryption = value; }

        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? NoEncryptionEnabledProtocolsDash { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryptionInternal)NoEncryption).EnabledProtocolDash; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryptionInternal)NoEncryption).EnabledProtocolDash = value ?? default(bool); }

        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? NoEncryptionEnabledProtocolsDownload { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryptionInternal)NoEncryption).EnabledProtocolDownload; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryptionInternal)NoEncryption).EnabledProtocolDownload = value ?? default(bool); }

        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? NoEncryptionEnabledProtocolsHl { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryptionInternal)NoEncryption).EnabledProtocolHl; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryptionInternal)NoEncryption).EnabledProtocolHl = value ?? default(bool); }

        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? NoEncryptionEnabledProtocolsSmoothStreaming { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryptionInternal)NoEncryption).EnabledProtocolSmoothStreaming; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryptionInternal)NoEncryption).EnabledProtocolSmoothStreaming = value ?? default(bool); }

        /// <summary>Creates an new <see cref="StreamingPolicyProperties" /> instance.</summary>
        public StreamingPolicyProperties()
        {

        }
    }
    /// Class to specify properties of Streaming Policy
    public partial interface IStreamingPolicyProperties :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IJsonSerializable
    {
        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing which tracks should not be encrypted",
        SerializedName = @"clearTracks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection[] CommonEncryptionCbcClearTrack { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure
        /// Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime
        /// with the value specific to the request. The currently supported token value is {AlternativeMediaId}, which is replaced
        /// with the value of StreamingLocatorId.AlternativeMediaId.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token value is {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId.",
        SerializedName = @"customKeysAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsClearKeyEncryptionConfigurationCustomKeysAcquisitionUrlTemplate { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Label can be used to specify Content Key when creating a Streaming Locator",
        SerializedName = @"label",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Policy used by Default Key",
        SerializedName = @"policyName",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing tracks needs separate content key",
        SerializedName = @"keyToTrackMappings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey[] CommonEncryptionCbcsContentKeysKeyToTrackMapping { get; set; }
        /// <summary>Custom attributes for PlayReady</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom attributes for PlayReady",
        SerializedName = @"playReadyCustomAttributes",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsDrmPlayReadyCustomAttribute { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsDrmWidevineCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable DASH protocol or not",
        SerializedName = @"dash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCbcsEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable Download protocol or not",
        SerializedName = @"download",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCbcsEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable HLS protocol or not",
        SerializedName = @"hls",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCbcsEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable SmoothStreaming protocol or not",
        SerializedName = @"smoothStreaming",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCbcsEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure
        /// Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime
        /// with the value specific to the request. The currently supported token value is {AlternativeMediaId}, which is replaced
        /// with the value of StreamingLocatorId.AlternativeMediaId.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token value is {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId.",
        SerializedName = @"customKeysAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencClearKeyEncryptionConfigurationCustomKeysAcquisitionUrlTemplate { get; set; }
        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing which tracks should not be encrypted",
        SerializedName = @"clearTracks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection[] CommonEncryptionCencClearTrack { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Label can be used to specify Content Key when creating a Streaming Locator",
        SerializedName = @"label",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Policy used by Default Key",
        SerializedName = @"policyName",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing tracks needs separate content key",
        SerializedName = @"keyToTrackMappings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey[] CommonEncryptionCencContentKeysKeyToTrackMapping { get; set; }
        /// <summary>Custom attributes for PlayReady</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom attributes for PlayReady",
        SerializedName = @"playReadyCustomAttributes",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencDrmPlayReadyCustomAttribute { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencDrmWidevineCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable DASH protocol or not",
        SerializedName = @"dash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCencEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable Download protocol or not",
        SerializedName = @"download",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCencEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable HLS protocol or not",
        SerializedName = @"hls",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCencEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable SmoothStreaming protocol or not",
        SerializedName = @"smoothStreaming",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCencEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>Creation time of Streaming Policy</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Creation time of Streaming Policy",
        SerializedName = @"created",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? Created { get;  }
        /// <summary>Default ContentKey used by current Streaming Policy</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Default ContentKey used by current Streaming Policy",
        SerializedName = @"defaultContentKeyPolicyName",
        PossibleTypes = new [] { typeof(string) })]
        string DefaultContentKeyPolicyName { get; set; }
        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing which tracks should not be encrypted",
        SerializedName = @"clearTracks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection[] EnvelopeEncryptionClearTrack { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Label can be used to specify Content Key when creating a Streaming Locator",
        SerializedName = @"label",
        PossibleTypes = new [] { typeof(string) })]
        string EnvelopeEncryptionContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Policy used by Default Key",
        SerializedName = @"policyName",
        PossibleTypes = new [] { typeof(string) })]
        string EnvelopeEncryptionContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing tracks needs separate content key",
        SerializedName = @"keyToTrackMappings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey[] EnvelopeEncryptionContentKeysKeyToTrackMapping { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services
        /// for issuing keys. The template supports replaceable tokens that the service will update at runtime with the value specific
        /// to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId,
        /// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customKeyAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string EnvelopeEncryptionCustomKeyAcquisitionUrlTemplate { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable DASH protocol or not",
        SerializedName = @"dash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnvelopeEncryptionEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable Download protocol or not",
        SerializedName = @"download",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnvelopeEncryptionEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable HLS protocol or not",
        SerializedName = @"hls",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnvelopeEncryptionEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable SmoothStreaming protocol or not",
        SerializedName = @"smoothStreaming",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnvelopeEncryptionEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>All license to be persistent or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"All license to be persistent or not",
        SerializedName = @"allowPersistentLicense",
        PossibleTypes = new [] { typeof(bool) })]
        bool? FairPlayAllowPersistentLicense { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string FairPlayCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable DASH protocol or not",
        SerializedName = @"dash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NoEncryptionEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable Download protocol or not",
        SerializedName = @"download",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NoEncryptionEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable HLS protocol or not",
        SerializedName = @"hls",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NoEncryptionEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable SmoothStreaming protocol or not",
        SerializedName = @"smoothStreaming",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NoEncryptionEnabledProtocolsSmoothStreaming { get; set; }

    }
    /// Class to specify properties of Streaming Policy
    internal partial interface IStreamingPolicyPropertiesInternal

    {
        /// <summary>Configuration of CommonEncryptionCbcs</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCbcs CommonEncryptionCbc { get; set; }
        /// <summary>
        /// Optional configuration supporting ClearKey in CommonEncryptionCbcs encryption scheme.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IClearKeyEncryptionConfiguration CommonEncryptionCbcClearKeyEncryptionConfiguration { get; set; }
        /// <summary>Representing which tracks should not be encrypted</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection[] CommonEncryptionCbcClearTrack { get; set; }
        /// <summary>
        /// Representing default content key for each encryption scheme and separate content keys for specific tracks
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKeys CommonEncryptionCbcContentKey { get; set; }
        /// <summary>Configuration of DRMs for current encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICbcsDrmConfiguration CommonEncryptionCbcDrm { get; set; }
        /// <summary>Representing supported protocols</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnabledProtocols CommonEncryptionCbcEnabledProtocol { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure
        /// Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime
        /// with the value specific to the request. The currently supported token value is {AlternativeMediaId}, which is replaced
        /// with the value of StreamingLocatorId.AlternativeMediaId.
        /// </summary>
        string CommonEncryptionCbcsClearKeyEncryptionConfigurationCustomKeysAcquisitionUrlTemplate { get; set; }
        /// <summary>Default content key for an encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IDefaultKey CommonEncryptionCbcsContentKeysDefaultKey { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        string CommonEncryptionCbcsContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        string CommonEncryptionCbcsContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey[] CommonEncryptionCbcsContentKeysKeyToTrackMapping { get; set; }
        /// <summary>PlayReady configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPlayReadyConfiguration CommonEncryptionCbcsDrmPlayReady { get; set; }
        /// <summary>Custom attributes for PlayReady</summary>
        string CommonEncryptionCbcsDrmPlayReadyCustomAttribute { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string CommonEncryptionCbcsDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Widevine configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyWidevineConfiguration CommonEncryptionCbcsDrmWidevine { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string CommonEncryptionCbcsDrmWidevineCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        bool? CommonEncryptionCbcsEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        bool? CommonEncryptionCbcsEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        bool? CommonEncryptionCbcsEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        bool? CommonEncryptionCbcsEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>Configuration of CommonEncryptionCenc</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICommonEncryptionCenc CommonEncryptionCenc { get; set; }
        /// <summary>
        /// Optional configuration supporting ClearKey in CommonEncryptionCenc encryption scheme.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IClearKeyEncryptionConfiguration CommonEncryptionCencClearKeyEncryptionConfiguration { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering content keys to end user players. Not required when using Azure
        /// Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime
        /// with the value specific to the request. The currently supported token value is {AlternativeMediaId}, which is replaced
        /// with the value of StreamingLocatorId.AlternativeMediaId.
        /// </summary>
        string CommonEncryptionCencClearKeyEncryptionConfigurationCustomKeysAcquisitionUrlTemplate { get; set; }
        /// <summary>Representing which tracks should not be encrypted</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection[] CommonEncryptionCencClearTrack { get; set; }
        /// <summary>
        /// Representing default content key for each encryption scheme and separate content keys for specific tracks
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKeys CommonEncryptionCencContentKey { get; set; }
        /// <summary>Default content key for an encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IDefaultKey CommonEncryptionCencContentKeysDefaultKey { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        string CommonEncryptionCencContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        string CommonEncryptionCencContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey[] CommonEncryptionCencContentKeysKeyToTrackMapping { get; set; }
        /// <summary>Configuration of DRMs for CommonEncryptionCenc encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ICencDrmConfiguration CommonEncryptionCencDrm { get; set; }
        /// <summary>PlayReady configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyPlayReadyConfiguration CommonEncryptionCencDrmPlayReady { get; set; }
        /// <summary>Custom attributes for PlayReady</summary>
        string CommonEncryptionCencDrmPlayReadyCustomAttribute { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string CommonEncryptionCencDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Widevine configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyWidevineConfiguration CommonEncryptionCencDrmWidevine { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string CommonEncryptionCencDrmWidevineCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Representing supported protocols</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnabledProtocols CommonEncryptionCencEnabledProtocol { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        bool? CommonEncryptionCencEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        bool? CommonEncryptionCencEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        bool? CommonEncryptionCencEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        bool? CommonEncryptionCencEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>Creation time of Streaming Policy</summary>
        global::System.DateTime? Created { get; set; }
        /// <summary>Default ContentKey used by current Streaming Policy</summary>
        string DefaultContentKeyPolicyName { get; set; }
        /// <summary>FairPlay configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyFairPlayConfiguration DrmFairPlay { get; set; }
        /// <summary>Configuration of EnvelopeEncryption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnvelopeEncryption EnvelopeEncryption { get; set; }
        /// <summary>Representing which tracks should not be encrypted</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.ITrackSelection[] EnvelopeEncryptionClearTrack { get; set; }
        /// <summary>
        /// Representing default content key for each encryption scheme and separate content keys for specific tracks
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKeys EnvelopeEncryptionContentKey { get; set; }
        /// <summary>Default content key for an encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IDefaultKey EnvelopeEncryptionContentKeysDefaultKey { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        string EnvelopeEncryptionContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        string EnvelopeEncryptionContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IStreamingPolicyContentKey[] EnvelopeEncryptionContentKeysKeyToTrackMapping { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services
        /// for issuing keys. The template supports replaceable tokens that the service will update at runtime with the value specific
        /// to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId,
        /// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        /// </summary>
        string EnvelopeEncryptionCustomKeyAcquisitionUrlTemplate { get; set; }
        /// <summary>Representing supported protocols</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnabledProtocols EnvelopeEncryptionEnabledProtocol { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        bool? EnvelopeEncryptionEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        bool? EnvelopeEncryptionEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        bool? EnvelopeEncryptionEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        bool? EnvelopeEncryptionEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>All license to be persistent or not</summary>
        bool? FairPlayAllowPersistentLicense { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string FairPlayCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Configurations of NoEncryption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.INoEncryption NoEncryption { get; set; }
        /// <summary>Representing supported protocols</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20220801.IEnabledProtocols NoEncryptionEnabledProtocol { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        bool? NoEncryptionEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        bool? NoEncryptionEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        bool? NoEncryptionEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        bool? NoEncryptionEnabledProtocolsSmoothStreaming { get; set; }

    }
}
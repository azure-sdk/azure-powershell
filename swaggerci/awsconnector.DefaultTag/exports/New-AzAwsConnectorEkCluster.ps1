
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a EksCluster.
Please note that end user resource creation is currently restricted, but it will be enabled in the future.
.Description
Create a EksCluster.
Please note that end user resource creation is currently restricted, but it will be enabled in the future.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IEksCluster
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

AWSPROPERTY <IAwsEksClusterProperties>: AWS Properties
  [AccessConfigBootstrapClusterCreatorAdminPermission <Boolean?>]: <p>Specifies whether or not the cluster creator IAM principal was set as a cluster admin access entry during cluster creation time.</p>
  [Arn <String>]: <p>The Amazon Resource Name (ARN) of the cluster.</p>
  [AuthenticationModeValue <AuthenticationMode?>]: Property value
  [CertificateAuthorityData <String>]: <p>The Base64-encoded certificate data required to communicate with your cluster. Add this to the <code>certificate-authority-data</code> section of the <code>kubeconfig</code> file for your cluster.</p>
  [ClientRequestToken <String>]: <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
  [ConnectorConfigActivationCode <String>]: <p>A unique code associated with the cluster for registration purposes.</p>
  [ConnectorConfigActivationExpiry <DateTime?>]: <p>The expiration time of the connected cluster. The cluster's YAML file must be applied through the native provider.</p>
  [ConnectorConfigActivationId <String>]: <p>A unique ID associated with the cluster for registration purposes.</p>
  [ConnectorConfigProvider <String>]: <p>The cluster's cloud service provider.</p>
  [ConnectorConfigRoleArn <String>]: <p>The Amazon Resource Name (ARN) of the role to communicate with services from the connected Kubernetes cluster.</p>
  [ControlPlanePlacementGroupName <String>]: <p>The name of the placement group for the Kubernetes control plane instances.</p>
  [CreatedAt <DateTime?>]: <p>The Unix epoch timestamp at object creation.</p>
  [EncryptionConfig <IEncryptionConfig[]>]: <p>The encryption configuration for the cluster.</p>
    [ProviderKeyArn <String>]: <p>Amazon Resource Name (ARN) or alias of the KMS key. The KMS key must be symmetric and created in the same Amazon Web Services Region as the cluster. If the KMS key was created in a different account, the <a href='https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts.html'>IAM principal</a> must have access to the KMS key. For more information, see <a href='https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-modifying-external-accounts.html'>Allowing users in other accounts to use a KMS key</a> in the <i>Key Management Service Developer Guide</i>.</p>
    [Resource <String[]>]: <p>Specifies the resources to be encrypted. The only supported value is <code>secrets</code>.</p>
  [Endpoint <String>]: <p>The endpoint for your Kubernetes API server.</p>
  [HealthIssue <IClusterIssue[]>]: <p>An object representing the health issues of your local Amazon EKS cluster on an Amazon Web Services Outpost.</p>
    [CodeValue <ClusterIssueCode?>]: Property value
    [Message <String>]: <p>A description of the issue.</p>
    [ResourceId <String[]>]: <p>The resource IDs that the issue relates to.</p>
  [IPFamilyValue <IPFamily?>]: Property value
  [Id <String>]: <p>The ID of your local Amazon EKS cluster on an Amazon Web Services Outpost. This property isn't available for an Amazon EKS cluster on the Amazon Web Services cloud.</p>
  [KuberneteNetworkConfigServiceIpv4Cidr <String>]: <p>The CIDR block that Kubernetes <code>Pod</code> and <code>Service</code> object IP addresses are assigned from. Kubernetes assigns addresses from an <code>IPv4</code> CIDR block assigned to a subnet that the node is in. If you didn't specify a CIDR block when you created the cluster, then Kubernetes assigns addresses from either the <code>10.100.0.0/16</code> or <code>172.20.0.0/16</code> CIDR blocks. If this was specified, then it was specified when the cluster was created and it can't be changed.</p>
  [KuberneteNetworkConfigServiceIpv6Cidr <String>]: <p>The CIDR block that Kubernetes pod and service IP addresses are assigned from if you created a 1.21 or later cluster with version 1.10.1 or later of the Amazon VPC CNI add-on and specified <code>ipv6</code> for <b>ipFamily</b> when you created the cluster. Kubernetes assigns service addresses from the unique local address range (<code>fc00::/7</code>) because you can't specify a custom IPv6 CIDR block when you create the cluster.</p>
  [LoggingClusterLogging <ILogSetup[]>]: <p>The cluster control plane logging configuration for your cluster.</p>
    [Enabled <Boolean?>]: <p>If a log type is enabled, that log type exports its control plane logs to CloudWatch Logs. If a log type isn't enabled, that log type doesn't export its control plane logs. Each individual log type can be enabled or disabled independently.</p>
    [Type <LogType[]>]: <p>The available cluster control plane log types.</p>
  [Name <String>]: <p>The name of your cluster.</p>
  [OidcIssuer <String>]: <p>The issuer URL for the OIDC identity provider.</p>
  [OutpostConfigControlPlaneInstanceType <String>]: <p>The Amazon EC2 instance type used for the control plane. The instance type is the same for all control plane instances.</p>
  [OutpostConfigOutpostArn <String[]>]: <p>The ARN of the Outpost that you specified for use with your local Amazon EKS cluster on Outposts.</p>
  [PlatformVersion <String>]: <p>The platform version of your Amazon EKS cluster. For more information about clusters deployed on the Amazon Web Services Cloud, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/platform-versions.html'>Platform versions</a> in the <i> <i>Amazon EKS User Guide</i> </i>. For more information about local clusters deployed on an Outpost, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/eks-outposts-platform-versions.html'>Amazon EKS local cluster platform versions</a> in the <i> <i>Amazon EKS User Guide</i> </i>.</p>
  [ResourceVpcConfigClusterSecurityGroupId <String>]: <p>The cluster security group that was created by Amazon EKS for the cluster. Managed node groups use this security group for control-plane-to-data-plane communication.</p>
  [ResourceVpcConfigEndpointPrivateAccess <Boolean?>]: <p>This parameter indicates whether the Amazon EKS private API server endpoint is enabled. If the Amazon EKS private API server endpoint is enabled, Kubernetes API requests that originate from within your cluster's VPC use the private VPC endpoint instead of traversing the internet. If this value is disabled and you have nodes or Fargate pods in the cluster, then ensure that <code>publicAccessCidrs</code> includes the necessary CIDR blocks for communication with the nodes or Fargate pods. For more information, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html'>Amazon EKS cluster endpoint access control</a> in the <i> <i>Amazon EKS User Guide</i> </i>.</p>
  [ResourceVpcConfigEndpointPublicAccess <Boolean?>]: <p>Whether the public API server endpoint is enabled.</p>
  [ResourceVpcConfigPublicAccessCidr <String[]>]: <p>The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint.</p>
  [ResourceVpcConfigSecurityGroupId <String[]>]: <p>The security groups associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Kubernetes control plane.</p>
  [ResourceVpcConfigSubnetId <String[]>]: <p>The subnets associated with your cluster.</p>
  [ResourceVpcConfigVpcId <String>]: <p>The VPC associated with your cluster.</p>
  [RoleArn <String>]: <p>The Amazon Resource Name (ARN) of the IAM role that provides permissions for the Kubernetes control plane to make calls to Amazon Web Services API operations on your behalf.</p>
  [StatusValue <ClusterStatus?>]: Property value
  [Tag <IAwsEksClusterPropertiesTags>]: <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    [(Any) <String>]: This indicates any property can be added to this object.
  [Version <String>]: <p>The Kubernetes server version for the cluster.</p>
.Link
https://learn.microsoft.com/powershell/module/az.awsconnector/new-azawsconnectorekcluster
#>
function New-AzAwsConnectorEkCluster {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IEksCluster])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Path')]
    [System.String]
    # The fully qualified Azure Resource manager identifier of the resource.
    ${ResourceUri},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Body')]
    [System.String]
    # Amazon Resource Name (ARN)
    ${Arn},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Body')]
    [System.String]
    # AWS Account ID
    ${AwsAccountId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IAwsEksClusterProperties]
    # AWS Properties
    # To construct, see NOTES section for AWSPROPERTY properties and create a hash table.
    ${AwsProperty},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Body')]
    [System.String]
    # AWS Region
    ${AwsRegion},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Body')]
    [System.String]
    # AWS Source Schema
    ${AwsSourceSchema},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IEksClusterPropertiesAwsTags]))]
    [System.Collections.Hashtable]
    # AWS Tags
    ${AwsTag},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Body')]
    [System.String]
    # Public Cloud Connectors Resource ID
    ${PublicCloudConnectorsResourceId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Body')]
    [System.String]
    # Public Cloud Resource Name
    ${PublicCloudResourceName},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.AwsConnector.private\New-AzAwsConnectorEkCluster_CreateExpanded';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

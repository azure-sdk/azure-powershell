// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201
{
    using static Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Extensions;

    /// <summary>Definition of ProjectArtifacts</summary>
    public partial class ProjectArtifacts :
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IProjectArtifacts,
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IProjectArtifactsInternal
    {

        /// <summary>Backing field for <see cref="ArtifactIdentifier" /> property.</summary>
        private string _artifactIdentifier;

        /// <summary><p> An identifier for this artifact definition. </p></summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Owned)]
        public string ArtifactIdentifier { get => this._artifactIdentifier; set => this._artifactIdentifier = value; }

        /// <summary>Backing field for <see cref="BucketOwnerAccess" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IBucketOwnerAccessEnumValue _bucketOwnerAccess;

        /// <summary>Property bucketOwnerAccess</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IBucketOwnerAccessEnumValue BucketOwnerAccess { get => (this._bucketOwnerAccess = this._bucketOwnerAccess ?? new Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.BucketOwnerAccessEnumValue()); set => this._bucketOwnerAccess = value; }

        /// <summary>Property value</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.BucketOwnerAccess? BucketOwnerAccessValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IBucketOwnerAccessEnumValueInternal)BucketOwnerAccess).Value; set => ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IBucketOwnerAccessEnumValueInternal)BucketOwnerAccess).Value = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.BucketOwnerAccess)""); }

        /// <summary>Backing field for <see cref="EncryptionDisabled" /> property.</summary>
        private bool? _encryptionDisabled;

        /// <summary>
        /// <p> Set to true if you do not want your output artifacts encrypted. This option is valid only if your artifacts type is
        /// Amazon S3. If this is set with another artifacts type, an invalidInputException is thrown. </p>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Owned)]
        public bool? EncryptionDisabled { get => this._encryptionDisabled; set => this._encryptionDisabled = value; }

        /// <summary>Backing field for <see cref="Location" /> property.</summary>
        private string _location;

        /// <summary>
        /// <p>Information about the build output artifact location:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>,
        /// CodePipeline ignores this value if specified. This is because CodePipeline manages its build output locations instead
        /// of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified,
        /// because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name
        /// of the output bucket.</p> </li> </ul>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Owned)]
        public string Location { get => this._location; set => this._location = value; }

        /// <summary>Internal Acessors for BucketOwnerAccess</summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IBucketOwnerAccessEnumValue Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IProjectArtifactsInternal.BucketOwnerAccess { get => (this._bucketOwnerAccess = this._bucketOwnerAccess ?? new Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.BucketOwnerAccessEnumValue()); set { {_bucketOwnerAccess = value;} } }

        /// <summary>Internal Acessors for NamespaceType</summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactNamespaceEnumValue Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IProjectArtifactsInternal.NamespaceType { get => (this._namespaceType = this._namespaceType ?? new Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.ArtifactNamespaceEnumValue()); set { {_namespaceType = value;} } }

        /// <summary>Internal Acessors for Packaging</summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactPackagingEnumValue Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IProjectArtifactsInternal.Packaging { get => (this._packaging = this._packaging ?? new Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.ArtifactPackagingEnumValue()); set { {_packaging = value;} } }

        /// <summary>Internal Acessors for Type</summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactsTypeEnumValue Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IProjectArtifactsInternal.Type { get => (this._type = this._type ?? new Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.ArtifactsTypeEnumValue()); set { {_type = value;} } }

        /// <summary>Backing field for <see cref="Name" /> property.</summary>
        private string _name;

        /// <summary>
        /// <p>Along with <code>path</code> and <code>namespaceType</code>, the pattern that CodeBuild uses to name and store the
        /// output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this
        /// value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If
        /// <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is
        /// produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output artifact object.
        /// If you set the name to be a forward slash ('/'), the artifact is stored in the root of the output bucket.</p> </li> </ul>
        /// <p>For example:</p> <ul> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code>
        /// is set to <code>BUILD_ID</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, then the output artifact
        /// is stored in <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>. </p> </li> <li> <p> If <code>path</code> is empty,
        /// <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to '<code>/</code>', the output artifact
        /// is stored in the root of the output bucket. </p> </li> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>,
        /// <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to '<code>/</code>', the output
        /// artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;</code>. </p> </li> </ul>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Owned)]
        public string Name { get => this._name; set => this._name = value; }

        /// <summary>Backing field for <see cref="NamespaceType" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactNamespaceEnumValue _namespaceType;

        /// <summary>
        /// <p>Along with <code>path</code> and <code>name</code>, the pattern that CodeBuild uses to determine the name and location
        /// to store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline
        /// ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p>
        /// </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no
        /// build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p>
        /// <ul> <li> <p> <code>BUILD_ID</code>: Include the build ID in the location of the build output artifact.</p> </li> <li>
        /// <p> <code>NONE</code>: Do not include the build ID. This is the default if <code>namespaceType</code> is not specified.</p>
        /// </li> </ul> </li> </ul> <p>For example, if <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code>
        /// is set to <code>BUILD_ID</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, the output artifact is stored
        /// in <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>.</p>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactNamespaceEnumValue NamespaceType { get => (this._namespaceType = this._namespaceType ?? new Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.ArtifactNamespaceEnumValue()); set => this._namespaceType = value; }

        /// <summary>Property value</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactNamespace? NamespaceTypeValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactNamespaceEnumValueInternal)NamespaceType).Value; set => ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactNamespaceEnumValueInternal)NamespaceType).Value = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactNamespace)""); }

        /// <summary>Backing field for <see cref="OverrideArtifactName" /> property.</summary>
        private bool? _overrideArtifactName;

        /// <summary>
        /// <p> If this flag is set, a name specified in the buildspec file overrides the artifact name. The name specified in a buildspec
        /// file is calculated at build time and uses the Shell Command Language. For example, you can append a date and time to your
        /// artifact name so that it is always unique. </p>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Owned)]
        public bool? OverrideArtifactName { get => this._overrideArtifactName; set => this._overrideArtifactName = value; }

        /// <summary>Backing field for <see cref="Packaging" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactPackagingEnumValue _packaging;

        /// <summary>
        /// <p>The type of build output artifact to create:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>,
        /// CodePipeline ignores this value if specified. This is because CodePipeline manages its build output artifacts instead
        /// of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified,
        /// because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p>
        /// <ul> <li> <p> <code>NONE</code>: CodeBuild creates in the output bucket a folder that contains the build output. This
        /// is the default if <code>packaging</code> is not specified.</p> </li> <li> <p> <code>ZIP</code>: CodeBuild creates in the
        /// output bucket a ZIP file that contains the build output.</p> </li> </ul> </li> </ul>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactPackagingEnumValue Packaging { get => (this._packaging = this._packaging ?? new Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.ArtifactPackagingEnumValue()); set => this._packaging = value; }

        /// <summary>Property value</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactPackaging? PackagingValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactPackagingEnumValueInternal)Packaging).Value; set => ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactPackagingEnumValueInternal)Packaging).Value = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactPackaging)""); }

        /// <summary>Backing field for <see cref="Path" /> property.</summary>
        private string _path;

        /// <summary>
        /// <p>Along with <code>namespaceType</code> and <code>name</code>, the pattern that CodeBuild uses to name and store the
        /// output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this
        /// value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If
        /// <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is
        /// produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the path to the output artifact. If
        /// <code>path</code> is not specified, <code>path</code> is not used.</p> </li> </ul> <p>For example, if <code>path</code>
        /// is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set
        /// to <code>MyArtifact.zip</code>, the output artifact is stored in the output bucket at <code>MyArtifacts/MyArtifact.zip</code>.</p>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Owned)]
        public string Path { get => this._path; set => this._path = value; }

        /// <summary>Backing field for <see cref="Type" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactsTypeEnumValue _type;

        /// <summary>
        /// <p>The type of build output artifact. Valid values include:</p> <ul> <li> <p> <code>CODEPIPELINE</code>: The build project
        /// has build output generated through CodePipeline. </p> <note> <p>The <code>CODEPIPELINE</code> type is not supported for
        /// <code>secondaryArtifacts</code>.</p> </note> </li> <li> <p> <code>NO_ARTIFACTS</code>: The build project does not produce
        /// any build output.</p> </li> <li> <p> <code>S3</code>: The build project stores build output in Amazon S3.</p> </li> </ul>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactsTypeEnumValue Type { get => (this._type = this._type ?? new Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.ArtifactsTypeEnumValue()); set => this._type = value; }

        /// <summary>Property value</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Origin(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactsType? TypeValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactsTypeEnumValueInternal)Type).Value; set => ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactsTypeEnumValueInternal)Type).Value = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactsType)""); }

        /// <summary>Creates an new <see cref="ProjectArtifacts" /> instance.</summary>
        public ProjectArtifacts()
        {

        }
    }
    /// Definition of ProjectArtifacts
    public partial interface IProjectArtifacts :
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.IJsonSerializable
    {
        /// <summary><p> An identifier for this artifact definition. </p></summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<p> An identifier for this artifact definition. </p>",
        SerializedName = @"artifactIdentifier",
        PossibleTypes = new [] { typeof(string) })]
        string ArtifactIdentifier { get; set; }
        /// <summary>Property value</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property value",
        SerializedName = @"value",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.BucketOwnerAccess) })]
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.BucketOwnerAccess? BucketOwnerAccessValue { get; set; }
        /// <summary>
        /// <p> Set to true if you do not want your output artifacts encrypted. This option is valid only if your artifacts type is
        /// Amazon S3. If this is set with another artifacts type, an invalidInputException is thrown. </p>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<p> Set to true if you do not want your output artifacts encrypted. This option is valid only if your artifacts type is Amazon S3. If this is set with another artifacts type, an invalidInputException is thrown. </p>",
        SerializedName = @"encryptionDisabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EncryptionDisabled { get; set; }
        /// <summary>
        /// <p>Information about the build output artifact location:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>,
        /// CodePipeline ignores this value if specified. This is because CodePipeline manages its build output locations instead
        /// of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified,
        /// because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name
        /// of the output bucket.</p> </li> </ul>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<p>Information about the build output artifact location:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output locations instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output bucket.</p> </li> </ul>",
        SerializedName = @"location",
        PossibleTypes = new [] { typeof(string) })]
        string Location { get; set; }
        /// <summary>
        /// <p>Along with <code>path</code> and <code>namespaceType</code>, the pattern that CodeBuild uses to name and store the
        /// output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this
        /// value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If
        /// <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is
        /// produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output artifact object.
        /// If you set the name to be a forward slash ('/'), the artifact is stored in the root of the output bucket.</p> </li> </ul>
        /// <p>For example:</p> <ul> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code>
        /// is set to <code>BUILD_ID</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, then the output artifact
        /// is stored in <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>. </p> </li> <li> <p> If <code>path</code> is empty,
        /// <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to '<code>/</code>', the output artifact
        /// is stored in the root of the output bucket. </p> </li> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>,
        /// <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to '<code>/</code>', the output
        /// artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;</code>. </p> </li> </ul>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<p>Along with <code>path</code> and <code>namespaceType</code>, the pattern that CodeBuild uses to name and store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output artifact object. If you set the name to be a forward slash ('/'), the artifact is stored in the root of the output bucket.</p> </li> </ul> <p>For example:</p> <ul> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, then the output artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>. </p> </li> <li> <p> If <code>path</code> is empty, <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to '<code>/</code>', the output artifact is stored in the root of the output bucket. </p> </li> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to '<code>/</code>', the output artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;</code>. </p> </li> </ul>",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string Name { get; set; }
        /// <summary>Property value</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property value",
        SerializedName = @"value",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactNamespace) })]
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactNamespace? NamespaceTypeValue { get; set; }
        /// <summary>
        /// <p> If this flag is set, a name specified in the buildspec file overrides the artifact name. The name specified in a buildspec
        /// file is calculated at build time and uses the Shell Command Language. For example, you can append a date and time to your
        /// artifact name so that it is always unique. </p>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<p> If this flag is set, a name specified in the buildspec file overrides the artifact name. The name specified in a buildspec file is calculated at build time and uses the Shell Command Language. For example, you can append a date and time to your artifact name so that it is always unique. </p>",
        SerializedName = @"overrideArtifactName",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OverrideArtifactName { get; set; }
        /// <summary>Property value</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property value",
        SerializedName = @"value",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactPackaging) })]
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactPackaging? PackagingValue { get; set; }
        /// <summary>
        /// <p>Along with <code>namespaceType</code> and <code>name</code>, the pattern that CodeBuild uses to name and store the
        /// output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this
        /// value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If
        /// <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is
        /// produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the path to the output artifact. If
        /// <code>path</code> is not specified, <code>path</code> is not used.</p> </li> </ul> <p>For example, if <code>path</code>
        /// is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set
        /// to <code>MyArtifact.zip</code>, the output artifact is stored in the output bucket at <code>MyArtifacts/MyArtifact.zip</code>.</p>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<p>Along with <code>namespaceType</code> and <code>name</code>, the pattern that CodeBuild uses to name and store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the path to the output artifact. If <code>path</code> is not specified, <code>path</code> is not used.</p> </li> </ul> <p>For example, if <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, the output artifact is stored in the output bucket at <code>MyArtifacts/MyArtifact.zip</code>.</p>",
        SerializedName = @"path",
        PossibleTypes = new [] { typeof(string) })]
        string Path { get; set; }
        /// <summary>Property value</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property value",
        SerializedName = @"value",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactsType) })]
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactsType? TypeValue { get; set; }

    }
    /// Definition of ProjectArtifacts
    internal partial interface IProjectArtifactsInternal

    {
        /// <summary><p> An identifier for this artifact definition. </p></summary>
        string ArtifactIdentifier { get; set; }
        /// <summary>Property bucketOwnerAccess</summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IBucketOwnerAccessEnumValue BucketOwnerAccess { get; set; }
        /// <summary>Property value</summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.BucketOwnerAccess? BucketOwnerAccessValue { get; set; }
        /// <summary>
        /// <p> Set to true if you do not want your output artifacts encrypted. This option is valid only if your artifacts type is
        /// Amazon S3. If this is set with another artifacts type, an invalidInputException is thrown. </p>
        /// </summary>
        bool? EncryptionDisabled { get; set; }
        /// <summary>
        /// <p>Information about the build output artifact location:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>,
        /// CodePipeline ignores this value if specified. This is because CodePipeline manages its build output locations instead
        /// of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified,
        /// because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name
        /// of the output bucket.</p> </li> </ul>
        /// </summary>
        string Location { get; set; }
        /// <summary>
        /// <p>Along with <code>path</code> and <code>namespaceType</code>, the pattern that CodeBuild uses to name and store the
        /// output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this
        /// value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If
        /// <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is
        /// produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output artifact object.
        /// If you set the name to be a forward slash ('/'), the artifact is stored in the root of the output bucket.</p> </li> </ul>
        /// <p>For example:</p> <ul> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code>
        /// is set to <code>BUILD_ID</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, then the output artifact
        /// is stored in <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>. </p> </li> <li> <p> If <code>path</code> is empty,
        /// <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to '<code>/</code>', the output artifact
        /// is stored in the root of the output bucket. </p> </li> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>,
        /// <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to '<code>/</code>', the output
        /// artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;</code>. </p> </li> </ul>
        /// </summary>
        string Name { get; set; }
        /// <summary>
        /// <p>Along with <code>path</code> and <code>name</code>, the pattern that CodeBuild uses to determine the name and location
        /// to store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline
        /// ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p>
        /// </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no
        /// build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p>
        /// <ul> <li> <p> <code>BUILD_ID</code>: Include the build ID in the location of the build output artifact.</p> </li> <li>
        /// <p> <code>NONE</code>: Do not include the build ID. This is the default if <code>namespaceType</code> is not specified.</p>
        /// </li> </ul> </li> </ul> <p>For example, if <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code>
        /// is set to <code>BUILD_ID</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, the output artifact is stored
        /// in <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>.</p>
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactNamespaceEnumValue NamespaceType { get; set; }
        /// <summary>Property value</summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactNamespace? NamespaceTypeValue { get; set; }
        /// <summary>
        /// <p> If this flag is set, a name specified in the buildspec file overrides the artifact name. The name specified in a buildspec
        /// file is calculated at build time and uses the Shell Command Language. For example, you can append a date and time to your
        /// artifact name so that it is always unique. </p>
        /// </summary>
        bool? OverrideArtifactName { get; set; }
        /// <summary>
        /// <p>The type of build output artifact to create:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>,
        /// CodePipeline ignores this value if specified. This is because CodePipeline manages its build output artifacts instead
        /// of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified,
        /// because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p>
        /// <ul> <li> <p> <code>NONE</code>: CodeBuild creates in the output bucket a folder that contains the build output. This
        /// is the default if <code>packaging</code> is not specified.</p> </li> <li> <p> <code>ZIP</code>: CodeBuild creates in the
        /// output bucket a ZIP file that contains the build output.</p> </li> </ul> </li> </ul>
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactPackagingEnumValue Packaging { get; set; }
        /// <summary>Property value</summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactPackaging? PackagingValue { get; set; }
        /// <summary>
        /// <p>Along with <code>namespaceType</code> and <code>name</code>, the pattern that CodeBuild uses to name and store the
        /// output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this
        /// value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If
        /// <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is
        /// produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the path to the output artifact. If
        /// <code>path</code> is not specified, <code>path</code> is not used.</p> </li> </ul> <p>For example, if <code>path</code>
        /// is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set
        /// to <code>MyArtifact.zip</code>, the output artifact is stored in the output bucket at <code>MyArtifacts/MyArtifact.zip</code>.</p>
        /// </summary>
        string Path { get; set; }
        /// <summary>
        /// <p>The type of build output artifact. Valid values include:</p> <ul> <li> <p> <code>CODEPIPELINE</code>: The build project
        /// has build output generated through CodePipeline. </p> <note> <p>The <code>CODEPIPELINE</code> type is not supported for
        /// <code>secondaryArtifacts</code>.</p> </note> </li> <li> <p> <code>NO_ARTIFACTS</code>: The build project does not produce
        /// any build output.</p> </li> <li> <p> <code>S3</code>: The build project stores build output in Amazon S3.</p> </li> </ul>
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Models.Api20241201.IArtifactsTypeEnumValue Type { get; set; }
        /// <summary>Property value</summary>
        Microsoft.Azure.PowerShell.Cmdlets.AwsConnector.Support.ArtifactsType? TypeValue { get; set; }

    }
}
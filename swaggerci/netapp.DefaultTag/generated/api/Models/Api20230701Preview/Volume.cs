// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Extensions;

    /// <summary>Volume resource</summary>
    public partial class Volume :
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolume,
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal,
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ITrackedResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ITrackedResource __trackedResource = new Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.TrackedResource();

        /// <summary>
        /// Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public float? ActualThroughputMibp { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ActualThroughputMibp; }

        /// <summary>
        /// Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.AvsDataStore? AvsDataStore { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).AvsDataStore; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).AvsDataStore = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.AvsDataStore)""); }

        /// <summary>Backup Enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? BackupEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BackupEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BackupEnabled = value ?? default(bool); }

        /// <summary>UUID v4 or resource identifier used to identify the Backup.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string BackupId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BackupId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BackupId = value ?? null; }

        /// <summary>Policy Enforced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? BackupPolicyEnforced { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BackupPolicyEnforced; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BackupPolicyEnforced = value ?? default(bool); }

        /// <summary>Backup Policy Resource ID</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string BackupPolicyId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BackupPolicyId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BackupPolicyId = value ?? null; }

        /// <summary>Backup Vault Resource ID</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string BackupVaultId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BackupVaultId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BackupVaultId = value ?? null; }

        /// <summary>Unique Baremetal Tenant Identifier.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string BaremetalTenantId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BaremetalTenantId; }

        /// <summary>Pool Resource Id used in case of creating a volume through volume group</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string CapacityPoolResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CapacityPoolResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CapacityPoolResourceId = value ?? null; }

        /// <summary>
        /// When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process.
        /// When this value is empty/null there is no cloning process currently happening on this volume. This value will update every
        /// 5 minutes during cloning.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public int? CloneProgress { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CloneProgress; }

        /// <summary>Specifies whether Cool Access(tiering) is enabled for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? CoolAccess { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CoolAccess; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CoolAccess = value ?? default(bool); }

        /// <summary>
        /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read
        /// pattern for cool access enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CoolAccessRetrievalPolicy? CoolAccessRetrievalPolicy { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CoolAccessRetrievalPolicy; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CoolAccessRetrievalPolicy = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CoolAccessRetrievalPolicy)""); }

        /// <summary>
        /// Specifies the number of days after which data that is not accessed by clients will be tiered.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public int? CoolnessPeriod { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CoolnessPeriod; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CoolnessPeriod = value ?? default(int); }

        /// <summary>A unique file path for the volume. Used when creating mount targets</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string CreationToken { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CreationToken; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CreationToken = value ; }

        /// <summary>Data store resource unique identifier</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string[] DataStoreResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataStoreResourceId; }

        /// <summary>
        /// Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public long? DefaultGroupQuotaInKiB { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DefaultGroupQuotaInKiB; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DefaultGroupQuotaInKiB = value ?? default(long); }

        /// <summary>
        /// Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public long? DefaultUserQuotaInKiB { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DefaultUserQuotaInKiB; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DefaultUserQuotaInKiB = value ?? default(long); }

        /// <summary>
        /// If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation
        /// has finished. Defaults to false
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? DeleteBaseSnapshot { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DeleteBaseSnapshot; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DeleteBaseSnapshot = value ?? default(bool); }

        /// <summary>Flag indicating whether subvolume operations are enabled on the volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EnableSubvolumes? EnableSubvolume { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).EnableSubvolume; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).EnableSubvolume = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EnableSubvolumes)""); }

        /// <summary>
        /// Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? Encrypted { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).Encrypted; }

        /// <summary>
        /// Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'.
        /// Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EncryptionKeySource? EncryptionKeySource { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).EncryptionKeySource; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).EncryptionKeySource = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EncryptionKeySource)""); }

        /// <summary>Backing field for <see cref="Etag" /> property.</summary>
        private string _etag;

        /// <summary>A unique read-only string that changes whenever the resource is updated.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string Etag { get => this._etag; }

        /// <summary>Export policy rule</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IExportPolicyRule[] ExportPolicyRule { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ExportPolicyRule; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ExportPolicyRule = value ?? null /* arrayOf */; }

        /// <summary>
        /// Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the
        /// volume.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs? FileAccessLog { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).FileAccessLog; }

        /// <summary>Unique FileSystem Identifier.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string FileSystemId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).FileSystemId; }

        /// <summary>Volume Group Name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string GroupName { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeGroupName; }

        /// <summary>
        /// Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).Id; }

        /// <summary>Space shared by short term clone volume with parent volume in bytes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public long? InheritedSizeInByte { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).InheritedSizeInByte; }

        /// <summary>Specifies if default quota is enabled for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? IsDefaultQuotaEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).IsDefaultQuotaEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).IsDefaultQuotaEnabled = value ?? default(bool); }

        /// <summary>Specifies whether volume is a Large Volume or Regular Volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? IsLargeVolume { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).IsLargeVolume; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).IsLargeVolume = value ?? default(bool); }

        /// <summary>Restoring</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? IsRestoring { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).IsRestoring; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).IsRestoring = value ?? default(bool); }

        /// <summary>
        /// Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? KerberosEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).KerberosEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).KerberosEnabled = value ?? default(bool); }

        /// <summary>
        /// The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource
        /// = 'Microsoft.KeyVault'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string KeyVaultPrivateEndpointResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).KeyVaultPrivateEndpointResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).KeyVaultPrivateEndpointResourceId = value ?? null; }

        /// <summary>Specifies whether LDAP is enabled or not for a given NFS volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? LdapEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).LdapEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).LdapEnabled = value ?? default(bool); }

        /// <summary>The geo-location where the resource lives</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public string Location { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ITrackedResourceInternal)__trackedResource).Location; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ITrackedResourceInternal)__trackedResource).Location = value ; }

        /// <summary>
        /// Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume
        /// quota is more than 4TiB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public long? MaximumNumberOfFile { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).MaximumNumberOfFile; }

        /// <summary>Internal Acessors for ActualThroughputMibp</summary>
        float? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.ActualThroughputMibp { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ActualThroughputMibp; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ActualThroughputMibp = value; }

        /// <summary>Internal Acessors for BaremetalTenantId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.BaremetalTenantId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BaremetalTenantId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).BaremetalTenantId = value; }

        /// <summary>Internal Acessors for CloneProgress</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.CloneProgress { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CloneProgress; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).CloneProgress = value; }

        /// <summary>Internal Acessors for DataProtection</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtection Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.DataProtection { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataProtection; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataProtection = value; }

        /// <summary>Internal Acessors for DataProtectionBackup</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeBackupProperties Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.DataProtectionBackup { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataProtectionBackup; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataProtectionBackup = value; }

        /// <summary>Internal Acessors for DataProtectionReplication</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IReplicationObject Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.DataProtectionReplication { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataProtectionReplication; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataProtectionReplication = value; }

        /// <summary>Internal Acessors for DataProtectionSnapshot</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeSnapshotProperties Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.DataProtectionSnapshot { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataProtectionSnapshot; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataProtectionSnapshot = value; }

        /// <summary>Internal Acessors for DataProtectionVolumeRelocation</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeRelocationProperties Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.DataProtectionVolumeRelocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataProtectionVolumeRelocation; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataProtectionVolumeRelocation = value; }

        /// <summary>Internal Acessors for DataStoreResourceId</summary>
        string[] Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.DataStoreResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataStoreResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).DataStoreResourceId = value; }

        /// <summary>Internal Acessors for Encrypted</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.Encrypted { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).Encrypted; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).Encrypted = value; }

        /// <summary>Internal Acessors for Etag</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.Etag { get => this._etag; set { {_etag = value;} } }

        /// <summary>Internal Acessors for ExportPolicy</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesExportPolicy Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.ExportPolicy { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ExportPolicy; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ExportPolicy = value; }

        /// <summary>Internal Acessors for FileAccessLog</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.FileAccessLog { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).FileAccessLog; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).FileAccessLog = value; }

        /// <summary>Internal Acessors for FileSystemId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.FileSystemId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).FileSystemId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).FileSystemId = value; }

        /// <summary>Internal Acessors for GroupName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.GroupName { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeGroupName; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeGroupName = value; }

        /// <summary>Internal Acessors for InheritedSizeInByte</summary>
        long? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.InheritedSizeInByte { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).InheritedSizeInByte; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).InheritedSizeInByte = value; }

        /// <summary>Internal Acessors for MaximumNumberOfFile</summary>
        long? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.MaximumNumberOfFile { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).MaximumNumberOfFile; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).MaximumNumberOfFile = value; }

        /// <summary>Internal Acessors for MountTarget</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties[] Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.MountTarget { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).MountTarget; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).MountTarget = value; }

        /// <summary>Internal Acessors for NetworkSiblingSetId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.NetworkSiblingSetId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).NetworkSiblingSetId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).NetworkSiblingSetId = value; }

        /// <summary>Internal Acessors for OriginatingResourceId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.OriginatingResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).OriginatingResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).OriginatingResourceId = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeProperties Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.VolumeProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for ProvisionedAvailabilityZone</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.ProvisionedAvailabilityZone { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ProvisionedAvailabilityZone; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ProvisionedAvailabilityZone = value; }

        /// <summary>Internal Acessors for ProvisioningState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.ProvisioningState { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ProvisioningState; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ProvisioningState = value; }

        /// <summary>Internal Acessors for RelocationReadyToBeFinalized</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.RelocationReadyToBeFinalized { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeRelocationReadyToBeFinalized; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeRelocationReadyToBeFinalized = value; }

        /// <summary>Internal Acessors for ReplicationId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.ReplicationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationId = value; }

        /// <summary>Internal Acessors for ReplicationRemotePath</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IRemotePath Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.ReplicationRemotePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationRemotePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationRemotePath = value; }

        /// <summary>Internal Acessors for StorageToNetworkProximity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.StorageToNetworkProximity { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).StorageToNetworkProximity; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).StorageToNetworkProximity = value; }

        /// <summary>Internal Acessors for T2Network</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeInternal.T2Network { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).T2Network; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).T2Network = value; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).Name = value; }

        /// <summary>Internal Acessors for SystemData</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ISystemData Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal.SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemData; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemData = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).Type = value; }

        /// <summary>List of mount targets</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties[] MountTarget { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).MountTarget; }

        /// <summary>The name of the resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).Name; }

        /// <summary>Network features available to the volume, or current state of update.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.NetworkFeatures? NetworkFeature { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).NetworkFeature; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).NetworkFeature = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.NetworkFeatures)""); }

        /// <summary>
        /// Network Sibling Set ID for the the group of volumes sharing networking resources.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string NetworkSiblingSetId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).NetworkSiblingSetId; }

        /// <summary>Id of the snapshot or backup that the volume is restored from.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string OriginatingResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).OriginatingResourceId; }

        /// <summary>Application specific placement rules for the particular volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IPlacementKeyValuePairs[] PlacementRule { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).PlacementRule; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).PlacementRule = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeProperties _property;

        /// <summary>Volume properties</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.VolumeProperties()); set => this._property = value; }

        /// <summary>Set of protocol types, default NFSv3, CIFS for SMB protocol</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string[] ProtocolType { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ProtocolType; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ProtocolType = value ?? null /* arrayOf */; }

        /// <summary>
        /// The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string ProvisionedAvailabilityZone { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ProvisionedAvailabilityZone; }

        /// <summary>Azure lifecycle management</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string ProvisioningState { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ProvisioningState; }

        /// <summary>Proximity placement group associated with the volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string ProximityPlacementGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ProximityPlacementGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ProximityPlacementGroup = value ?? null; }

        /// <summary>Has relocation finished and is ready to be cleaned up</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? RelocationReadyToBeFinalized { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeRelocationReadyToBeFinalized; }

        /// <summary>Has relocation been requested for this volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? RelocationRequested { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeRelocationRequested; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeRelocationRequested = value ?? default(bool); }

        /// <summary>The Path to a ONTAP Host</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string RemotePathExternalHostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).RemotePathExternalHostName; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).RemotePathExternalHostName = value ?? null; }

        /// <summary>The name of a server on the ONTAP Host</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string RemotePathServerName { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).RemotePathServerName; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).RemotePathServerName = value ?? null; }

        /// <summary>The name of a volume on the server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string RemotePathVolumeName { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).RemotePathVolumeName; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).RemotePathVolumeName = value ?? null; }

        /// <summary>
        /// Indicates whether the local volume is the source or destination for the Volume Replication
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EndpointType? ReplicationEndpointType { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationEndpointType; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationEndpointType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EndpointType)""); }

        /// <summary>Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string ReplicationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationId; }

        /// <summary>The remote region for the other end of the Volume Replication.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string ReplicationRemoteVolumeRegion { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationRemoteVolumeRegion; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationRemoteVolumeRegion = value ?? null; }

        /// <summary>
        /// The resource ID of the remote volume. Required for cross region and cross zone replication
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string ReplicationRemoteVolumeResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationRemoteVolumeResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationRemoteVolumeResourceId = value ?? null; }

        /// <summary>Schedule</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ReplicationSchedule? ReplicationSchedule { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationSchedule; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ReplicationSchedule = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ReplicationSchedule)""); }

        /// <summary>
        /// The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SecurityStyle? SecurityStyle { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SecurityStyle; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SecurityStyle = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SecurityStyle)""); }

        /// <summary>The service level of the file system</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ServiceLevel? ServiceLevel { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ServiceLevel; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ServiceLevel = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ServiceLevel)""); }

        /// <summary>
        /// Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbAccessBasedEnumeration? SmbAccessBasedEnumeration { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SmbAccessBasedEnumeration; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SmbAccessBasedEnumeration = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbAccessBasedEnumeration)""); }

        /// <summary>
        /// Enables continuously available share property for smb volume. Only applicable for SMB volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? SmbContinuouslyAvailable { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SmbContinuouslyAvailable; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SmbContinuouslyAvailable = value ?? default(bool); }

        /// <summary>
        /// Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version
        /// 2020-08-01 or later
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? SmbEncryption { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SmbEncryption; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SmbEncryption = value ?? default(bool); }

        /// <summary>
        /// Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbNonBrowsable? SmbNonBrowsable { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SmbNonBrowsable; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SmbNonBrowsable = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbNonBrowsable)""); }

        /// <summary>
        /// If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's
        /// snapshots (defaults to true).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? SnapshotDirectoryVisible { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SnapshotDirectoryVisible; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SnapshotDirectoryVisible = value ?? default(bool); }

        /// <summary>UUID v4 or resource identifier used to identify the Snapshot.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string SnapshotId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SnapshotId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SnapshotId = value ?? null; }

        /// <summary>Snapshot Policy ResourceId</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string SnapshotPolicyId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SnapshotPolicyId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SnapshotPolicyId = value ?? null; }

        /// <summary>
        /// Volume spec name is the application specific designation or identifier for the particular volume in a volume group for
        /// e.g. data, log
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string SpecName { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeSpecName; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeSpecName = value ?? null; }

        /// <summary>Provides storage to network proximity information for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity? StorageToNetworkProximity { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).StorageToNetworkProximity; }

        /// <summary>
        /// The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string SubnetId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SubnetId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).SubnetId = value ; }

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ISystemData SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemData; }

        /// <summary>The timestamp of resource creation (UTC).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataCreatedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataCreatedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public string SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataCreatedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataCreatedBy = value ?? null; }

        /// <summary>The type of identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CreatedByType? SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataCreatedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataCreatedByType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CreatedByType)""); }

        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataLastModifiedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataLastModifiedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataLastModifiedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataLastModifiedBy = value ?? null; }

        /// <summary>The type of identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CreatedByType? SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataLastModifiedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).SystemDataLastModifiedByType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CreatedByType)""); }

        /// <summary>T2 network information</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string T2Network { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).T2Network; }

        /// <summary>Resource tags.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ITrackedResourceTags Tag { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ITrackedResourceInternal)__trackedResource).Tag; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ITrackedResourceInternal)__trackedResource).Tag = value ?? null /* model class */; }

        /// <summary>
        /// Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType
        /// volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public float? ThroughputMibp { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ThroughputMibp; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).ThroughputMibp = value ?? default(float); }

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.IResourceInternal)__trackedResource).Type; }

        /// <summary>
        /// UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID
        /// (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute
        /// (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 -
        /// gives read/write/execute permissions to owner and read/execute to group and other users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string UnixPermission { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).UnixPermission; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).UnixPermission = value ?? null; }

        /// <summary>
        /// Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is
        /// 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public long UsageThreshold { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).UsageThreshold; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).UsageThreshold = value ; }

        /// <summary>
        /// What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating
        /// clone volume, set type to ShortTermClone
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string VolumeType { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeType; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal)Property).VolumeType = value ?? null; }

        /// <summary>Backing field for <see cref="Zone" /> property.</summary>
        private string[] _zone;

        /// <summary>Availability Zone</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string[] Zone { get => this._zone; set => this._zone = value; }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__trackedResource), __trackedResource);
            await eventListener.AssertObjectIsValid(nameof(__trackedResource), __trackedResource);
        }

        /// <summary>Creates an new <see cref="Volume" /> instance.</summary>
        public Volume()
        {

        }
    }
    /// Volume resource
    public partial interface IVolume :
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ITrackedResource
    {
        /// <summary>
        /// Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel",
        SerializedName = @"actualThroughputMibps",
        PossibleTypes = new [] { typeof(float) })]
        float? ActualThroughputMibp { get;  }
        /// <summary>
        /// Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose",
        SerializedName = @"avsDataStore",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.AvsDataStore) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.AvsDataStore? AvsDataStore { get; set; }
        /// <summary>Backup Enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Backup Enabled",
        SerializedName = @"backupEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupEnabled { get; set; }
        /// <summary>UUID v4 or resource identifier used to identify the Backup.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"UUID v4 or resource identifier used to identify the Backup.",
        SerializedName = @"backupId",
        PossibleTypes = new [] { typeof(string) })]
        string BackupId { get; set; }
        /// <summary>Policy Enforced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Policy Enforced",
        SerializedName = @"policyEnforced",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupPolicyEnforced { get; set; }
        /// <summary>Backup Policy Resource ID</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Backup Policy Resource ID",
        SerializedName = @"backupPolicyId",
        PossibleTypes = new [] { typeof(string) })]
        string BackupPolicyId { get; set; }
        /// <summary>Backup Vault Resource ID</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Backup Vault Resource ID",
        SerializedName = @"backupVaultId",
        PossibleTypes = new [] { typeof(string) })]
        string BackupVaultId { get; set; }
        /// <summary>Unique Baremetal Tenant Identifier.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Unique Baremetal Tenant Identifier.",
        SerializedName = @"baremetalTenantId",
        PossibleTypes = new [] { typeof(string) })]
        string BaremetalTenantId { get;  }
        /// <summary>Pool Resource Id used in case of creating a volume through volume group</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Pool Resource Id used in case of creating a volume through volume group",
        SerializedName = @"capacityPoolResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string CapacityPoolResourceId { get; set; }
        /// <summary>
        /// When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process.
        /// When this value is empty/null there is no cloning process currently happening on this volume. This value will update every
        /// 5 minutes during cloning.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.",
        SerializedName = @"cloneProgress",
        PossibleTypes = new [] { typeof(int) })]
        int? CloneProgress { get;  }
        /// <summary>Specifies whether Cool Access(tiering) is enabled for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether Cool Access(tiering) is enabled for the volume.",
        SerializedName = @"coolAccess",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CoolAccess { get; set; }
        /// <summary>
        /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read
        /// pattern for cool access enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are:
         Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
         OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
         Never - No client-driven data is pulled from cool tier to standard storage.",
        SerializedName = @"coolAccessRetrievalPolicy",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CoolAccessRetrievalPolicy) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CoolAccessRetrievalPolicy? CoolAccessRetrievalPolicy { get; set; }
        /// <summary>
        /// Specifies the number of days after which data that is not accessed by clients will be tiered.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the number of days after which data that is not accessed by clients will be tiered.",
        SerializedName = @"coolnessPeriod",
        PossibleTypes = new [] { typeof(int) })]
        int? CoolnessPeriod { get; set; }
        /// <summary>A unique file path for the volume. Used when creating mount targets</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"A unique file path for the volume. Used when creating mount targets",
        SerializedName = @"creationToken",
        PossibleTypes = new [] { typeof(string) })]
        string CreationToken { get; set; }
        /// <summary>Data store resource unique identifier</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Data store resource unique identifier",
        SerializedName = @"dataStoreResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string[] DataStoreResourceId { get;  }
        /// <summary>
        /// Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.",
        SerializedName = @"defaultGroupQuotaInKiBs",
        PossibleTypes = new [] { typeof(long) })]
        long? DefaultGroupQuotaInKiB { get; set; }
        /// <summary>
        /// Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .",
        SerializedName = @"defaultUserQuotaInKiBs",
        PossibleTypes = new [] { typeof(long) })]
        long? DefaultUserQuotaInKiB { get; set; }
        /// <summary>
        /// If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation
        /// has finished. Defaults to false
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false",
        SerializedName = @"deleteBaseSnapshot",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DeleteBaseSnapshot { get; set; }
        /// <summary>Flag indicating whether subvolume operations are enabled on the volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Flag indicating whether subvolume operations are enabled on the volume",
        SerializedName = @"enableSubvolumes",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EnableSubvolumes) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EnableSubvolumes? EnableSubvolume { get; set; }
        /// <summary>
        /// Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.",
        SerializedName = @"encrypted",
        PossibleTypes = new [] { typeof(bool) })]
        bool? Encrypted { get;  }
        /// <summary>
        /// Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'.
        /// Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'",
        SerializedName = @"encryptionKeySource",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EncryptionKeySource) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EncryptionKeySource? EncryptionKeySource { get; set; }
        /// <summary>A unique read-only string that changes whenever the resource is updated.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"A unique read-only string that changes whenever the resource is updated.",
        SerializedName = @"etag",
        PossibleTypes = new [] { typeof(string) })]
        string Etag { get;  }
        /// <summary>Export policy rule</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Export policy rule",
        SerializedName = @"rules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IExportPolicyRule) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IExportPolicyRule[] ExportPolicyRule { get; set; }
        /// <summary>
        /// Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the
        /// volume.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume.",
        SerializedName = @"fileAccessLogs",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs? FileAccessLog { get;  }
        /// <summary>Unique FileSystem Identifier.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Unique FileSystem Identifier.",
        SerializedName = @"fileSystemId",
        PossibleTypes = new [] { typeof(string) })]
        string FileSystemId { get;  }
        /// <summary>Volume Group Name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Volume Group Name",
        SerializedName = @"volumeGroupName",
        PossibleTypes = new [] { typeof(string) })]
        string GroupName { get;  }
        /// <summary>Space shared by short term clone volume with parent volume in bytes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Space shared by short term clone volume with parent volume in bytes.",
        SerializedName = @"inheritedSizeInBytes",
        PossibleTypes = new [] { typeof(long) })]
        long? InheritedSizeInByte { get;  }
        /// <summary>Specifies if default quota is enabled for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies if default quota is enabled for the volume.",
        SerializedName = @"isDefaultQuotaEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsDefaultQuotaEnabled { get; set; }
        /// <summary>Specifies whether volume is a Large Volume or Regular Volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether volume is a Large Volume or Regular Volume.",
        SerializedName = @"isLargeVolume",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsLargeVolume { get; set; }
        /// <summary>Restoring</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Restoring",
        SerializedName = @"isRestoring",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsRestoring { get; set; }
        /// <summary>
        /// Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later",
        SerializedName = @"kerberosEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? KerberosEnabled { get; set; }
        /// <summary>
        /// The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource
        /// = 'Microsoft.KeyVault'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.",
        SerializedName = @"keyVaultPrivateEndpointResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string KeyVaultPrivateEndpointResourceId { get; set; }
        /// <summary>Specifies whether LDAP is enabled or not for a given NFS volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether LDAP is enabled or not for a given NFS volume.",
        SerializedName = @"ldapEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LdapEnabled { get; set; }
        /// <summary>
        /// Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume
        /// quota is more than 4TiB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.",
        SerializedName = @"maximumNumberOfFiles",
        PossibleTypes = new [] { typeof(long) })]
        long? MaximumNumberOfFile { get;  }
        /// <summary>List of mount targets</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"List of mount targets",
        SerializedName = @"mountTargets",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties[] MountTarget { get;  }
        /// <summary>Network features available to the volume, or current state of update.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Network features available to the volume, or current state of update.",
        SerializedName = @"networkFeatures",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.NetworkFeatures) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.NetworkFeatures? NetworkFeature { get; set; }
        /// <summary>
        /// Network Sibling Set ID for the the group of volumes sharing networking resources.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Network Sibling Set ID for the the group of volumes sharing networking resources.",
        SerializedName = @"networkSiblingSetId",
        PossibleTypes = new [] { typeof(string) })]
        string NetworkSiblingSetId { get;  }
        /// <summary>Id of the snapshot or backup that the volume is restored from.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Id of the snapshot or backup that the volume is restored from.",
        SerializedName = @"originatingResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string OriginatingResourceId { get;  }
        /// <summary>Application specific placement rules for the particular volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Application specific placement rules for the particular volume",
        SerializedName = @"placementRules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IPlacementKeyValuePairs) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IPlacementKeyValuePairs[] PlacementRule { get; set; }
        /// <summary>Set of protocol types, default NFSv3, CIFS for SMB protocol</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Set of protocol types, default NFSv3, CIFS for SMB protocol",
        SerializedName = @"protocolTypes",
        PossibleTypes = new [] { typeof(string) })]
        string[] ProtocolType { get; set; }
        /// <summary>
        /// The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.",
        SerializedName = @"provisionedAvailabilityZone",
        PossibleTypes = new [] { typeof(string) })]
        string ProvisionedAvailabilityZone { get;  }
        /// <summary>Azure lifecycle management</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Azure lifecycle management",
        SerializedName = @"provisioningState",
        PossibleTypes = new [] { typeof(string) })]
        string ProvisioningState { get;  }
        /// <summary>Proximity placement group associated with the volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Proximity placement group associated with the volume",
        SerializedName = @"proximityPlacementGroup",
        PossibleTypes = new [] { typeof(string) })]
        string ProximityPlacementGroup { get; set; }
        /// <summary>Has relocation finished and is ready to be cleaned up</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Has relocation finished and is ready to be cleaned up",
        SerializedName = @"readyToBeFinalized",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RelocationReadyToBeFinalized { get;  }
        /// <summary>Has relocation been requested for this volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Has relocation been requested for this volume",
        SerializedName = @"relocationRequested",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RelocationRequested { get; set; }
        /// <summary>The Path to a ONTAP Host</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Path to a ONTAP Host",
        SerializedName = @"externalHostName",
        PossibleTypes = new [] { typeof(string) })]
        string RemotePathExternalHostName { get; set; }
        /// <summary>The name of a server on the ONTAP Host</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of a server on the ONTAP Host",
        SerializedName = @"serverName",
        PossibleTypes = new [] { typeof(string) })]
        string RemotePathServerName { get; set; }
        /// <summary>The name of a volume on the server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of a volume on the server",
        SerializedName = @"volumeName",
        PossibleTypes = new [] { typeof(string) })]
        string RemotePathVolumeName { get; set; }
        /// <summary>
        /// Indicates whether the local volume is the source or destination for the Volume Replication
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the local volume is the source or destination for the Volume Replication",
        SerializedName = @"endpointType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EndpointType) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EndpointType? ReplicationEndpointType { get; set; }
        /// <summary>Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Id",
        SerializedName = @"replicationId",
        PossibleTypes = new [] { typeof(string) })]
        string ReplicationId { get;  }
        /// <summary>The remote region for the other end of the Volume Replication.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The remote region for the other end of the Volume Replication.",
        SerializedName = @"remoteVolumeRegion",
        PossibleTypes = new [] { typeof(string) })]
        string ReplicationRemoteVolumeRegion { get; set; }
        /// <summary>
        /// The resource ID of the remote volume. Required for cross region and cross zone replication
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource ID of the remote volume. Required for cross region and cross zone replication",
        SerializedName = @"remoteVolumeResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string ReplicationRemoteVolumeResourceId { get; set; }
        /// <summary>Schedule</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Schedule",
        SerializedName = @"replicationSchedule",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ReplicationSchedule) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ReplicationSchedule? ReplicationSchedule { get; set; }
        /// <summary>
        /// The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol",
        SerializedName = @"securityStyle",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SecurityStyle) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SecurityStyle? SecurityStyle { get; set; }
        /// <summary>The service level of the file system</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The service level of the file system",
        SerializedName = @"serviceLevel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ServiceLevel) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ServiceLevel? ServiceLevel { get; set; }
        /// <summary>
        /// Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume",
        SerializedName = @"smbAccessBasedEnumeration",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbAccessBasedEnumeration) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbAccessBasedEnumeration? SmbAccessBasedEnumeration { get; set; }
        /// <summary>
        /// Enables continuously available share property for smb volume. Only applicable for SMB volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables continuously available share property for smb volume. Only applicable for SMB volume",
        SerializedName = @"smbContinuouslyAvailable",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SmbContinuouslyAvailable { get; set; }
        /// <summary>
        /// Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version
        /// 2020-08-01 or later
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later",
        SerializedName = @"smbEncryption",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SmbEncryption { get; set; }
        /// <summary>
        /// Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume",
        SerializedName = @"smbNonBrowsable",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbNonBrowsable) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbNonBrowsable? SmbNonBrowsable { get; set; }
        /// <summary>
        /// If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's
        /// snapshots (defaults to true).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).",
        SerializedName = @"snapshotDirectoryVisible",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotDirectoryVisible { get; set; }
        /// <summary>UUID v4 or resource identifier used to identify the Snapshot.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"UUID v4 or resource identifier used to identify the Snapshot.",
        SerializedName = @"snapshotId",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotId { get; set; }
        /// <summary>Snapshot Policy ResourceId</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Snapshot Policy ResourceId",
        SerializedName = @"snapshotPolicyId",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotPolicyId { get; set; }
        /// <summary>
        /// Volume spec name is the application specific designation or identifier for the particular volume in a volume group for
        /// e.g. data, log
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log",
        SerializedName = @"volumeSpecName",
        PossibleTypes = new [] { typeof(string) })]
        string SpecName { get; set; }
        /// <summary>Provides storage to network proximity information for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Provides storage to network proximity information for the volume.",
        SerializedName = @"storageToNetworkProximity",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity? StorageToNetworkProximity { get;  }
        /// <summary>
        /// The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes",
        SerializedName = @"subnetId",
        PossibleTypes = new [] { typeof(string) })]
        string SubnetId { get; set; }
        /// <summary>T2 network information</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"T2 network information",
        SerializedName = @"t2Network",
        PossibleTypes = new [] { typeof(string) })]
        string T2Network { get;  }
        /// <summary>
        /// Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType
        /// volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType volume",
        SerializedName = @"throughputMibps",
        PossibleTypes = new [] { typeof(float) })]
        float? ThroughputMibp { get; set; }
        /// <summary>
        /// UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID
        /// (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute
        /// (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 -
        /// gives read/write/execute permissions to owner and read/execute to group and other users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.",
        SerializedName = @"unixPermissions",
        PossibleTypes = new [] { typeof(string) })]
        string UnixPermission { get; set; }
        /// <summary>
        /// Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is
        /// 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.",
        SerializedName = @"usageThreshold",
        PossibleTypes = new [] { typeof(long) })]
        long UsageThreshold { get; set; }
        /// <summary>
        /// What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating
        /// clone volume, set type to ShortTermClone
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating clone volume, set type to ShortTermClone",
        SerializedName = @"volumeType",
        PossibleTypes = new [] { typeof(string) })]
        string VolumeType { get; set; }
        /// <summary>Availability Zone</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Availability Zone",
        SerializedName = @"zones",
        PossibleTypes = new [] { typeof(string) })]
        string[] Zone { get; set; }

    }
    /// Volume resource
    internal partial interface IVolumeInternal :
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api40.ITrackedResourceInternal
    {
        /// <summary>
        /// Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        /// </summary>
        float? ActualThroughputMibp { get; set; }
        /// <summary>
        /// Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.AvsDataStore? AvsDataStore { get; set; }
        /// <summary>Backup Enabled</summary>
        bool? BackupEnabled { get; set; }
        /// <summary>UUID v4 or resource identifier used to identify the Backup.</summary>
        string BackupId { get; set; }
        /// <summary>Policy Enforced</summary>
        bool? BackupPolicyEnforced { get; set; }
        /// <summary>Backup Policy Resource ID</summary>
        string BackupPolicyId { get; set; }
        /// <summary>Backup Vault Resource ID</summary>
        string BackupVaultId { get; set; }
        /// <summary>Unique Baremetal Tenant Identifier.</summary>
        string BaremetalTenantId { get; set; }
        /// <summary>Pool Resource Id used in case of creating a volume through volume group</summary>
        string CapacityPoolResourceId { get; set; }
        /// <summary>
        /// When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process.
        /// When this value is empty/null there is no cloning process currently happening on this volume. This value will update every
        /// 5 minutes during cloning.
        /// </summary>
        int? CloneProgress { get; set; }
        /// <summary>Specifies whether Cool Access(tiering) is enabled for the volume.</summary>
        bool? CoolAccess { get; set; }
        /// <summary>
        /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read
        /// pattern for cool access enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CoolAccessRetrievalPolicy? CoolAccessRetrievalPolicy { get; set; }
        /// <summary>
        /// Specifies the number of days after which data that is not accessed by clients will be tiered.
        /// </summary>
        int? CoolnessPeriod { get; set; }
        /// <summary>A unique file path for the volume. Used when creating mount targets</summary>
        string CreationToken { get; set; }
        /// <summary>
        /// DataProtection type volumes include an object containing details of the replication
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtection DataProtection { get; set; }
        /// <summary>Backup Properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeBackupProperties DataProtectionBackup { get; set; }
        /// <summary>Replication properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IReplicationObject DataProtectionReplication { get; set; }
        /// <summary>Snapshot properties.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeSnapshotProperties DataProtectionSnapshot { get; set; }
        /// <summary>VolumeRelocation properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeRelocationProperties DataProtectionVolumeRelocation { get; set; }
        /// <summary>Data store resource unique identifier</summary>
        string[] DataStoreResourceId { get; set; }
        /// <summary>
        /// Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        /// </summary>
        long? DefaultGroupQuotaInKiB { get; set; }
        /// <summary>
        /// Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        /// </summary>
        long? DefaultUserQuotaInKiB { get; set; }
        /// <summary>
        /// If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation
        /// has finished. Defaults to false
        /// </summary>
        bool? DeleteBaseSnapshot { get; set; }
        /// <summary>Flag indicating whether subvolume operations are enabled on the volume</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EnableSubvolumes? EnableSubvolume { get; set; }
        /// <summary>
        /// Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        /// </summary>
        bool? Encrypted { get; set; }
        /// <summary>
        /// Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'.
        /// Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EncryptionKeySource? EncryptionKeySource { get; set; }
        /// <summary>A unique read-only string that changes whenever the resource is updated.</summary>
        string Etag { get; set; }
        /// <summary>Set of export policy rules</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesExportPolicy ExportPolicy { get; set; }
        /// <summary>Export policy rule</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IExportPolicyRule[] ExportPolicyRule { get; set; }
        /// <summary>
        /// Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the
        /// volume.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs? FileAccessLog { get; set; }
        /// <summary>Unique FileSystem Identifier.</summary>
        string FileSystemId { get; set; }
        /// <summary>Volume Group Name</summary>
        string GroupName { get; set; }
        /// <summary>Space shared by short term clone volume with parent volume in bytes.</summary>
        long? InheritedSizeInByte { get; set; }
        /// <summary>Specifies if default quota is enabled for the volume.</summary>
        bool? IsDefaultQuotaEnabled { get; set; }
        /// <summary>Specifies whether volume is a Large Volume or Regular Volume.</summary>
        bool? IsLargeVolume { get; set; }
        /// <summary>Restoring</summary>
        bool? IsRestoring { get; set; }
        /// <summary>
        /// Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        /// </summary>
        bool? KerberosEnabled { get; set; }
        /// <summary>
        /// The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource
        /// = 'Microsoft.KeyVault'.
        /// </summary>
        string KeyVaultPrivateEndpointResourceId { get; set; }
        /// <summary>Specifies whether LDAP is enabled or not for a given NFS volume.</summary>
        bool? LdapEnabled { get; set; }
        /// <summary>
        /// Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume
        /// quota is more than 4TiB.
        /// </summary>
        long? MaximumNumberOfFile { get; set; }
        /// <summary>List of mount targets</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties[] MountTarget { get; set; }
        /// <summary>Network features available to the volume, or current state of update.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.NetworkFeatures? NetworkFeature { get; set; }
        /// <summary>
        /// Network Sibling Set ID for the the group of volumes sharing networking resources.
        /// </summary>
        string NetworkSiblingSetId { get; set; }
        /// <summary>Id of the snapshot or backup that the volume is restored from.</summary>
        string OriginatingResourceId { get; set; }
        /// <summary>Application specific placement rules for the particular volume</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IPlacementKeyValuePairs[] PlacementRule { get; set; }
        /// <summary>Volume properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeProperties Property { get; set; }
        /// <summary>Set of protocol types, default NFSv3, CIFS for SMB protocol</summary>
        string[] ProtocolType { get; set; }
        /// <summary>
        /// The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        /// </summary>
        string ProvisionedAvailabilityZone { get; set; }
        /// <summary>Azure lifecycle management</summary>
        string ProvisioningState { get; set; }
        /// <summary>Proximity placement group associated with the volume</summary>
        string ProximityPlacementGroup { get; set; }
        /// <summary>Has relocation finished and is ready to be cleaned up</summary>
        bool? RelocationReadyToBeFinalized { get; set; }
        /// <summary>Has relocation been requested for this volume</summary>
        bool? RelocationRequested { get; set; }
        /// <summary>The Path to a ONTAP Host</summary>
        string RemotePathExternalHostName { get; set; }
        /// <summary>The name of a server on the ONTAP Host</summary>
        string RemotePathServerName { get; set; }
        /// <summary>The name of a volume on the server</summary>
        string RemotePathVolumeName { get; set; }
        /// <summary>
        /// Indicates whether the local volume is the source or destination for the Volume Replication
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EndpointType? ReplicationEndpointType { get; set; }
        /// <summary>Id</summary>
        string ReplicationId { get; set; }
        /// <summary>
        /// The full path to a volume that is to be migrated into ANF. Required for Migration volumes
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IRemotePath ReplicationRemotePath { get; set; }
        /// <summary>The remote region for the other end of the Volume Replication.</summary>
        string ReplicationRemoteVolumeRegion { get; set; }
        /// <summary>
        /// The resource ID of the remote volume. Required for cross region and cross zone replication
        /// </summary>
        string ReplicationRemoteVolumeResourceId { get; set; }
        /// <summary>Schedule</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ReplicationSchedule? ReplicationSchedule { get; set; }
        /// <summary>
        /// The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SecurityStyle? SecurityStyle { get; set; }
        /// <summary>The service level of the file system</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ServiceLevel? ServiceLevel { get; set; }
        /// <summary>
        /// Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbAccessBasedEnumeration? SmbAccessBasedEnumeration { get; set; }
        /// <summary>
        /// Enables continuously available share property for smb volume. Only applicable for SMB volume
        /// </summary>
        bool? SmbContinuouslyAvailable { get; set; }
        /// <summary>
        /// Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version
        /// 2020-08-01 or later
        /// </summary>
        bool? SmbEncryption { get; set; }
        /// <summary>
        /// Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbNonBrowsable? SmbNonBrowsable { get; set; }
        /// <summary>
        /// If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's
        /// snapshots (defaults to true).
        /// </summary>
        bool? SnapshotDirectoryVisible { get; set; }
        /// <summary>UUID v4 or resource identifier used to identify the Snapshot.</summary>
        string SnapshotId { get; set; }
        /// <summary>Snapshot Policy ResourceId</summary>
        string SnapshotPolicyId { get; set; }
        /// <summary>
        /// Volume spec name is the application specific designation or identifier for the particular volume in a volume group for
        /// e.g. data, log
        /// </summary>
        string SpecName { get; set; }
        /// <summary>Provides storage to network proximity information for the volume.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity? StorageToNetworkProximity { get; set; }
        /// <summary>
        /// The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        /// </summary>
        string SubnetId { get; set; }
        /// <summary>T2 network information</summary>
        string T2Network { get; set; }
        /// <summary>
        /// Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType
        /// volume
        /// </summary>
        float? ThroughputMibp { get; set; }
        /// <summary>
        /// UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID
        /// (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute
        /// (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 -
        /// gives read/write/execute permissions to owner and read/execute to group and other users.
        /// </summary>
        string UnixPermission { get; set; }
        /// <summary>
        /// Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is
        /// 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.
        /// </summary>
        long UsageThreshold { get; set; }
        /// <summary>
        /// What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating
        /// clone volume, set type to ShortTermClone
        /// </summary>
        string VolumeType { get; set; }
        /// <summary>Availability Zone</summary>
        string[] Zone { get; set; }

    }
}
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Extensions;

    /// <summary>Volume properties</summary>
    public partial class VolumeProperties :
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeProperties,
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal
    {

        /// <summary>Backing field for <see cref="ActualThroughputMibp" /> property.</summary>
        private float? _actualThroughputMibp;

        /// <summary>
        /// Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public float? ActualThroughputMibp { get => this._actualThroughputMibp; }

        /// <summary>Backing field for <see cref="AvsDataStore" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.AvsDataStore? _avsDataStore;

        /// <summary>
        /// Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.AvsDataStore? AvsDataStore { get => this._avsDataStore; set => this._avsDataStore = value; }

        /// <summary>Backup Enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? BackupEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).BackupEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).BackupEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="BackupId" /> property.</summary>
        private string _backupId;

        /// <summary>UUID v4 or resource identifier used to identify the Backup.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string BackupId { get => this._backupId; set => this._backupId = value; }

        /// <summary>Policy Enforced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? BackupPolicyEnforced { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).BackupPolicyEnforced; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).BackupPolicyEnforced = value ?? default(bool); }

        /// <summary>Backup Policy Resource ID</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string BackupPolicyId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).BackupPolicyId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).BackupPolicyId = value ?? null; }

        /// <summary>Backup Vault Resource ID</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string BackupVaultId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).BackupVaultId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).BackupVaultId = value ?? null; }

        /// <summary>Backing field for <see cref="BaremetalTenantId" /> property.</summary>
        private string _baremetalTenantId;

        /// <summary>Unique Baremetal Tenant Identifier.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string BaremetalTenantId { get => this._baremetalTenantId; }

        /// <summary>Backing field for <see cref="CapacityPoolResourceId" /> property.</summary>
        private string _capacityPoolResourceId;

        /// <summary>Pool Resource Id used in case of creating a volume through volume group</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string CapacityPoolResourceId { get => this._capacityPoolResourceId; set => this._capacityPoolResourceId = value; }

        /// <summary>Backing field for <see cref="CloneProgress" /> property.</summary>
        private int? _cloneProgress;

        /// <summary>
        /// When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process.
        /// When this value is empty/null there is no cloning process currently happening on this volume. This value will update every
        /// 5 minutes during cloning.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public int? CloneProgress { get => this._cloneProgress; }

        /// <summary>Backing field for <see cref="CoolAccess" /> property.</summary>
        private bool? _coolAccess;

        /// <summary>Specifies whether Cool Access(tiering) is enabled for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? CoolAccess { get => this._coolAccess; set => this._coolAccess = value; }

        /// <summary>Backing field for <see cref="CoolAccessRetrievalPolicy" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CoolAccessRetrievalPolicy? _coolAccessRetrievalPolicy;

        /// <summary>
        /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read
        /// pattern for cool access enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CoolAccessRetrievalPolicy? CoolAccessRetrievalPolicy { get => this._coolAccessRetrievalPolicy; set => this._coolAccessRetrievalPolicy = value; }

        /// <summary>Backing field for <see cref="CoolnessPeriod" /> property.</summary>
        private int? _coolnessPeriod;

        /// <summary>
        /// Specifies the number of days after which data that is not accessed by clients will be tiered.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public int? CoolnessPeriod { get => this._coolnessPeriod; set => this._coolnessPeriod = value; }

        /// <summary>Backing field for <see cref="CreationToken" /> property.</summary>
        private string _creationToken;

        /// <summary>A unique file path for the volume. Used when creating mount targets</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string CreationToken { get => this._creationToken; set => this._creationToken = value; }

        /// <summary>Backing field for <see cref="DataProtection" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtection _dataProtection;

        /// <summary>
        /// DataProtection type volumes include an object containing details of the replication
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtection DataProtection { get => (this._dataProtection = this._dataProtection ?? new Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.VolumePropertiesDataProtection()); set => this._dataProtection = value; }

        /// <summary>Backing field for <see cref="DataStoreResourceId" /> property.</summary>
        private string[] _dataStoreResourceId;

        /// <summary>Data store resource unique identifier</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string[] DataStoreResourceId { get => this._dataStoreResourceId; }

        /// <summary>Backing field for <see cref="DefaultGroupQuotaInKiB" /> property.</summary>
        private long? _defaultGroupQuotaInKiB;

        /// <summary>
        /// Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public long? DefaultGroupQuotaInKiB { get => this._defaultGroupQuotaInKiB; set => this._defaultGroupQuotaInKiB = value; }

        /// <summary>Backing field for <see cref="DefaultUserQuotaInKiB" /> property.</summary>
        private long? _defaultUserQuotaInKiB;

        /// <summary>
        /// Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public long? DefaultUserQuotaInKiB { get => this._defaultUserQuotaInKiB; set => this._defaultUserQuotaInKiB = value; }

        /// <summary>Backing field for <see cref="DeleteBaseSnapshot" /> property.</summary>
        private bool? _deleteBaseSnapshot;

        /// <summary>
        /// If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation
        /// has finished. Defaults to false
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? DeleteBaseSnapshot { get => this._deleteBaseSnapshot; set => this._deleteBaseSnapshot = value; }

        /// <summary>Backing field for <see cref="EnableSubvolume" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EnableSubvolumes? _enableSubvolume;

        /// <summary>Flag indicating whether subvolume operations are enabled on the volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EnableSubvolumes? EnableSubvolume { get => this._enableSubvolume; set => this._enableSubvolume = value; }

        /// <summary>Backing field for <see cref="Encrypted" /> property.</summary>
        private bool? _encrypted;

        /// <summary>
        /// Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? Encrypted { get => this._encrypted; }

        /// <summary>Backing field for <see cref="EncryptionKeySource" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EncryptionKeySource? _encryptionKeySource;

        /// <summary>
        /// Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'.
        /// Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EncryptionKeySource? EncryptionKeySource { get => this._encryptionKeySource; set => this._encryptionKeySource = value; }

        /// <summary>Backing field for <see cref="ExportPolicy" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesExportPolicy _exportPolicy;

        /// <summary>Set of export policy rules</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesExportPolicy ExportPolicy { get => (this._exportPolicy = this._exportPolicy ?? new Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.VolumePropertiesExportPolicy()); set => this._exportPolicy = value; }

        /// <summary>Export policy rule</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IExportPolicyRule[] ExportPolicyRule { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesExportPolicyInternal)ExportPolicy).Rule; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesExportPolicyInternal)ExportPolicy).Rule = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="FileAccessLog" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs? _fileAccessLog;

        /// <summary>
        /// Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the
        /// volume.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs? FileAccessLog { get => this._fileAccessLog; }

        /// <summary>Backing field for <see cref="FileSystemId" /> property.</summary>
        private string _fileSystemId;

        /// <summary>Unique FileSystem Identifier.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string FileSystemId { get => this._fileSystemId; }

        /// <summary>Backing field for <see cref="InheritedSizeInByte" /> property.</summary>
        private long? _inheritedSizeInByte;

        /// <summary>Space shared by short term clone volume with parent volume in bytes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public long? InheritedSizeInByte { get => this._inheritedSizeInByte; }

        /// <summary>Backing field for <see cref="IsDefaultQuotaEnabled" /> property.</summary>
        private bool? _isDefaultQuotaEnabled;

        /// <summary>Specifies if default quota is enabled for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? IsDefaultQuotaEnabled { get => this._isDefaultQuotaEnabled; set => this._isDefaultQuotaEnabled = value; }

        /// <summary>Backing field for <see cref="IsLargeVolume" /> property.</summary>
        private bool? _isLargeVolume;

        /// <summary>Specifies whether volume is a Large Volume or Regular Volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? IsLargeVolume { get => this._isLargeVolume; set => this._isLargeVolume = value; }

        /// <summary>Backing field for <see cref="IsRestoring" /> property.</summary>
        private bool? _isRestoring;

        /// <summary>Restoring</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? IsRestoring { get => this._isRestoring; set => this._isRestoring = value; }

        /// <summary>Backing field for <see cref="KerberosEnabled" /> property.</summary>
        private bool? _kerberosEnabled;

        /// <summary>
        /// Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? KerberosEnabled { get => this._kerberosEnabled; set => this._kerberosEnabled = value; }

        /// <summary>Backing field for <see cref="KeyVaultPrivateEndpointResourceId" /> property.</summary>
        private string _keyVaultPrivateEndpointResourceId;

        /// <summary>
        /// The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource
        /// = 'Microsoft.KeyVault'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string KeyVaultPrivateEndpointResourceId { get => this._keyVaultPrivateEndpointResourceId; set => this._keyVaultPrivateEndpointResourceId = value; }

        /// <summary>Backing field for <see cref="LdapEnabled" /> property.</summary>
        private bool? _ldapEnabled;

        /// <summary>Specifies whether LDAP is enabled or not for a given NFS volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? LdapEnabled { get => this._ldapEnabled; set => this._ldapEnabled = value; }

        /// <summary>Backing field for <see cref="MaximumNumberOfFile" /> property.</summary>
        private long? _maximumNumberOfFile;

        /// <summary>
        /// Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume
        /// quota is more than 4TiB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public long? MaximumNumberOfFile { get => this._maximumNumberOfFile; }

        /// <summary>Internal Acessors for ActualThroughputMibp</summary>
        float? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.ActualThroughputMibp { get => this._actualThroughputMibp; set { {_actualThroughputMibp = value;} } }

        /// <summary>Internal Acessors for BaremetalTenantId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.BaremetalTenantId { get => this._baremetalTenantId; set { {_baremetalTenantId = value;} } }

        /// <summary>Internal Acessors for CloneProgress</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.CloneProgress { get => this._cloneProgress; set { {_cloneProgress = value;} } }

        /// <summary>Internal Acessors for DataProtection</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtection Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.DataProtection { get => (this._dataProtection = this._dataProtection ?? new Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.VolumePropertiesDataProtection()); set { {_dataProtection = value;} } }

        /// <summary>Internal Acessors for DataProtectionBackup</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeBackupProperties Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.DataProtectionBackup { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).Backup; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).Backup = value; }

        /// <summary>Internal Acessors for DataProtectionReplication</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IReplicationObject Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.DataProtectionReplication { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).Replication; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).Replication = value; }

        /// <summary>Internal Acessors for DataProtectionSnapshot</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeSnapshotProperties Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.DataProtectionSnapshot { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).Snapshot; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).Snapshot = value; }

        /// <summary>Internal Acessors for DataProtectionVolumeRelocation</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeRelocationProperties Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.DataProtectionVolumeRelocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).VolumeRelocation; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).VolumeRelocation = value; }

        /// <summary>Internal Acessors for DataStoreResourceId</summary>
        string[] Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.DataStoreResourceId { get => this._dataStoreResourceId; set { {_dataStoreResourceId = value;} } }

        /// <summary>Internal Acessors for Encrypted</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.Encrypted { get => this._encrypted; set { {_encrypted = value;} } }

        /// <summary>Internal Acessors for ExportPolicy</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesExportPolicy Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.ExportPolicy { get => (this._exportPolicy = this._exportPolicy ?? new Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.VolumePropertiesExportPolicy()); set { {_exportPolicy = value;} } }

        /// <summary>Internal Acessors for FileAccessLog</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.FileAccessLog { get => this._fileAccessLog; set { {_fileAccessLog = value;} } }

        /// <summary>Internal Acessors for FileSystemId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.FileSystemId { get => this._fileSystemId; set { {_fileSystemId = value;} } }

        /// <summary>Internal Acessors for InheritedSizeInByte</summary>
        long? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.InheritedSizeInByte { get => this._inheritedSizeInByte; set { {_inheritedSizeInByte = value;} } }

        /// <summary>Internal Acessors for MaximumNumberOfFile</summary>
        long? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.MaximumNumberOfFile { get => this._maximumNumberOfFile; set { {_maximumNumberOfFile = value;} } }

        /// <summary>Internal Acessors for MountTarget</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties[] Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.MountTarget { get => this._mountTarget; set { {_mountTarget = value;} } }

        /// <summary>Internal Acessors for NetworkSiblingSetId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.NetworkSiblingSetId { get => this._networkSiblingSetId; set { {_networkSiblingSetId = value;} } }

        /// <summary>Internal Acessors for OriginatingResourceId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.OriginatingResourceId { get => this._originatingResourceId; set { {_originatingResourceId = value;} } }

        /// <summary>Internal Acessors for ProvisionedAvailabilityZone</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.ProvisionedAvailabilityZone { get => this._provisionedAvailabilityZone; set { {_provisionedAvailabilityZone = value;} } }

        /// <summary>Internal Acessors for ProvisioningState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.ProvisioningState { get => this._provisioningState; set { {_provisioningState = value;} } }

        /// <summary>Internal Acessors for ReplicationId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.ReplicationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationId = value; }

        /// <summary>Internal Acessors for ReplicationRemotePath</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IRemotePath Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.ReplicationRemotePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationRemotePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationRemotePath = value; }

        /// <summary>Internal Acessors for StorageToNetworkProximity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.StorageToNetworkProximity { get => this._storageToNetworkProximity; set { {_storageToNetworkProximity = value;} } }

        /// <summary>Internal Acessors for T2Network</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.T2Network { get => this._t2Network; set { {_t2Network = value;} } }

        /// <summary>Internal Acessors for VolumeGroupName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.VolumeGroupName { get => this._volumeGroupName; set { {_volumeGroupName = value;} } }

        /// <summary>Internal Acessors for VolumeRelocationReadyToBeFinalized</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesInternal.VolumeRelocationReadyToBeFinalized { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).VolumeRelocationReadyToBeFinalized; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).VolumeRelocationReadyToBeFinalized = value; }

        /// <summary>Backing field for <see cref="MountTarget" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties[] _mountTarget;

        /// <summary>List of mount targets</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties[] MountTarget { get => this._mountTarget; }

        /// <summary>Backing field for <see cref="NetworkFeature" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.NetworkFeatures? _networkFeature;

        /// <summary>Network features available to the volume, or current state of update.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.NetworkFeatures? NetworkFeature { get => this._networkFeature; set => this._networkFeature = value; }

        /// <summary>Backing field for <see cref="NetworkSiblingSetId" /> property.</summary>
        private string _networkSiblingSetId;

        /// <summary>
        /// Network Sibling Set ID for the the group of volumes sharing networking resources.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string NetworkSiblingSetId { get => this._networkSiblingSetId; }

        /// <summary>Backing field for <see cref="OriginatingResourceId" /> property.</summary>
        private string _originatingResourceId;

        /// <summary>Id of the snapshot or backup that the volume is restored from.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string OriginatingResourceId { get => this._originatingResourceId; }

        /// <summary>Backing field for <see cref="PlacementRule" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IPlacementKeyValuePairs[] _placementRule;

        /// <summary>Application specific placement rules for the particular volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IPlacementKeyValuePairs[] PlacementRule { get => this._placementRule; set => this._placementRule = value; }

        /// <summary>Backing field for <see cref="ProtocolType" /> property.</summary>
        private string[] _protocolType;

        /// <summary>Set of protocol types, default NFSv3, CIFS for SMB protocol</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string[] ProtocolType { get => this._protocolType; set => this._protocolType = value; }

        /// <summary>Backing field for <see cref="ProvisionedAvailabilityZone" /> property.</summary>
        private string _provisionedAvailabilityZone;

        /// <summary>
        /// The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string ProvisionedAvailabilityZone { get => this._provisionedAvailabilityZone; }

        /// <summary>Backing field for <see cref="ProvisioningState" /> property.</summary>
        private string _provisioningState;

        /// <summary>Azure lifecycle management</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string ProvisioningState { get => this._provisioningState; }

        /// <summary>Backing field for <see cref="ProximityPlacementGroup" /> property.</summary>
        private string _proximityPlacementGroup;

        /// <summary>Proximity placement group associated with the volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string ProximityPlacementGroup { get => this._proximityPlacementGroup; set => this._proximityPlacementGroup = value; }

        /// <summary>The Path to a ONTAP Host</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string RemotePathExternalHostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).RemotePathExternalHostName; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).RemotePathExternalHostName = value ?? null; }

        /// <summary>The name of a server on the ONTAP Host</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string RemotePathServerName { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).RemotePathServerName; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).RemotePathServerName = value ?? null; }

        /// <summary>The name of a volume on the server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string RemotePathVolumeName { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).RemotePathVolumeName; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).RemotePathVolumeName = value ?? null; }

        /// <summary>
        /// Indicates whether the local volume is the source or destination for the Volume Replication
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EndpointType? ReplicationEndpointType { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationEndpointType; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationEndpointType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EndpointType)""); }

        /// <summary>Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string ReplicationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationId; }

        /// <summary>The remote region for the other end of the Volume Replication.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string ReplicationRemoteVolumeRegion { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationRemoteVolumeRegion; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationRemoteVolumeRegion = value ?? null; }

        /// <summary>
        /// The resource ID of the remote volume. Required for cross region and cross zone replication
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string ReplicationRemoteVolumeResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationRemoteVolumeResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationRemoteVolumeResourceId = value ?? null; }

        /// <summary>Schedule</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ReplicationSchedule? ReplicationSchedule { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationSchedule; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).ReplicationSchedule = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ReplicationSchedule)""); }

        /// <summary>Backing field for <see cref="SecurityStyle" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SecurityStyle? _securityStyle;

        /// <summary>
        /// The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SecurityStyle? SecurityStyle { get => this._securityStyle; set => this._securityStyle = value; }

        /// <summary>Backing field for <see cref="ServiceLevel" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ServiceLevel? _serviceLevel;

        /// <summary>The service level of the file system</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ServiceLevel? ServiceLevel { get => this._serviceLevel; set => this._serviceLevel = value; }

        /// <summary>Backing field for <see cref="SmbAccessBasedEnumeration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbAccessBasedEnumeration? _smbAccessBasedEnumeration;

        /// <summary>
        /// Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbAccessBasedEnumeration? SmbAccessBasedEnumeration { get => this._smbAccessBasedEnumeration; set => this._smbAccessBasedEnumeration = value; }

        /// <summary>Backing field for <see cref="SmbContinuouslyAvailable" /> property.</summary>
        private bool? _smbContinuouslyAvailable;

        /// <summary>
        /// Enables continuously available share property for smb volume. Only applicable for SMB volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? SmbContinuouslyAvailable { get => this._smbContinuouslyAvailable; set => this._smbContinuouslyAvailable = value; }

        /// <summary>Backing field for <see cref="SmbEncryption" /> property.</summary>
        private bool? _smbEncryption;

        /// <summary>
        /// Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version
        /// 2020-08-01 or later
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? SmbEncryption { get => this._smbEncryption; set => this._smbEncryption = value; }

        /// <summary>Backing field for <see cref="SmbNonBrowsable" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbNonBrowsable? _smbNonBrowsable;

        /// <summary>
        /// Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbNonBrowsable? SmbNonBrowsable { get => this._smbNonBrowsable; set => this._smbNonBrowsable = value; }

        /// <summary>Backing field for <see cref="SnapshotDirectoryVisible" /> property.</summary>
        private bool? _snapshotDirectoryVisible;

        /// <summary>
        /// If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's
        /// snapshots (defaults to true).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public bool? SnapshotDirectoryVisible { get => this._snapshotDirectoryVisible; set => this._snapshotDirectoryVisible = value; }

        /// <summary>Backing field for <see cref="SnapshotId" /> property.</summary>
        private string _snapshotId;

        /// <summary>UUID v4 or resource identifier used to identify the Snapshot.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string SnapshotId { get => this._snapshotId; set => this._snapshotId = value; }

        /// <summary>Snapshot Policy ResourceId</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public string SnapshotPolicyId { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).SnapshotPolicyId; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).SnapshotPolicyId = value ?? null; }

        /// <summary>Backing field for <see cref="StorageToNetworkProximity" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity? _storageToNetworkProximity;

        /// <summary>Provides storage to network proximity information for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity? StorageToNetworkProximity { get => this._storageToNetworkProximity; }

        /// <summary>Backing field for <see cref="SubnetId" /> property.</summary>
        private string _subnetId;

        /// <summary>
        /// The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string SubnetId { get => this._subnetId; set => this._subnetId = value; }

        /// <summary>Backing field for <see cref="T2Network" /> property.</summary>
        private string _t2Network;

        /// <summary>T2 network information</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string T2Network { get => this._t2Network; }

        /// <summary>Backing field for <see cref="ThroughputMibp" /> property.</summary>
        private float? _throughputMibp;

        /// <summary>
        /// Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType
        /// volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public float? ThroughputMibp { get => this._throughputMibp; set => this._throughputMibp = value; }

        /// <summary>Backing field for <see cref="UnixPermission" /> property.</summary>
        private string _unixPermission;

        /// <summary>
        /// UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID
        /// (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute
        /// (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 -
        /// gives read/write/execute permissions to owner and read/execute to group and other users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string UnixPermission { get => this._unixPermission; set => this._unixPermission = value; }

        /// <summary>Backing field for <see cref="UsageThreshold" /> property.</summary>
        private long _usageThreshold;

        /// <summary>
        /// Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is
        /// 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public long UsageThreshold { get => this._usageThreshold; set => this._usageThreshold = value; }

        /// <summary>Backing field for <see cref="VolumeGroupName" /> property.</summary>
        private string _volumeGroupName;

        /// <summary>Volume Group Name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string VolumeGroupName { get => this._volumeGroupName; }

        /// <summary>Has relocation finished and is ready to be cleaned up</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? VolumeRelocationReadyToBeFinalized { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).VolumeRelocationReadyToBeFinalized; }

        /// <summary>Has relocation been requested for this volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Inlined)]
        public bool? VolumeRelocationRequested { get => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).VolumeRelocationRequested; set => ((Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtectionInternal)DataProtection).VolumeRelocationRequested = value ?? default(bool); }

        /// <summary>Backing field for <see cref="VolumeSpecName" /> property.</summary>
        private string _volumeSpecName;

        /// <summary>
        /// Volume spec name is the application specific designation or identifier for the particular volume in a volume group for
        /// e.g. data, log
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string VolumeSpecName { get => this._volumeSpecName; set => this._volumeSpecName = value; }

        /// <summary>Backing field for <see cref="VolumeType" /> property.</summary>
        private string _volumeType;

        /// <summary>
        /// What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating
        /// clone volume, set type to ShortTermClone
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Origin(Microsoft.Azure.PowerShell.Cmdlets.NetApp.PropertyOrigin.Owned)]
        public string VolumeType { get => this._volumeType; set => this._volumeType = value; }

        /// <summary>Creates an new <see cref="VolumeProperties" /> instance.</summary>
        public VolumeProperties()
        {

        }
    }
    /// Volume properties
    public partial interface IVolumeProperties :
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.IJsonSerializable
    {
        /// <summary>
        /// Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel",
        SerializedName = @"actualThroughputMibps",
        PossibleTypes = new [] { typeof(float) })]
        float? ActualThroughputMibp { get;  }
        /// <summary>
        /// Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose",
        SerializedName = @"avsDataStore",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.AvsDataStore) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.AvsDataStore? AvsDataStore { get; set; }
        /// <summary>Backup Enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Backup Enabled",
        SerializedName = @"backupEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupEnabled { get; set; }
        /// <summary>UUID v4 or resource identifier used to identify the Backup.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"UUID v4 or resource identifier used to identify the Backup.",
        SerializedName = @"backupId",
        PossibleTypes = new [] { typeof(string) })]
        string BackupId { get; set; }
        /// <summary>Policy Enforced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Policy Enforced",
        SerializedName = @"policyEnforced",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupPolicyEnforced { get; set; }
        /// <summary>Backup Policy Resource ID</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Backup Policy Resource ID",
        SerializedName = @"backupPolicyId",
        PossibleTypes = new [] { typeof(string) })]
        string BackupPolicyId { get; set; }
        /// <summary>Backup Vault Resource ID</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Backup Vault Resource ID",
        SerializedName = @"backupVaultId",
        PossibleTypes = new [] { typeof(string) })]
        string BackupVaultId { get; set; }
        /// <summary>Unique Baremetal Tenant Identifier.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Unique Baremetal Tenant Identifier.",
        SerializedName = @"baremetalTenantId",
        PossibleTypes = new [] { typeof(string) })]
        string BaremetalTenantId { get;  }
        /// <summary>Pool Resource Id used in case of creating a volume through volume group</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Pool Resource Id used in case of creating a volume through volume group",
        SerializedName = @"capacityPoolResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string CapacityPoolResourceId { get; set; }
        /// <summary>
        /// When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process.
        /// When this value is empty/null there is no cloning process currently happening on this volume. This value will update every
        /// 5 minutes during cloning.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.",
        SerializedName = @"cloneProgress",
        PossibleTypes = new [] { typeof(int) })]
        int? CloneProgress { get;  }
        /// <summary>Specifies whether Cool Access(tiering) is enabled for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether Cool Access(tiering) is enabled for the volume.",
        SerializedName = @"coolAccess",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CoolAccess { get; set; }
        /// <summary>
        /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read
        /// pattern for cool access enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are:
         Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
         OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
         Never - No client-driven data is pulled from cool tier to standard storage.",
        SerializedName = @"coolAccessRetrievalPolicy",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CoolAccessRetrievalPolicy) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CoolAccessRetrievalPolicy? CoolAccessRetrievalPolicy { get; set; }
        /// <summary>
        /// Specifies the number of days after which data that is not accessed by clients will be tiered.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the number of days after which data that is not accessed by clients will be tiered.",
        SerializedName = @"coolnessPeriod",
        PossibleTypes = new [] { typeof(int) })]
        int? CoolnessPeriod { get; set; }
        /// <summary>A unique file path for the volume. Used when creating mount targets</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"A unique file path for the volume. Used when creating mount targets",
        SerializedName = @"creationToken",
        PossibleTypes = new [] { typeof(string) })]
        string CreationToken { get; set; }
        /// <summary>Data store resource unique identifier</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Data store resource unique identifier",
        SerializedName = @"dataStoreResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string[] DataStoreResourceId { get;  }
        /// <summary>
        /// Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.",
        SerializedName = @"defaultGroupQuotaInKiBs",
        PossibleTypes = new [] { typeof(long) })]
        long? DefaultGroupQuotaInKiB { get; set; }
        /// <summary>
        /// Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .",
        SerializedName = @"defaultUserQuotaInKiBs",
        PossibleTypes = new [] { typeof(long) })]
        long? DefaultUserQuotaInKiB { get; set; }
        /// <summary>
        /// If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation
        /// has finished. Defaults to false
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false",
        SerializedName = @"deleteBaseSnapshot",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DeleteBaseSnapshot { get; set; }
        /// <summary>Flag indicating whether subvolume operations are enabled on the volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Flag indicating whether subvolume operations are enabled on the volume",
        SerializedName = @"enableSubvolumes",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EnableSubvolumes) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EnableSubvolumes? EnableSubvolume { get; set; }
        /// <summary>
        /// Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.",
        SerializedName = @"encrypted",
        PossibleTypes = new [] { typeof(bool) })]
        bool? Encrypted { get;  }
        /// <summary>
        /// Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'.
        /// Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'",
        SerializedName = @"encryptionKeySource",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EncryptionKeySource) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EncryptionKeySource? EncryptionKeySource { get; set; }
        /// <summary>Export policy rule</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Export policy rule",
        SerializedName = @"rules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IExportPolicyRule) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IExportPolicyRule[] ExportPolicyRule { get; set; }
        /// <summary>
        /// Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the
        /// volume.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume.",
        SerializedName = @"fileAccessLogs",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs? FileAccessLog { get;  }
        /// <summary>Unique FileSystem Identifier.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Unique FileSystem Identifier.",
        SerializedName = @"fileSystemId",
        PossibleTypes = new [] { typeof(string) })]
        string FileSystemId { get;  }
        /// <summary>Space shared by short term clone volume with parent volume in bytes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Space shared by short term clone volume with parent volume in bytes.",
        SerializedName = @"inheritedSizeInBytes",
        PossibleTypes = new [] { typeof(long) })]
        long? InheritedSizeInByte { get;  }
        /// <summary>Specifies if default quota is enabled for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies if default quota is enabled for the volume.",
        SerializedName = @"isDefaultQuotaEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsDefaultQuotaEnabled { get; set; }
        /// <summary>Specifies whether volume is a Large Volume or Regular Volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether volume is a Large Volume or Regular Volume.",
        SerializedName = @"isLargeVolume",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsLargeVolume { get; set; }
        /// <summary>Restoring</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Restoring",
        SerializedName = @"isRestoring",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsRestoring { get; set; }
        /// <summary>
        /// Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later",
        SerializedName = @"kerberosEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? KerberosEnabled { get; set; }
        /// <summary>
        /// The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource
        /// = 'Microsoft.KeyVault'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.",
        SerializedName = @"keyVaultPrivateEndpointResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string KeyVaultPrivateEndpointResourceId { get; set; }
        /// <summary>Specifies whether LDAP is enabled or not for a given NFS volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether LDAP is enabled or not for a given NFS volume.",
        SerializedName = @"ldapEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LdapEnabled { get; set; }
        /// <summary>
        /// Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume
        /// quota is more than 4TiB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.",
        SerializedName = @"maximumNumberOfFiles",
        PossibleTypes = new [] { typeof(long) })]
        long? MaximumNumberOfFile { get;  }
        /// <summary>List of mount targets</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"List of mount targets",
        SerializedName = @"mountTargets",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties[] MountTarget { get;  }
        /// <summary>Network features available to the volume, or current state of update.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Network features available to the volume, or current state of update.",
        SerializedName = @"networkFeatures",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.NetworkFeatures) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.NetworkFeatures? NetworkFeature { get; set; }
        /// <summary>
        /// Network Sibling Set ID for the the group of volumes sharing networking resources.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Network Sibling Set ID for the the group of volumes sharing networking resources.",
        SerializedName = @"networkSiblingSetId",
        PossibleTypes = new [] { typeof(string) })]
        string NetworkSiblingSetId { get;  }
        /// <summary>Id of the snapshot or backup that the volume is restored from.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Id of the snapshot or backup that the volume is restored from.",
        SerializedName = @"originatingResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string OriginatingResourceId { get;  }
        /// <summary>Application specific placement rules for the particular volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Application specific placement rules for the particular volume",
        SerializedName = @"placementRules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IPlacementKeyValuePairs) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IPlacementKeyValuePairs[] PlacementRule { get; set; }
        /// <summary>Set of protocol types, default NFSv3, CIFS for SMB protocol</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Set of protocol types, default NFSv3, CIFS for SMB protocol",
        SerializedName = @"protocolTypes",
        PossibleTypes = new [] { typeof(string) })]
        string[] ProtocolType { get; set; }
        /// <summary>
        /// The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.",
        SerializedName = @"provisionedAvailabilityZone",
        PossibleTypes = new [] { typeof(string) })]
        string ProvisionedAvailabilityZone { get;  }
        /// <summary>Azure lifecycle management</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Azure lifecycle management",
        SerializedName = @"provisioningState",
        PossibleTypes = new [] { typeof(string) })]
        string ProvisioningState { get;  }
        /// <summary>Proximity placement group associated with the volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Proximity placement group associated with the volume",
        SerializedName = @"proximityPlacementGroup",
        PossibleTypes = new [] { typeof(string) })]
        string ProximityPlacementGroup { get; set; }
        /// <summary>The Path to a ONTAP Host</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Path to a ONTAP Host",
        SerializedName = @"externalHostName",
        PossibleTypes = new [] { typeof(string) })]
        string RemotePathExternalHostName { get; set; }
        /// <summary>The name of a server on the ONTAP Host</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of a server on the ONTAP Host",
        SerializedName = @"serverName",
        PossibleTypes = new [] { typeof(string) })]
        string RemotePathServerName { get; set; }
        /// <summary>The name of a volume on the server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of a volume on the server",
        SerializedName = @"volumeName",
        PossibleTypes = new [] { typeof(string) })]
        string RemotePathVolumeName { get; set; }
        /// <summary>
        /// Indicates whether the local volume is the source or destination for the Volume Replication
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the local volume is the source or destination for the Volume Replication",
        SerializedName = @"endpointType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EndpointType) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EndpointType? ReplicationEndpointType { get; set; }
        /// <summary>Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Id",
        SerializedName = @"replicationId",
        PossibleTypes = new [] { typeof(string) })]
        string ReplicationId { get;  }
        /// <summary>The remote region for the other end of the Volume Replication.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The remote region for the other end of the Volume Replication.",
        SerializedName = @"remoteVolumeRegion",
        PossibleTypes = new [] { typeof(string) })]
        string ReplicationRemoteVolumeRegion { get; set; }
        /// <summary>
        /// The resource ID of the remote volume. Required for cross region and cross zone replication
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource ID of the remote volume. Required for cross region and cross zone replication",
        SerializedName = @"remoteVolumeResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string ReplicationRemoteVolumeResourceId { get; set; }
        /// <summary>Schedule</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Schedule",
        SerializedName = @"replicationSchedule",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ReplicationSchedule) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ReplicationSchedule? ReplicationSchedule { get; set; }
        /// <summary>
        /// The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol",
        SerializedName = @"securityStyle",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SecurityStyle) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SecurityStyle? SecurityStyle { get; set; }
        /// <summary>The service level of the file system</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The service level of the file system",
        SerializedName = @"serviceLevel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ServiceLevel) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ServiceLevel? ServiceLevel { get; set; }
        /// <summary>
        /// Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume",
        SerializedName = @"smbAccessBasedEnumeration",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbAccessBasedEnumeration) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbAccessBasedEnumeration? SmbAccessBasedEnumeration { get; set; }
        /// <summary>
        /// Enables continuously available share property for smb volume. Only applicable for SMB volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables continuously available share property for smb volume. Only applicable for SMB volume",
        SerializedName = @"smbContinuouslyAvailable",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SmbContinuouslyAvailable { get; set; }
        /// <summary>
        /// Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version
        /// 2020-08-01 or later
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later",
        SerializedName = @"smbEncryption",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SmbEncryption { get; set; }
        /// <summary>
        /// Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume",
        SerializedName = @"smbNonBrowsable",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbNonBrowsable) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbNonBrowsable? SmbNonBrowsable { get; set; }
        /// <summary>
        /// If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's
        /// snapshots (defaults to true).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).",
        SerializedName = @"snapshotDirectoryVisible",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotDirectoryVisible { get; set; }
        /// <summary>UUID v4 or resource identifier used to identify the Snapshot.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"UUID v4 or resource identifier used to identify the Snapshot.",
        SerializedName = @"snapshotId",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotId { get; set; }
        /// <summary>Snapshot Policy ResourceId</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Snapshot Policy ResourceId",
        SerializedName = @"snapshotPolicyId",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotPolicyId { get; set; }
        /// <summary>Provides storage to network proximity information for the volume.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Provides storage to network proximity information for the volume.",
        SerializedName = @"storageToNetworkProximity",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity) })]
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity? StorageToNetworkProximity { get;  }
        /// <summary>
        /// The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes",
        SerializedName = @"subnetId",
        PossibleTypes = new [] { typeof(string) })]
        string SubnetId { get; set; }
        /// <summary>T2 network information</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"T2 network information",
        SerializedName = @"t2Network",
        PossibleTypes = new [] { typeof(string) })]
        string T2Network { get;  }
        /// <summary>
        /// Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType
        /// volume
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType volume",
        SerializedName = @"throughputMibps",
        PossibleTypes = new [] { typeof(float) })]
        float? ThroughputMibp { get; set; }
        /// <summary>
        /// UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID
        /// (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute
        /// (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 -
        /// gives read/write/execute permissions to owner and read/execute to group and other users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.",
        SerializedName = @"unixPermissions",
        PossibleTypes = new [] { typeof(string) })]
        string UnixPermission { get; set; }
        /// <summary>
        /// Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is
        /// 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.",
        SerializedName = @"usageThreshold",
        PossibleTypes = new [] { typeof(long) })]
        long UsageThreshold { get; set; }
        /// <summary>Volume Group Name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Volume Group Name",
        SerializedName = @"volumeGroupName",
        PossibleTypes = new [] { typeof(string) })]
        string VolumeGroupName { get;  }
        /// <summary>Has relocation finished and is ready to be cleaned up</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Has relocation finished and is ready to be cleaned up",
        SerializedName = @"readyToBeFinalized",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VolumeRelocationReadyToBeFinalized { get;  }
        /// <summary>Has relocation been requested for this volume</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Has relocation been requested for this volume",
        SerializedName = @"relocationRequested",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VolumeRelocationRequested { get; set; }
        /// <summary>
        /// Volume spec name is the application specific designation or identifier for the particular volume in a volume group for
        /// e.g. data, log
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log",
        SerializedName = @"volumeSpecName",
        PossibleTypes = new [] { typeof(string) })]
        string VolumeSpecName { get; set; }
        /// <summary>
        /// What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating
        /// clone volume, set type to ShortTermClone
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.NetApp.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating clone volume, set type to ShortTermClone",
        SerializedName = @"volumeType",
        PossibleTypes = new [] { typeof(string) })]
        string VolumeType { get; set; }

    }
    /// Volume properties
    internal partial interface IVolumePropertiesInternal

    {
        /// <summary>
        /// Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        /// </summary>
        float? ActualThroughputMibp { get; set; }
        /// <summary>
        /// Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.AvsDataStore? AvsDataStore { get; set; }
        /// <summary>Backup Enabled</summary>
        bool? BackupEnabled { get; set; }
        /// <summary>UUID v4 or resource identifier used to identify the Backup.</summary>
        string BackupId { get; set; }
        /// <summary>Policy Enforced</summary>
        bool? BackupPolicyEnforced { get; set; }
        /// <summary>Backup Policy Resource ID</summary>
        string BackupPolicyId { get; set; }
        /// <summary>Backup Vault Resource ID</summary>
        string BackupVaultId { get; set; }
        /// <summary>Unique Baremetal Tenant Identifier.</summary>
        string BaremetalTenantId { get; set; }
        /// <summary>Pool Resource Id used in case of creating a volume through volume group</summary>
        string CapacityPoolResourceId { get; set; }
        /// <summary>
        /// When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process.
        /// When this value is empty/null there is no cloning process currently happening on this volume. This value will update every
        /// 5 minutes during cloning.
        /// </summary>
        int? CloneProgress { get; set; }
        /// <summary>Specifies whether Cool Access(tiering) is enabled for the volume.</summary>
        bool? CoolAccess { get; set; }
        /// <summary>
        /// coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read
        /// pattern for cool access enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.CoolAccessRetrievalPolicy? CoolAccessRetrievalPolicy { get; set; }
        /// <summary>
        /// Specifies the number of days after which data that is not accessed by clients will be tiered.
        /// </summary>
        int? CoolnessPeriod { get; set; }
        /// <summary>A unique file path for the volume. Used when creating mount targets</summary>
        string CreationToken { get; set; }
        /// <summary>
        /// DataProtection type volumes include an object containing details of the replication
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesDataProtection DataProtection { get; set; }
        /// <summary>Backup Properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeBackupProperties DataProtectionBackup { get; set; }
        /// <summary>Replication properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IReplicationObject DataProtectionReplication { get; set; }
        /// <summary>Snapshot properties.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeSnapshotProperties DataProtectionSnapshot { get; set; }
        /// <summary>VolumeRelocation properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumeRelocationProperties DataProtectionVolumeRelocation { get; set; }
        /// <summary>Data store resource unique identifier</summary>
        string[] DataStoreResourceId { get; set; }
        /// <summary>
        /// Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        /// </summary>
        long? DefaultGroupQuotaInKiB { get; set; }
        /// <summary>
        /// Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        /// </summary>
        long? DefaultUserQuotaInKiB { get; set; }
        /// <summary>
        /// If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation
        /// has finished. Defaults to false
        /// </summary>
        bool? DeleteBaseSnapshot { get; set; }
        /// <summary>Flag indicating whether subvolume operations are enabled on the volume</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EnableSubvolumes? EnableSubvolume { get; set; }
        /// <summary>
        /// Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        /// </summary>
        bool? Encrypted { get; set; }
        /// <summary>
        /// Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'.
        /// Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EncryptionKeySource? EncryptionKeySource { get; set; }
        /// <summary>Set of export policy rules</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IVolumePropertiesExportPolicy ExportPolicy { get; set; }
        /// <summary>Export policy rule</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IExportPolicyRule[] ExportPolicyRule { get; set; }
        /// <summary>
        /// Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the
        /// volume.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.FileAccessLogs? FileAccessLog { get; set; }
        /// <summary>Unique FileSystem Identifier.</summary>
        string FileSystemId { get; set; }
        /// <summary>Space shared by short term clone volume with parent volume in bytes.</summary>
        long? InheritedSizeInByte { get; set; }
        /// <summary>Specifies if default quota is enabled for the volume.</summary>
        bool? IsDefaultQuotaEnabled { get; set; }
        /// <summary>Specifies whether volume is a Large Volume or Regular Volume.</summary>
        bool? IsLargeVolume { get; set; }
        /// <summary>Restoring</summary>
        bool? IsRestoring { get; set; }
        /// <summary>
        /// Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        /// </summary>
        bool? KerberosEnabled { get; set; }
        /// <summary>
        /// The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource
        /// = 'Microsoft.KeyVault'.
        /// </summary>
        string KeyVaultPrivateEndpointResourceId { get; set; }
        /// <summary>Specifies whether LDAP is enabled or not for a given NFS volume.</summary>
        bool? LdapEnabled { get; set; }
        /// <summary>
        /// Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume
        /// quota is more than 4TiB.
        /// </summary>
        long? MaximumNumberOfFile { get; set; }
        /// <summary>List of mount targets</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IMountTargetProperties[] MountTarget { get; set; }
        /// <summary>Network features available to the volume, or current state of update.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.NetworkFeatures? NetworkFeature { get; set; }
        /// <summary>
        /// Network Sibling Set ID for the the group of volumes sharing networking resources.
        /// </summary>
        string NetworkSiblingSetId { get; set; }
        /// <summary>Id of the snapshot or backup that the volume is restored from.</summary>
        string OriginatingResourceId { get; set; }
        /// <summary>Application specific placement rules for the particular volume</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IPlacementKeyValuePairs[] PlacementRule { get; set; }
        /// <summary>Set of protocol types, default NFSv3, CIFS for SMB protocol</summary>
        string[] ProtocolType { get; set; }
        /// <summary>
        /// The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        /// </summary>
        string ProvisionedAvailabilityZone { get; set; }
        /// <summary>Azure lifecycle management</summary>
        string ProvisioningState { get; set; }
        /// <summary>Proximity placement group associated with the volume</summary>
        string ProximityPlacementGroup { get; set; }
        /// <summary>The Path to a ONTAP Host</summary>
        string RemotePathExternalHostName { get; set; }
        /// <summary>The name of a server on the ONTAP Host</summary>
        string RemotePathServerName { get; set; }
        /// <summary>The name of a volume on the server</summary>
        string RemotePathVolumeName { get; set; }
        /// <summary>
        /// Indicates whether the local volume is the source or destination for the Volume Replication
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.EndpointType? ReplicationEndpointType { get; set; }
        /// <summary>Id</summary>
        string ReplicationId { get; set; }
        /// <summary>
        /// The full path to a volume that is to be migrated into ANF. Required for Migration volumes
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Models.Api20230701Preview.IRemotePath ReplicationRemotePath { get; set; }
        /// <summary>The remote region for the other end of the Volume Replication.</summary>
        string ReplicationRemoteVolumeRegion { get; set; }
        /// <summary>
        /// The resource ID of the remote volume. Required for cross region and cross zone replication
        /// </summary>
        string ReplicationRemoteVolumeResourceId { get; set; }
        /// <summary>Schedule</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ReplicationSchedule? ReplicationSchedule { get; set; }
        /// <summary>
        /// The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SecurityStyle? SecurityStyle { get; set; }
        /// <summary>The service level of the file system</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.ServiceLevel? ServiceLevel { get; set; }
        /// <summary>
        /// Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbAccessBasedEnumeration? SmbAccessBasedEnumeration { get; set; }
        /// <summary>
        /// Enables continuously available share property for smb volume. Only applicable for SMB volume
        /// </summary>
        bool? SmbContinuouslyAvailable { get; set; }
        /// <summary>
        /// Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version
        /// 2020-08-01 or later
        /// </summary>
        bool? SmbEncryption { get; set; }
        /// <summary>
        /// Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.SmbNonBrowsable? SmbNonBrowsable { get; set; }
        /// <summary>
        /// If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's
        /// snapshots (defaults to true).
        /// </summary>
        bool? SnapshotDirectoryVisible { get; set; }
        /// <summary>UUID v4 or resource identifier used to identify the Snapshot.</summary>
        string SnapshotId { get; set; }
        /// <summary>Snapshot Policy ResourceId</summary>
        string SnapshotPolicyId { get; set; }
        /// <summary>Provides storage to network proximity information for the volume.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.NetApp.Support.VolumeStorageToNetworkProximity? StorageToNetworkProximity { get; set; }
        /// <summary>
        /// The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        /// </summary>
        string SubnetId { get; set; }
        /// <summary>T2 network information</summary>
        string T2Network { get; set; }
        /// <summary>
        /// Maximum throughput in MiB/s that can be achieved by this volume and this will be accepted as input only for manual qosType
        /// volume
        /// </summary>
        float? ThroughputMibp { get; set; }
        /// <summary>
        /// UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID
        /// (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute
        /// (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 -
        /// gives read/write/execute permissions to owner and read/execute to group and other users.
        /// </summary>
        string UnixPermission { get; set; }
        /// <summary>
        /// Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is
        /// 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.
        /// </summary>
        long UsageThreshold { get; set; }
        /// <summary>Volume Group Name</summary>
        string VolumeGroupName { get; set; }
        /// <summary>Has relocation finished and is ready to be cleaned up</summary>
        bool? VolumeRelocationReadyToBeFinalized { get; set; }
        /// <summary>Has relocation been requested for this volume</summary>
        bool? VolumeRelocationRequested { get; set; }
        /// <summary>
        /// Volume spec name is the application specific designation or identifier for the particular volume in a volume group for
        /// e.g. data, log
        /// </summary>
        string VolumeSpecName { get; set; }
        /// <summary>
        /// What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating
        /// clone volume, set type to ShortTermClone
        /// </summary>
        string VolumeType { get; set; }

    }
}
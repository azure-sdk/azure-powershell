// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Cmdlets
{
    using static Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Extensions;
    using System;

    /// <summary>Creates or updates a SQL virtual machine.</summary>
    /// <remarks>
    /// [OpenAPI] CreateOrUpdate=>PUT:"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SqlVirtualMachine/sqlVirtualMachines/{sqlVirtualMachineName}"
    /// </remarks>
    [global::System.Management.Automation.Cmdlet(global::System.Management.Automation.VerbsCommon.New, @"AzSqlVirtualMachineSqlVirtualMachine_CreateExpanded", SupportsShouldProcess = true)]
    [global::System.Management.Automation.OutputType(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.ISqlVirtualMachine))]
    [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Description(@"Creates or updates a SQL virtual machine.")]
    [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Generated]
    public partial class NewAzSqlVirtualMachineSqlVirtualMachine_CreateExpanded : global::System.Management.Automation.PSCmdlet,
        Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener
    {
        /// <summary>A unique id generatd for the this cmdlet when it is instantiated.</summary>
        private string __correlationId = System.Guid.NewGuid().ToString();

        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        private global::System.Management.Automation.InvocationInfo __invocationInfo;

        /// <summary>A unique id generatd for the this cmdlet when ProcessRecord() is called.</summary>
        private string __processRecordId;

        /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();

        /// <summary>Enable or disable R services (SQL 2016 onwards).</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable R services (SQL 2016 onwards).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable R services (SQL 2016 onwards).",
        SerializedName = @"isRServicesEnabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AdditionalFeatureServerConfigurationIsRServicesEnabled { get => ParametersBody.AdditionalFeatureServerConfigurationIsRServicesEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.AdditionalFeatureServerConfigurationIsRServicesEnabled = value; }

        /// <summary>when specified, runs this cmdlet as a PowerShell job</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command as a job")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter AsJob { get; set; }

        /// <summary>Enable or disable assessment feature on SQL virtual machine.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable assessment feature on SQL virtual machine.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable assessment feature on SQL virtual machine.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AssessmentSettingEnable { get => ParametersBody.AssessmentSettingEnable ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.AssessmentSettingEnable = value; }

        /// <summary>Run assessment immediately on SQL virtual machine.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run assessment immediately on SQL virtual machine.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Run assessment immediately on SQL virtual machine.",
        SerializedName = @"runImmediately",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AssessmentSettingRunImmediately { get => ParametersBody.AssessmentSettingRunImmediately ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.AssessmentSettingRunImmediately = value; }

        /// <summary>Backup schedule type.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Backup schedule type.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Backup schedule type.",
        SerializedName = @"backupScheduleType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.BackupScheduleType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.BackupScheduleType))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.BackupScheduleType AutoBackupSettingBackupScheduleType { get => ParametersBody.AutoBackupSettingBackupScheduleType ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.BackupScheduleType)""); set => ParametersBody.AutoBackupSettingBackupScheduleType = value; }

        /// <summary>Include or exclude system databases from auto backup.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Include or exclude system databases from auto backup.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Include or exclude system databases from auto backup.",
        SerializedName = @"backupSystemDbs",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AutoBackupSettingBackupSystemDb { get => ParametersBody.AutoBackupSettingBackupSystemDb ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.AutoBackupSettingBackupSystemDb = value; }

        /// <summary>Days of the week for the backups when FullBackupFrequency is set to Weekly.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Days of the week for the backups when FullBackupFrequency is set to Weekly.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Days of the week for the backups when FullBackupFrequency is set to Weekly.",
        SerializedName = @"daysOfWeek",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DaysOfWeek) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DaysOfWeek))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DaysOfWeek[] AutoBackupSettingDaysOfWeek { get => ParametersBody.AutoBackupSettingDaysOfWeek ?? null /* arrayOf */; set => ParametersBody.AutoBackupSettingDaysOfWeek = value; }

        /// <summary>Enable or disable autobackup on SQL virtual machine.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable autobackup on SQL virtual machine.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable autobackup on SQL virtual machine.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AutoBackupSettingEnable { get => ParametersBody.AutoBackupSettingEnable ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.AutoBackupSettingEnable = value; }

        /// <summary>Enable or disable encryption for backup on SQL virtual machine.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable encryption for backup on SQL virtual machine.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable encryption for backup on SQL virtual machine.",
        SerializedName = @"enableEncryption",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AutoBackupSettingEnableEncryption { get => ParametersBody.AutoBackupSettingEnableEncryption ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.AutoBackupSettingEnableEncryption = value; }

        /// <summary>
        /// Frequency of full backups. In both cases, full backups begin during the next scheduled time window.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Frequency of full backups. In both cases, full backups begin during the next scheduled time window.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Frequency of full backups. In both cases, full backups begin during the next scheduled time window.",
        SerializedName = @"fullBackupFrequency",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.FullBackupFrequencyType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.FullBackupFrequencyType))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.FullBackupFrequencyType AutoBackupSettingFullBackupFrequency { get => ParametersBody.AutoBackupSettingFullBackupFrequency ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.FullBackupFrequencyType)""); set => ParametersBody.AutoBackupSettingFullBackupFrequency = value; }

        /// <summary>Start time of a given day during which full backups can take place. 0-23 hours.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Start time of a given day during which full backups can take place. 0-23 hours.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Start time of a given day during which full backups can take place. 0-23 hours.",
        SerializedName = @"fullBackupStartTime",
        PossibleTypes = new [] { typeof(int) })]
        public int AutoBackupSettingFullBackupStartTime { get => ParametersBody.AutoBackupSettingFullBackupStartTime ?? default(int); set => ParametersBody.AutoBackupSettingFullBackupStartTime = value; }

        /// <summary>
        /// Duration of the time window of a given day during which full backups can take place. 1-23 hours.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Duration of the time window of a given day during which full backups can take place. 1-23 hours.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Duration of the time window of a given day during which full backups can take place. 1-23 hours.",
        SerializedName = @"fullBackupWindowHours",
        PossibleTypes = new [] { typeof(int) })]
        public int AutoBackupSettingFullBackupWindowHour { get => ParametersBody.AutoBackupSettingFullBackupWindowHour ?? default(int); set => ParametersBody.AutoBackupSettingFullBackupWindowHour = value; }

        /// <summary>Frequency of log backups. 5-60 minutes.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Frequency of log backups. 5-60 minutes.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Frequency of log backups. 5-60 minutes.",
        SerializedName = @"logBackupFrequency",
        PossibleTypes = new [] { typeof(int) })]
        public int AutoBackupSettingLogBackupFrequency { get => ParametersBody.AutoBackupSettingLogBackupFrequency ?? default(int); set => ParametersBody.AutoBackupSettingLogBackupFrequency = value; }

        /// <summary>Password for encryption on backup.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Password for encryption on backup.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Password for encryption on backup.",
        SerializedName = @"password",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoBackupSettingPassword { get => ParametersBody.AutoBackupSettingPassword ?? null; set => ParametersBody.AutoBackupSettingPassword = value; }

        /// <summary>Retention period of backup: 1-90 days.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Retention period of backup: 1-90 days.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Retention period of backup: 1-90 days.",
        SerializedName = @"retentionPeriod",
        PossibleTypes = new [] { typeof(int) })]
        public int AutoBackupSettingRetentionPeriod { get => ParametersBody.AutoBackupSettingRetentionPeriod ?? default(int); set => ParametersBody.AutoBackupSettingRetentionPeriod = value; }

        /// <summary>Storage account key where backup will be taken to.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Storage account key where backup will be taken to.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Storage account key where backup will be taken to.",
        SerializedName = @"storageAccessKey",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoBackupSettingStorageAccessKey { get => ParametersBody.AutoBackupSettingStorageAccessKey ?? null; set => ParametersBody.AutoBackupSettingStorageAccessKey = value; }

        /// <summary>Storage account url where backup will be taken to.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Storage account url where backup will be taken to.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Storage account url where backup will be taken to.",
        SerializedName = @"storageAccountUrl",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoBackupSettingStorageAccountUrl { get => ParametersBody.AutoBackupSettingStorageAccountUrl ?? null; set => ParametersBody.AutoBackupSettingStorageAccountUrl = value; }

        /// <summary>Storage container name where backup will be taken to.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Storage container name where backup will be taken to.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Storage container name where backup will be taken to.",
        SerializedName = @"storageContainerName",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoBackupSettingStorageContainerName { get => ParametersBody.AutoBackupSettingStorageContainerName ?? null; set => ParametersBody.AutoBackupSettingStorageContainerName = value; }

        /// <summary>Day of week to apply the patch on.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Day of week to apply the patch on.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Day of week to apply the patch on.",
        SerializedName = @"dayOfWeek",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DayOfWeek) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DayOfWeek))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DayOfWeek AutoPatchingSettingDayOfWeek { get => ParametersBody.AutoPatchingSettingDayOfWeek ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DayOfWeek)""); set => ParametersBody.AutoPatchingSettingDayOfWeek = value; }

        /// <summary>Enable or disable autopatching on SQL virtual machine.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable autopatching on SQL virtual machine.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable autopatching on SQL virtual machine.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AutoPatchingSettingEnable { get => ParametersBody.AutoPatchingSettingEnable ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.AutoPatchingSettingEnable = value; }

        /// <summary>Duration of patching.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Duration of patching.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Duration of patching.",
        SerializedName = @"maintenanceWindowDuration",
        PossibleTypes = new [] { typeof(int) })]
        public int AutoPatchingSettingMaintenanceWindowDuration { get => ParametersBody.AutoPatchingSettingMaintenanceWindowDuration ?? default(int); set => ParametersBody.AutoPatchingSettingMaintenanceWindowDuration = value; }

        /// <summary>Hour of the day when patching is initiated. Local VM time.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Hour of the day when patching is initiated. Local VM time.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Hour of the day when patching is initiated. Local VM time.",
        SerializedName = @"maintenanceWindowStartingHour",
        PossibleTypes = new [] { typeof(int) })]
        public int AutoPatchingSettingMaintenanceWindowStartingHour { get => ParametersBody.AutoPatchingSettingMaintenanceWindowStartingHour ?? default(int); set => ParametersBody.AutoPatchingSettingMaintenanceWindowStartingHour = value; }

        /// <summary>Wait for .NET debugger to attach</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter Break { get; set; }

        /// <summary>The reference to the client API class.</summary>
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.SqlVirtualMachineManagementClient Client => Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Module.Instance.ClientAPI;

        /// <summary>
        /// The credentials, account, tenant, and subscription used for communication with Azure
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The credentials, account, tenant, and subscription used for communication with Azure.")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::System.Management.Automation.Alias("AzureRMContext", "AzureCredential")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Azure)]
        public global::System.Management.Automation.PSObject DefaultProfile { get; set; }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>
        /// The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory
        /// principal for the resource.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.IdentityType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.IdentityType))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.IdentityType IdentityType { get => ParametersBody.IdentityType ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.IdentityType)""); set => ParametersBody.IdentityType = value; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public global::System.Management.Automation.InvocationInfo InvocationInformation { get => __invocationInfo = __invocationInfo ?? this.MyInvocation ; set { __invocationInfo = value; } }

        /// <summary>Azure Key Vault url.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Azure Key Vault url.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Azure Key Vault url.",
        SerializedName = @"azureKeyVaultUrl",
        PossibleTypes = new [] { typeof(string) })]
        public string KeyVaultCredentialSettingAzureKeyVaultUrl { get => ParametersBody.KeyVaultCredentialSettingAzureKeyVaultUrl ?? null; set => ParametersBody.KeyVaultCredentialSettingAzureKeyVaultUrl = value; }

        /// <summary>Credential name.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Credential name.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Credential name.",
        SerializedName = @"credentialName",
        PossibleTypes = new [] { typeof(string) })]
        public string KeyVaultCredentialSettingCredentialName { get => ParametersBody.KeyVaultCredentialSettingCredentialName ?? null; set => ParametersBody.KeyVaultCredentialSettingCredentialName = value; }

        /// <summary>Enable or disable key vault credential setting.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable key vault credential setting.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable key vault credential setting.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter KeyVaultCredentialSettingEnable { get => ParametersBody.KeyVaultCredentialSettingEnable ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.KeyVaultCredentialSettingEnable = value; }

        /// <summary>Service principal name to access key vault.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Service principal name to access key vault.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Service principal name to access key vault.",
        SerializedName = @"servicePrincipalName",
        PossibleTypes = new [] { typeof(string) })]
        public string KeyVaultCredentialSettingServicePrincipalName { get => ParametersBody.KeyVaultCredentialSettingServicePrincipalName ?? null; set => ParametersBody.KeyVaultCredentialSettingServicePrincipalName = value; }

        /// <summary>Service principal name secret to access key vault.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Service principal name secret to access key vault.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Service principal name secret to access key vault.",
        SerializedName = @"servicePrincipalSecret",
        PossibleTypes = new [] { typeof(string) })]
        public string KeyVaultCredentialSettingServicePrincipalSecret { get => ParametersBody.KeyVaultCredentialSettingServicePrincipalSecret ?? null; set => ParametersBody.KeyVaultCredentialSettingServicePrincipalSecret = value; }

        /// <summary>Resource location.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "Resource location.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Resource location.",
        SerializedName = @"location",
        PossibleTypes = new [] { typeof(string) })]
        public string Location { get => ParametersBody.Location ?? null; set => ParametersBody.Location = value; }

        /// <summary>
        /// <see cref="IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        /// <summary><see cref="IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener.Token => _cancellationTokenSource.Token;

        /// <summary>Backing field for <see cref="Name" /> property.</summary>
        private string _name;

        /// <summary>Name of the SQL virtual machine.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "Name of the SQL virtual machine.")]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Name of the SQL virtual machine.",
        SerializedName = @"sqlVirtualMachineName",
        PossibleTypes = new [] { typeof(string) })]
        [global::System.Management.Automation.Alias("SqlVirtualMachineName")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Path)]
        public string Name { get => this._name; set => this._name = value; }

        /// <summary>
        /// when specified, will make the remote call, and return an AsyncOperationResponse, letting the remote operation continue
        /// asynchronously.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command asynchronously")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter NoWait { get; set; }

        /// <summary>Backing field for <see cref="ParametersBody" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.ISqlVirtualMachine _parametersBody= new Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.SqlVirtualMachine();

        /// <summary>A SQL virtual machine.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.ISqlVirtualMachine ParametersBody { get => this._parametersBody; set => this._parametersBody = value; }

        /// <summary>
        /// When specified, forces the cmdlet return a 'bool' given that there isn't a return type by default.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Returns true when the command succeeds")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter PassThru { get; set; }

        /// <summary>
        /// The instance of the <see cref="Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.HttpPipeline" /> that the remote call will use.
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.HttpPipeline Pipeline { get; set; }

        /// <summary>The URI for the proxy server to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Runtime)]
        public global::System.Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Runtime)]
        public global::System.Management.Automation.PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>Backing field for <see cref="ResourceGroupName" /> property.</summary>
        private string _resourceGroupName;

        /// <summary>
        /// Name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or
        /// the portal.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "Name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.")]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.",
        SerializedName = @"resourceGroupName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Path)]
        public string ResourceGroupName { get => this._resourceGroupName; set => this._resourceGroupName = value; }

        /// <summary>Day of the week to run assessment.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Day of the week to run assessment.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Day of the week to run assessment.",
        SerializedName = @"dayOfWeek",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DayOfWeek) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DayOfWeek))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DayOfWeek ScheduleDayOfWeek { get => ParametersBody.ScheduleDayOfWeek ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DayOfWeek)""); set => ParametersBody.ScheduleDayOfWeek = value; }

        /// <summary>Enable or disable assessment schedule on SQL virtual machine.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable assessment schedule on SQL virtual machine.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable assessment schedule on SQL virtual machine.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ScheduleEnable { get => ParametersBody.ScheduleEnable ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.ScheduleEnable = value; }

        /// <summary>
        /// Occurrence of the DayOfWeek day within a month to schedule assessment. Takes values: 1,2,3,4 and -1. Use -1 for last DayOfWeek
        /// day of the month
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Occurrence of the DayOfWeek day within a month to schedule assessment. Takes values: 1,2,3,4 and -1. Use -1 for last DayOfWeek day of the month")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Occurrence of the DayOfWeek day within a month to schedule assessment. Takes values: 1,2,3,4 and -1. Use -1 for last DayOfWeek day of the month",
        SerializedName = @"monthlyOccurrence",
        PossibleTypes = new [] { typeof(int) })]
        public int ScheduleMonthlyOccurrence { get => ParametersBody.ScheduleMonthlyOccurrence ?? default(int); set => ParametersBody.ScheduleMonthlyOccurrence = value; }

        /// <summary>Time of the day in HH:mm format. Eg. 17:30</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Time of the day in HH:mm format. Eg. 17:30")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Time of the day in HH:mm format. Eg. 17:30",
        SerializedName = @"startTime",
        PossibleTypes = new [] { typeof(string) })]
        public string ScheduleStartTime { get => ParametersBody.ScheduleStartTime ?? null; set => ParametersBody.ScheduleStartTime = value; }

        /// <summary>Number of weeks to schedule between 2 assessment runs. Takes value from 1-6</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Number of weeks to schedule between 2 assessment runs. Takes value from 1-6")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of weeks to schedule between 2 assessment runs. Takes value from 1-6",
        SerializedName = @"weeklyInterval",
        PossibleTypes = new [] { typeof(int) })]
        public int ScheduleWeeklyInterval { get => ParametersBody.ScheduleWeeklyInterval ?? default(int); set => ParametersBody.ScheduleWeeklyInterval = value; }

        /// <summary>SQL Server connectivity option.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server connectivity option.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server connectivity option.",
        SerializedName = @"connectivityType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.ConnectivityType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.ConnectivityType))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.ConnectivityType SqlConnectivityUpdateSettingConnectivityType { get => ParametersBody.SqlConnectivityUpdateSettingConnectivityType ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.ConnectivityType)""); set => ParametersBody.SqlConnectivityUpdateSettingConnectivityType = value; }

        /// <summary>SQL Server port.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server port.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server port.",
        SerializedName = @"port",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlConnectivityUpdateSettingPort { get => ParametersBody.SqlConnectivityUpdateSettingPort ?? default(int); set => ParametersBody.SqlConnectivityUpdateSettingPort = value; }

        /// <summary>SQL Server sysadmin login password.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server sysadmin login password.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server sysadmin login password.",
        SerializedName = @"sqlAuthUpdatePassword",
        PossibleTypes = new [] { typeof(string) })]
        public string SqlConnectivityUpdateSettingSqlAuthUpdatePassword { get => ParametersBody.SqlConnectivityUpdateSettingSqlAuthUpdatePassword ?? null; set => ParametersBody.SqlConnectivityUpdateSettingSqlAuthUpdatePassword = value; }

        /// <summary>SQL Server sysadmin login to create.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server sysadmin login to create.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server sysadmin login to create.",
        SerializedName = @"sqlAuthUpdateUserName",
        PossibleTypes = new [] { typeof(string) })]
        public string SqlConnectivityUpdateSettingSqlAuthUpdateUserName { get => ParametersBody.SqlConnectivityUpdateSettingSqlAuthUpdateUserName ?? null; set => ParametersBody.SqlConnectivityUpdateSettingSqlAuthUpdateUserName = value; }

        /// <summary>SQL Server default file path</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server default file path")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server default file path",
        SerializedName = @"defaultFilePath",
        PossibleTypes = new [] { typeof(string) })]
        public string SqlDataSettingDefaultFilePath { get => ParametersBody.SqlDataSettingDefaultFilePath ?? null; set => ParametersBody.SqlDataSettingDefaultFilePath = value; }

        /// <summary>Logical Unit Numbers for the disks.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Logical Unit Numbers for the disks.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Logical Unit Numbers for the disks.",
        SerializedName = @"luns",
        PossibleTypes = new [] { typeof(int) })]
        public int[] SqlDataSettingLun { get => ParametersBody.SqlDataSettingLun ?? null /* arrayOf */; set => ParametersBody.SqlDataSettingLun = value; }

        /// <summary>SQL image offer. Examples include SQL2016-WS2016, SQL2017-WS2016.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL image offer. Examples include SQL2016-WS2016, SQL2017-WS2016.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL image offer. Examples include SQL2016-WS2016, SQL2017-WS2016.",
        SerializedName = @"sqlImageOffer",
        PossibleTypes = new [] { typeof(string) })]
        public string SqlImageOffer { get => ParametersBody.SqlImageOffer ?? null; set => ParametersBody.SqlImageOffer = value; }

        /// <summary>SQL Server edition type.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server edition type.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server edition type.",
        SerializedName = @"sqlImageSku",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlImageSku) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlImageSku))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlImageSku SqlImageSku { get => ParametersBody.SqlImageSku ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlImageSku)""); set => ParametersBody.SqlImageSku = value; }

        /// <summary>SQL Server Collation.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server Collation.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server Collation.",
        SerializedName = @"collation",
        PossibleTypes = new [] { typeof(string) })]
        public string SqlInstanceSettingCollation { get => ParametersBody.SqlInstanceSettingCollation ?? null; set => ParametersBody.SqlInstanceSettingCollation = value; }

        /// <summary>SQL Server Optimize for Adhoc workloads.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server Optimize for Adhoc workloads.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server Optimize for Adhoc workloads.",
        SerializedName = @"isOptimizeForAdHocWorkloadsEnabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter SqlInstanceSettingIsOptimizeForAdHocWorkloadsEnabled { get => ParametersBody.SqlInstanceSettingIsOptimizeForAdHocWorkloadsEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.SqlInstanceSettingIsOptimizeForAdHocWorkloadsEnabled = value; }

        /// <summary>SQL Server MAXDOP.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server MAXDOP.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server MAXDOP.",
        SerializedName = @"maxDop",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlInstanceSettingMaxDop { get => ParametersBody.SqlInstanceSettingMaxDop ?? default(int); set => ParametersBody.SqlInstanceSettingMaxDop = value; }

        /// <summary>SQL Server maximum memory.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server maximum memory.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server maximum memory.",
        SerializedName = @"maxServerMemoryMB",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlInstanceSettingMaxServerMemoryMb { get => ParametersBody.SqlInstanceSettingMaxServerMemoryMb ?? default(int); set => ParametersBody.SqlInstanceSettingMaxServerMemoryMb = value; }

        /// <summary>SQL Server minimum memory.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server minimum memory.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server minimum memory.",
        SerializedName = @"minServerMemoryMB",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlInstanceSettingMinServerMemoryMb { get => ParametersBody.SqlInstanceSettingMinServerMemoryMb ?? default(int); set => ParametersBody.SqlInstanceSettingMinServerMemoryMb = value; }

        /// <summary>SQL Server default file path</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server default file path")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server default file path",
        SerializedName = @"defaultFilePath",
        PossibleTypes = new [] { typeof(string) })]
        public string SqlLogSettingDefaultFilePath { get => ParametersBody.SqlLogSettingDefaultFilePath ?? null; set => ParametersBody.SqlLogSettingDefaultFilePath = value; }

        /// <summary>Logical Unit Numbers for the disks.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Logical Unit Numbers for the disks.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Logical Unit Numbers for the disks.",
        SerializedName = @"luns",
        PossibleTypes = new [] { typeof(int) })]
        public int[] SqlLogSettingLun { get => ParametersBody.SqlLogSettingLun ?? null /* arrayOf */; set => ParametersBody.SqlLogSettingLun = value; }

        /// <summary>SQL Server Management type.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server Management type.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server Management type.",
        SerializedName = @"sqlManagement",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlManagementMode) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlManagementMode))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlManagementMode SqlManagement { get => ParametersBody.SqlManagement ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlManagementMode)""); set => ParametersBody.SqlManagement = value; }

        /// <summary>SQL Server license type.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server license type.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server license type.",
        SerializedName = @"sqlServerLicenseType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlServerLicenseType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlServerLicenseType))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlServerLicenseType SqlServerLicenseType { get => ParametersBody.SqlServerLicenseType ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlServerLicenseType)""); set => ParametersBody.SqlServerLicenseType = value; }

        /// <summary>Disk configuration to apply to SQL Server.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Disk configuration to apply to SQL Server.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Disk configuration to apply to SQL Server.",
        SerializedName = @"diskConfigurationType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DiskConfigurationType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DiskConfigurationType))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DiskConfigurationType SqlStorageUpdateSettingDiskConfigurationType { get => ParametersBody.SqlStorageUpdateSettingDiskConfigurationType ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DiskConfigurationType)""); set => ParametersBody.SqlStorageUpdateSettingDiskConfigurationType = value; }

        /// <summary>Virtual machine disk count.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Virtual machine disk count.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Virtual machine disk count.",
        SerializedName = @"diskCount",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlStorageUpdateSettingDiskCount { get => ParametersBody.SqlStorageUpdateSettingDiskCount ?? default(int); set => ParametersBody.SqlStorageUpdateSettingDiskCount = value; }

        /// <summary>Device id of the first disk to be updated.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Device id of the first disk to be updated.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Device id of the first disk to be updated.",
        SerializedName = @"startingDeviceId",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlStorageUpdateSettingStartingDeviceId { get => ParametersBody.SqlStorageUpdateSettingStartingDeviceId ?? default(int); set => ParametersBody.SqlStorageUpdateSettingStartingDeviceId = value; }

        /// <summary>SQL Server default file count</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server default file count")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server default file count",
        SerializedName = @"dataFileCount",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlTempDbSettingDataFileCount { get => ParametersBody.SqlTempDbSettingDataFileCount ?? default(int); set => ParametersBody.SqlTempDbSettingDataFileCount = value; }

        /// <summary>SQL Server default file size</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server default file size")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server default file size",
        SerializedName = @"dataFileSize",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlTempDbSettingDataFileSize { get => ParametersBody.SqlTempDbSettingDataFileSize ?? default(int); set => ParametersBody.SqlTempDbSettingDataFileSize = value; }

        /// <summary>SQL Server default file autoGrowth size</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server default file autoGrowth size")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server default file autoGrowth size",
        SerializedName = @"dataGrowth",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlTempDbSettingDataGrowth { get => ParametersBody.SqlTempDbSettingDataGrowth ?? default(int); set => ParametersBody.SqlTempDbSettingDataGrowth = value; }

        /// <summary>SQL Server default file path</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server default file path")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server default file path",
        SerializedName = @"defaultFilePath",
        PossibleTypes = new [] { typeof(string) })]
        public string SqlTempDbSettingDefaultFilePath { get => ParametersBody.SqlTempDbSettingDefaultFilePath ?? null; set => ParametersBody.SqlTempDbSettingDefaultFilePath = value; }

        /// <summary>SQL Server default file size</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server default file size")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server default file size",
        SerializedName = @"logFileSize",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlTempDbSettingLogFileSize { get => ParametersBody.SqlTempDbSettingLogFileSize ?? default(int); set => ParametersBody.SqlTempDbSettingLogFileSize = value; }

        /// <summary>SQL Server default file autoGrowth size</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server default file autoGrowth size")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server default file autoGrowth size",
        SerializedName = @"logGrowth",
        PossibleTypes = new [] { typeof(int) })]
        public int SqlTempDbSettingLogGrowth { get => ParametersBody.SqlTempDbSettingLogGrowth ?? default(int); set => ParametersBody.SqlTempDbSettingLogGrowth = value; }

        /// <summary>Logical Unit Numbers for the disks.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Logical Unit Numbers for the disks.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Logical Unit Numbers for the disks.",
        SerializedName = @"luns",
        PossibleTypes = new [] { typeof(int) })]
        public int[] SqlTempDbSettingLun { get => ParametersBody.SqlTempDbSettingLun ?? null /* arrayOf */; set => ParametersBody.SqlTempDbSettingLun = value; }

        /// <summary>
        /// ARM resource id of the SQL virtual machine group this SQL virtual machine is or will be part of.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "ARM resource id of the SQL virtual machine group this SQL virtual machine is or will be part of.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ARM resource id of the SQL virtual machine group this SQL virtual machine is or will be part of.",
        SerializedName = @"sqlVirtualMachineGroupResourceId",
        PossibleTypes = new [] { typeof(string) })]
        public string SqlVirtualMachineGroupResourceId { get => ParametersBody.GroupResourceId ?? null; set => ParametersBody.GroupResourceId = value; }

        /// <summary>SQL Server workload type.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server workload type.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server workload type.",
        SerializedName = @"sqlWorkloadType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlWorkloadType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlWorkloadType))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlWorkloadType SqlWorkloadTypeUpdateSettingSqlWorkloadType { get => ParametersBody.SqlWorkloadTypeUpdateSettingSqlWorkloadType ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.SqlWorkloadType)""); set => ParametersBody.SqlWorkloadTypeUpdateSettingSqlWorkloadType = value; }

        /// <summary>Disk configuration to apply to SQL Server.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Disk configuration to apply to SQL Server.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Disk configuration to apply to SQL Server.",
        SerializedName = @"diskConfigurationType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DiskConfigurationType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DiskConfigurationType))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DiskConfigurationType StorageConfigurationSettingDiskConfigurationType { get => ParametersBody.StorageConfigurationSettingDiskConfigurationType ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.DiskConfigurationType)""); set => ParametersBody.StorageConfigurationSettingDiskConfigurationType = value; }

        /// <summary>SQL Server SystemDb Storage on DataPool if true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL Server SystemDb Storage on DataPool if true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL Server SystemDb Storage on DataPool if true.",
        SerializedName = @"sqlSystemDbOnDataDisk",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter StorageConfigurationSettingSqlSystemDbOnDataDisk { get => ParametersBody.StorageConfigurationSettingSqlSystemDbOnDataDisk ?? default(global::System.Management.Automation.SwitchParameter); set => ParametersBody.StorageConfigurationSettingSqlSystemDbOnDataDisk = value; }

        /// <summary>Storage workload type.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Storage workload type.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Storage workload type.",
        SerializedName = @"storageWorkloadType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.StorageWorkloadType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.StorageWorkloadType))]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.StorageWorkloadType StorageConfigurationSettingStorageWorkloadType { get => ParametersBody.StorageConfigurationSettingStorageWorkloadType ?? ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Support.StorageWorkloadType)""); set => ParametersBody.StorageConfigurationSettingStorageWorkloadType = value; }

        /// <summary>Backing field for <see cref="SubscriptionId" /> property.</summary>
        private string _subscriptionId;

        /// <summary>Subscription ID that identifies an Azure subscription.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "Subscription ID that identifies an Azure subscription.")]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Subscription ID that identifies an Azure subscription.",
        SerializedName = @"subscriptionId",
        PossibleTypes = new [] { typeof(string) })]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.DefaultInfo(
        Name = @"",
        Description =@"",
        Script = @"(Get-AzContext).Subscription.Id")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Path)]
        public string SubscriptionId { get => this._subscriptionId; set => this._subscriptionId = value; }

        /// <summary>Resource tags.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Resource tags.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource tags.",
        SerializedName = @"tags",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.ITrackedResourceTags) })]
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.ITrackedResourceTags Tag { get => ParametersBody.Tag ?? null /* object */; set => ParametersBody.Tag = value; }

        /// <summary>
        /// ARM Resource id of underlying virtual machine created from SQL marketplace image.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "ARM Resource id of underlying virtual machine created from SQL marketplace image.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ARM Resource id of underlying virtual machine created from SQL marketplace image.",
        SerializedName = @"virtualMachineResourceId",
        PossibleTypes = new [] { typeof(string) })]
        public string VirtualMachineResourceId { get => ParametersBody.VirtualMachineResourceId ?? null; set => ParametersBody.VirtualMachineResourceId = value; }

        /// <summary>Cluster bootstrap account password.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Cluster bootstrap account password.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Cluster bootstrap account password.",
        SerializedName = @"clusterBootstrapAccountPassword",
        PossibleTypes = new [] { typeof(string) })]
        public string WsfcDomainCredentialsClusterBootstrapAccountPassword { get => ParametersBody.WsfcDomainCredentialsClusterBootstrapAccountPassword ?? null; set => ParametersBody.WsfcDomainCredentialsClusterBootstrapAccountPassword = value; }

        /// <summary>Cluster operator account password.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Cluster operator account password.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Cluster operator account password.",
        SerializedName = @"clusterOperatorAccountPassword",
        PossibleTypes = new [] { typeof(string) })]
        public string WsfcDomainCredentialsClusterOperatorAccountPassword { get => ParametersBody.WsfcDomainCredentialsClusterOperatorAccountPassword ?? null; set => ParametersBody.WsfcDomainCredentialsClusterOperatorAccountPassword = value; }

        /// <summary>SQL service account password.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SQL service account password.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category(global::Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SQL service account password.",
        SerializedName = @"sqlServiceAccountPassword",
        PossibleTypes = new [] { typeof(string) })]
        public string WsfcDomainCredentialsSqlServiceAccountPassword { get => ParametersBody.WsfcDomainCredentialsSqlServiceAccountPassword ?? null; set => ParametersBody.WsfcDomainCredentialsSqlServiceAccountPassword = value; }

        /// <summary>
        /// <c>overrideOnDefault</c> will be called before the regular onDefault has been processed, allowing customization of what
        /// happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="returnNow">/// Determines if the rest of the onDefault method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnDefault(global::System.Net.Http.HttpResponseMessage responseMessage, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnOk</c> will be called before the regular onOk has been processed, allowing customization of what happens
        /// on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.ISqlVirtualMachine"
        /// /> from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onOk method should be processed, or if the method should return
        /// immediately (set to true to skip further processing )</param>

        partial void overrideOnOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.ISqlVirtualMachine> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            var telemetryId = Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Module.Instance.GetTelemetryId.Invoke();
            if (telemetryId != "" && telemetryId != "internal")
            {
                __correlationId = telemetryId;
            }
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break)
            {
                Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.AttachDebugger.Break();
            }
            ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.CmdletBeginProcessing).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Creates a duplicate instance of this cmdlet (via JSON serialization).</summary>
        /// <returns>a duplicate instance of NewAzSqlVirtualMachineSqlVirtualMachine_CreateExpanded</returns>
        public Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Cmdlets.NewAzSqlVirtualMachineSqlVirtualMachine_CreateExpanded Clone()
        {
            var clone = new NewAzSqlVirtualMachineSqlVirtualMachine_CreateExpanded();
            clone.__correlationId = this.__correlationId;
            clone.__processRecordId = this.__processRecordId;
            clone.DefaultProfile = this.DefaultProfile;
            clone.InvocationInformation = this.InvocationInformation;
            clone.Proxy = this.Proxy;
            clone.Pipeline = this.Pipeline;
            clone.AsJob = this.AsJob;
            clone.Break = this.Break;
            clone.ProxyCredential = this.ProxyCredential;
            clone.ProxyUseDefaultCredentials = this.ProxyUseDefaultCredentials;
            clone.HttpPipelinePrepend = this.HttpPipelinePrepend;
            clone.HttpPipelineAppend = this.HttpPipelineAppend;
            clone.ParametersBody = this.ParametersBody;
            clone.ResourceGroupName = this.ResourceGroupName;
            clone.Name = this.Name;
            clone.SubscriptionId = this.SubscriptionId;
            return clone;
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {

        }

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the message is completed.
        /// </returns>
         async global::System.Threading.Tasks.Task Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.Warning:
                    {
                        WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.Information:
                    {
                        // When an operation supports asjob, Information messages must go thru verbose.
                        WriteVerbose($"INFORMATION: {(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.Debug:
                    {
                        WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.Error:
                    {
                        WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.DelayBeforePolling:
                    {
                        if (true == MyInvocation?.BoundParameters?.ContainsKey("NoWait"))
                        {
                            var data = messageData();
                            if (data.ResponseMessage is System.Net.Http.HttpResponseMessage response)
                            {
                                var asyncOperation = response.GetFirstHeader(@"Azure-AsyncOperation");
                                var location = response.GetFirstHeader(@"Location");
                                var uri = global::System.String.IsNullOrEmpty(asyncOperation) ? global::System.String.IsNullOrEmpty(location) ? response.RequestMessage.RequestUri.AbsoluteUri : location : asyncOperation;
                                WriteObject(new Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.PowerShell.AsyncOperationResponse { Target = uri });
                                // do nothing more.
                                data.Cancel();
                                return;
                            }
                        }
                        break;
                    }
                }
                await Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Module.Instance.Signal(id, token, messageData, (i,t,m) => ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Signal(i,t,()=> Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.EventDataConverter.ConvertFrom( m() ) as Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.EventData ), InvocationInformation, this.ParameterSetName, __correlationId, __processRecordId, null );
                if (token.IsCancellationRequested)
                {
                    return ;
                }
                WriteDebug($"{id}: {(messageData().Message ?? global::System.String.Empty)}");
            }
        }

        /// <summary>
        /// Intializes a new instance of the <see cref="NewAzSqlVirtualMachineSqlVirtualMachine_CreateExpanded" /> cmdlet class.
        /// </summary>
        public NewAzSqlVirtualMachineSqlVirtualMachine_CreateExpanded()
        {

        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.CmdletProcessRecordStart).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
            __processRecordId = System.Guid.NewGuid().ToString();
            try
            {
                // work
                if (ShouldProcess($"Call remote 'SqlVirtualMachinesCreateOrUpdate' operation"))
                {
                    if (true == MyInvocation?.BoundParameters?.ContainsKey("AsJob"))
                    {
                        var instance = this.Clone();
                        var job = new Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.PowerShell.AsyncJob(instance, this.MyInvocation.Line, this.MyInvocation.MyCommand.Name, this._cancellationTokenSource.Token, this._cancellationTokenSource.Cancel);
                        JobRepository.Add(job);
                        var task = instance.ProcessRecordAsync();
                        job.Monitor(task);
                        WriteObject(job);
                    }
                    else
                    {
                        using( var asyncCommandRuntime = new Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.PowerShell.AsyncCommandRuntime(this, ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Token) )
                        {
                            asyncCommandRuntime.Wait( ProcessRecordAsync(),((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Token);
                        }
                    }
                }
            }
            catch (global::System.AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach( var innerException in aggregateException.Flatten().InnerExceptions )
                {
                    ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.CmdletException, $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // Write exception out to error channel.
                    WriteError( new global::System.Management.Automation.ErrorRecord(innerException,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
                }
            }
            catch (global::System.Exception exception) when ((exception as System.Management.Automation.PipelineStoppedException)== null || (exception as System.Management.Automation.PipelineStoppedException).InnerException != null)
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.CmdletException, $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                // Write exception out to error channel.
                WriteError( new global::System.Management.Automation.ErrorRecord(exception,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
            }
            finally
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }

        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async global::System.Threading.Tasks.Task ProcessRecordAsync()
        {
            using( NoSynchronizationContext )
            {
                await ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.CmdletGetPipeline); if( ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                Pipeline = Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Module.Instance.CreatePipeline(InvocationInformation, __correlationId, __processRecordId, this.ParameterSetName);
                if (null != HttpPipelinePrepend)
                {
                    Pipeline.Prepend((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ?? HttpPipelinePrepend);
                }
                if (null != HttpPipelineAppend)
                {
                    Pipeline.Append((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ?? HttpPipelineAppend);
                }
                // get the client instance
                try
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.CmdletBeforeAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    await this.Client.SqlVirtualMachinesCreateOrUpdate(ResourceGroupName, Name, SubscriptionId, ParametersBody, onOk, onDefault, this, Pipeline);
                    await ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.CmdletAfterAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                }
                catch (Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.UndeclaredResponseException urexception)
                {
                    WriteError(new global::System.Management.Automation.ErrorRecord(urexception, urexception.StatusCode.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  ResourceGroupName=ResourceGroupName,Name=Name,SubscriptionId=SubscriptionId,body=ParametersBody})
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(urexception.Message) { RecommendedAction = urexception.Action }
                    });
                }
                finally
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.IEventListener)this).Cancel();
            base.StopProcessing();
        }

        /// <summary>
        /// a delegate that is called when the remote service returns default (any response code not handled elsewhere).
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onDefault(global::System.Net.Http.HttpResponseMessage responseMessage)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnDefault(responseMessage, ref _returnNow);
                // if overrideOnDefault has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // Error Response : default
                // Unrecognized Response. Create an error record based on what we have.
                var ex = new Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.RestException(responseMessage);
                WriteError( new global::System.Management.Automation.ErrorRecord(ex, ex.Code, global::System.Management.Automation.ErrorCategory.InvalidOperation, new { ResourceGroupName=ResourceGroupName, Name=Name, SubscriptionId=SubscriptionId, body=ParametersBody })
                {
                  ErrorDetails = new global::System.Management.Automation.ErrorDetails(ex.Message) { RecommendedAction = ex.Action }
                });
            }
        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.ISqlVirtualMachine"
        /// /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.ISqlVirtualMachine> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnOk(responseMessage, response, ref _returnNow);
                // if overrideOnOk has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onOk - response for 200 / application/json
                // (await response) // should be Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.Api20211101Preview.ISqlVirtualMachine
                WriteObject((await response));
            }
        }
    }
}
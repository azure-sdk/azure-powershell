// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ServiceMap
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Extensions;

    /// <summary>
    /// Low-level API implementation for the Service Map service.
    /// Service Map API Reference
    /// </summary>
    public partial class ServiceMap
    {

        /// <summary>Retrieves the specified client group</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="clientGroupName">Client Group resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ClientGroupsGet(string subscriptionId, string resourceGroupName, string workspaceName, string clientGroupName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IClientGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/clientGroups/"
                        + global::System.Uri.EscapeDataString(clientGroupName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ClientGroupsGet_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns the approximate number of members in the client group.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="clientGroupName">Client Group resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ClientGroupsGetMembersCount(string subscriptionId, string resourceGroupName, string workspaceName, string clientGroupName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IClientGroupMembersCount>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/clientGroups/"
                        + global::System.Uri.EscapeDataString(clientGroupName)
                        + "/membersCount"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ClientGroupsGetMembersCount_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns the approximate number of members in the client group.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ClientGroupsGetMembersCountViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IClientGroupMembersCount>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/clientGroups/(?<clientGroupName>[^/]+)/membersCount$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/clientGroups/{clientGroupName}/membersCount'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var clientGroupName = _match.Groups["clientGroupName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/clientGroups/"
                        + clientGroupName
                        + "/membersCount"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ClientGroupsGetMembersCount_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ClientGroupsGetMembersCount" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ClientGroupsGetMembersCount_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IClientGroupMembersCount>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ClientGroupMembersCount.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ClientGroupsGetMembersCount" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="clientGroupName">Client Group resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ClientGroupsGetMembersCount_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string clientGroupName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(clientGroupName),clientGroupName);
                await eventListener.AssertMinimumLength(nameof(clientGroupName),clientGroupName,3);
                await eventListener.AssertMaximumLength(nameof(clientGroupName),clientGroupName,256);
            }
        }

        /// <summary>Retrieves the specified client group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ClientGroupsGetViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IClientGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/clientGroups/(?<clientGroupName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/clientGroups/{clientGroupName}'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var clientGroupName = _match.Groups["clientGroupName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/clientGroups/"
                        + clientGroupName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ClientGroupsGet_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ClientGroupsGet" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ClientGroupsGet_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IClientGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ClientGroup.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ClientGroupsGet" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="clientGroupName">Client Group resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ClientGroupsGet_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string clientGroupName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(clientGroupName),clientGroupName);
                await eventListener.AssertMinimumLength(nameof(clientGroupName),clientGroupName,3);
                await eventListener.AssertMaximumLength(nameof(clientGroupName),clientGroupName,256);
            }
        }

        /// <summary>Returns the members of the client group during the specified time interval.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="clientGroupName">Client Group resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="Top">Page size to use. When not specified, the default page size is 100 records.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ClientGroupsListMembers(string subscriptionId, string resourceGroupName, string workspaceName, string clientGroupName, global::System.DateTime? startTime, global::System.DateTime? endTime, int? Top, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IClientGroupMembersCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/clientGroups/"
                        + global::System.Uri.EscapeDataString(clientGroupName)
                        + "/members"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == Top ? global::System.String.Empty : "$top=" + global::System.Uri.EscapeDataString(Top.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ClientGroupsListMembers_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns the members of the client group during the specified time interval.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="Top">Page size to use. When not specified, the default page size is 100 records.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ClientGroupsListMembersViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, int? Top, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IClientGroupMembersCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/clientGroups/(?<clientGroupName>[^/]+)/members$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/clientGroups/{clientGroupName}/members'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var clientGroupName = _match.Groups["clientGroupName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/clientGroups/"
                        + clientGroupName
                        + "/members"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == Top ? global::System.String.Empty : "$top=" + global::System.Uri.EscapeDataString(Top.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ClientGroupsListMembers_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ClientGroupsListMembers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ClientGroupsListMembers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IClientGroupMembersCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ClientGroupMembersCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ClientGroupsListMembers" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="clientGroupName">Client Group resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="Top">Page size to use. When not specified, the default page size is 100 records.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ClientGroupsListMembers_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string clientGroupName, global::System.DateTime? startTime, global::System.DateTime? endTime, int? Top, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(clientGroupName),clientGroupName);
                await eventListener.AssertMinimumLength(nameof(clientGroupName),clientGroupName,3);
                await eventListener.AssertMaximumLength(nameof(clientGroupName),clientGroupName,256);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(Top),Top,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(Top),Top,200);
            }
        }

        /// <summary>Creates a new machine group.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="body">Machine Group resource to create.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachineGroupsCreate(string subscriptionId, string resourceGroupName, string workspaceName, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machineGroups"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachineGroupsCreate_Call(request,onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>Creates a new machine group.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Machine Group resource to create.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachineGroupsCreateViaIdentity(global::System.String viaIdentity, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machineGroups$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machineGroups'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machineGroups"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachineGroupsCreate_Call(request,onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachineGroupsCreate" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachineGroupsCreate_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Created:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onCreated(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.MachineGroup.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachineGroupsCreate" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="body">Machine Group resource to create.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachineGroupsCreate_Validate(string subscriptionId, string resourceGroupName, string workspaceName, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup body, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Deletes the specified Machine Group.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineGroupName">Machine Group resource name.</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachineGroupsDelete(string subscriptionId, string resourceGroupName, string workspaceName, string machineGroupName, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machineGroups/"
                        + global::System.Uri.EscapeDataString(machineGroupName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachineGroupsDelete_Call(request,onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>Deletes the specified Machine Group.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachineGroupsDeleteViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machineGroups/(?<machineGroupName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machineGroups/{machineGroupName}'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineGroupName = _match.Groups["machineGroupName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machineGroups/"
                        + machineGroupName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachineGroupsDelete_Call(request,onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachineGroupsDelete" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachineGroupsDelete_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.NoContent:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNoContent(_response);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachineGroupsDelete" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineGroupName">Machine Group resource name.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachineGroupsDelete_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineGroupName, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineGroupName),machineGroupName);
                await eventListener.AssertMinimumLength(nameof(machineGroupName),machineGroupName,36);
                await eventListener.AssertMaximumLength(nameof(machineGroupName),machineGroupName,36);
            }
        }

        /// <summary>
        /// Returns the specified machine group as it existed during the specified time interval.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineGroupName">Machine Group resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachineGroupsGet(string subscriptionId, string resourceGroupName, string workspaceName, string machineGroupName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machineGroups/"
                        + global::System.Uri.EscapeDataString(machineGroupName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachineGroupsGet_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Returns the specified machine group as it existed during the specified time interval.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachineGroupsGetViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machineGroups/(?<machineGroupName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machineGroups/{machineGroupName}'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineGroupName = _match.Groups["machineGroupName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machineGroups/"
                        + machineGroupName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachineGroupsGet_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachineGroupsGet" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachineGroupsGet_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.MachineGroup.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachineGroupsGet" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineGroupName">Machine Group resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachineGroupsGet_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineGroupName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineGroupName),machineGroupName);
                await eventListener.AssertMinimumLength(nameof(machineGroupName),machineGroupName,36);
                await eventListener.AssertMaximumLength(nameof(machineGroupName),machineGroupName,36);
            }
        }

        /// <summary>Returns all machine groups during the specified time interval.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachineGroupsListByWorkspace(string subscriptionId, string resourceGroupName, string workspaceName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroupCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machineGroups"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachineGroupsListByWorkspace_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns all machine groups during the specified time interval.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachineGroupsListByWorkspaceViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroupCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machineGroups$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machineGroups'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machineGroups"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachineGroupsListByWorkspace_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachineGroupsListByWorkspace" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachineGroupsListByWorkspace_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroupCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.MachineGroupCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachineGroupsListByWorkspace" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachineGroupsListByWorkspace_Validate(string subscriptionId, string resourceGroupName, string workspaceName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
            }
        }

        /// <summary>Updates a machine group.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineGroupName">Machine Group resource name.</param>
        /// <param name="body">Machine Group resource to update.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachineGroupsUpdate(string subscriptionId, string resourceGroupName, string workspaceName, string machineGroupName, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machineGroups/"
                        + global::System.Uri.EscapeDataString(machineGroupName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachineGroupsUpdate_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Updates a machine group.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Machine Group resource to update.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachineGroupsUpdateViaIdentity(global::System.String viaIdentity, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machineGroups/(?<machineGroupName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machineGroups/{machineGroupName}'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineGroupName = _match.Groups["machineGroupName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machineGroups/"
                        + machineGroupName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachineGroupsUpdate_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachineGroupsUpdate" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachineGroupsUpdate_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.MachineGroup.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachineGroupsUpdate" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineGroupName">Machine Group resource name.</param>
        /// <param name="body">Machine Group resource to update.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachineGroupsUpdate_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineGroupName, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroup body, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineGroupName),machineGroupName);
                await eventListener.AssertMinimumLength(nameof(machineGroupName),machineGroupName,36);
                await eventListener.AssertMaximumLength(nameof(machineGroupName),machineGroupName,36);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Returns the specified machine.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate the machine resource.
        /// When not specified, the service uses DateTime.UtcNow.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesGet(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, global::System.DateTime? timestamp, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachine>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timestamp ? global::System.String.Empty : "timestamp=" + timestamp?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesGet_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Obtains the liveness status of the machine during the specified time interval.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesGetLiveness(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ILiveness>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/liveness"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesGetLiveness_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Obtains the liveness status of the machine during the specified time interval.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesGetLivenessViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ILiveness>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/liveness$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/liveness'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/liveness"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesGetLiveness_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachinesGetLiveness" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesGetLiveness_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ILiveness>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.Liveness.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachinesGetLiveness" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesGetLiveness_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
            }
        }

        /// <summary>Returns the specified machine.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate the machine resource.
        /// When not specified, the service uses DateTime.UtcNow.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesGetViaIdentity(global::System.String viaIdentity, global::System.DateTime? timestamp, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachine>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timestamp ? global::System.String.Empty : "timestamp=" + timestamp?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesGet_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachinesGet" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesGet_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachine>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.Machine.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachinesGet" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate the machine resource.
        /// When not specified, the service uses DateTime.UtcNow.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesGet_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, global::System.DateTime? timestamp, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
            }
        }

        /// <summary>
        /// Returns a collection of machines matching the specified conditions. The returned collection represents either machines
        /// that are active/live during the specified interval of time (`live=true` and `startTime`/`endTime` are specified) or that
        /// are known to have existed at or some time prior to the specified point in time (`live=false` and `timestamp` is specified).
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="live">Specifies whether to return live resources (true) or inventory resources (false). Defaults to **true**.
        /// When retrieving live resources, the start time (`startTime`) and end time (`endTime`) of the desired interval should be
        /// included. When retrieving inventory resources, an optional timestamp (`timestamp`) parameter can be specified to return
        /// the version of each resource closest (not-after) that timestamp.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate each machine resource.
        /// Only applies when `live=false`. When not specified, the service uses DateTime.UtcNow.</param>
        /// <param name="Top">Page size to use. When not specified, the default page size is 100 records.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesListByWorkspace(string subscriptionId, string resourceGroupName, string workspaceName, bool? live, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.DateTime? timestamp, int? Top, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == live ? global::System.String.Empty : "live=" + global::System.Uri.EscapeDataString(live.ToString()))
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == timestamp ? global::System.String.Empty : "timestamp=" + timestamp?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == Top ? global::System.String.Empty : "$top=" + global::System.Uri.EscapeDataString(Top.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesListByWorkspace_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Returns a collection of machines matching the specified conditions. The returned collection represents either machines
        /// that are active/live during the specified interval of time (`live=true` and `startTime`/`endTime` are specified) or that
        /// are known to have existed at or some time prior to the specified point in time (`live=false` and `timestamp` is specified).
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="live">Specifies whether to return live resources (true) or inventory resources (false). Defaults to **true**.
        /// When retrieving live resources, the start time (`startTime`) and end time (`endTime`) of the desired interval should be
        /// included. When retrieving inventory resources, an optional timestamp (`timestamp`) parameter can be specified to return
        /// the version of each resource closest (not-after) that timestamp.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate each machine resource.
        /// Only applies when `live=false`. When not specified, the service uses DateTime.UtcNow.</param>
        /// <param name="Top">Page size to use. When not specified, the default page size is 100 records.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesListByWorkspaceViaIdentity(global::System.String viaIdentity, bool? live, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.DateTime? timestamp, int? Top, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == live ? global::System.String.Empty : "live=" + global::System.Uri.EscapeDataString(live.ToString()))
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == timestamp ? global::System.String.Empty : "timestamp=" + timestamp?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == Top ? global::System.String.Empty : "$top=" + global::System.Uri.EscapeDataString(Top.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesListByWorkspace_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachinesListByWorkspace" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesListByWorkspace_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.MachineCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachinesListByWorkspace" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="live">Specifies whether to return live resources (true) or inventory resources (false). Defaults to **true**.
        /// When retrieving live resources, the start time (`startTime`) and end time (`endTime`) of the desired interval should be
        /// included. When retrieving inventory resources, an optional timestamp (`timestamp`) parameter can be specified to return
        /// the version of each resource closest (not-after) that timestamp.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate each machine resource.
        /// Only applies when `live=false`. When not specified, the service uses DateTime.UtcNow.</param>
        /// <param name="Top">Page size to use. When not specified, the default page size is 100 records.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesListByWorkspace_Validate(string subscriptionId, string resourceGroupName, string workspaceName, bool? live, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.DateTime? timestamp, int? Top, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertIsGreaterThanOrEqual(nameof(Top),Top,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(Top),Top,200);
            }
        }

        /// <summary>
        /// Returns a collection of connections terminating or originating at the specified machine
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesListConnections(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IConnectionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/connections"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesListConnections_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Returns a collection of connections terminating or originating at the specified machine
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesListConnectionsViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IConnectionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/connections$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/connections'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/connections"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesListConnections_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachinesListConnections" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesListConnections_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IConnectionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ConnectionCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachinesListConnections" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesListConnections_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
            }
        }

        /// <summary>
        /// Returns a collection of machine groups this machine belongs to during the specified time interval.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesListMachineGroupMembership(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroupCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/machineGroups"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesListMachineGroupMembership_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Returns a collection of machine groups this machine belongs to during the specified time interval.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesListMachineGroupMembershipViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroupCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/machineGroups$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/machineGroups'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/machineGroups"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesListMachineGroupMembership_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachinesListMachineGroupMembership" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesListMachineGroupMembership_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachineGroupCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.MachineGroupCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachinesListMachineGroupMembership" /> method. Call this like the actual call, but you
        /// will get validation events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesListMachineGroupMembership_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
            }
        }

        /// <summary>
        /// Returns a collection of live ports on the specified machine during the specified time interval.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesListPorts(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IPortCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/ports"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesListPorts_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Returns a collection of live ports on the specified machine during the specified time interval.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesListPortsViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IPortCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/ports$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/ports'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/ports"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesListPorts_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachinesListPorts" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesListPorts_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IPortCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.PortCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachinesListPorts" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesListPorts_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
            }
        }

        /// <summary>
        /// Returns a collection of processes on the specified machine matching the specified conditions. The returned collection
        /// represents either processes that are active/live during the specified interval of time (`live=true` and `startTime`/`endTime`
        /// are specified) or that are known to have existed at or some time prior to the specified point in time (`live=false` and
        /// `timestamp` is specified).
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="live">Specifies whether to return live resources (true) or inventory resources (false). Defaults to **true**.
        /// When retrieving live resources, the start time (`startTime`) and end time (`endTime`) of the desired interval should be
        /// included. When retrieving inventory resources, an optional timestamp (`timestamp`) parameter can be specified to return
        /// the version of each resource closest (not-after) that timestamp.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate all process resource.
        /// Only applies when `live=false`. When not specified, the service uses DateTime.UtcNow.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesListProcesses(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, bool? live, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.DateTime? timestamp, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IProcessCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/processes"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == live ? global::System.String.Empty : "live=" + global::System.Uri.EscapeDataString(live.ToString()))
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == timestamp ? global::System.String.Empty : "timestamp=" + timestamp?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesListProcesses_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Returns a collection of processes on the specified machine matching the specified conditions. The returned collection
        /// represents either processes that are active/live during the specified interval of time (`live=true` and `startTime`/`endTime`
        /// are specified) or that are known to have existed at or some time prior to the specified point in time (`live=false` and
        /// `timestamp` is specified).
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="live">Specifies whether to return live resources (true) or inventory resources (false). Defaults to **true**.
        /// When retrieving live resources, the start time (`startTime`) and end time (`endTime`) of the desired interval should be
        /// included. When retrieving inventory resources, an optional timestamp (`timestamp`) parameter can be specified to return
        /// the version of each resource closest (not-after) that timestamp.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate all process resource.
        /// Only applies when `live=false`. When not specified, the service uses DateTime.UtcNow.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MachinesListProcessesViaIdentity(global::System.String viaIdentity, bool? live, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.DateTime? timestamp, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IProcessCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/processes$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/processes'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/processes"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == live ? global::System.String.Empty : "live=" + global::System.Uri.EscapeDataString(live.ToString()))
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == timestamp ? global::System.String.Empty : "timestamp=" + timestamp?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MachinesListProcesses_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MachinesListProcesses" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesListProcesses_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IProcessCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ProcessCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MachinesListProcesses" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="live">Specifies whether to return live resources (true) or inventory resources (false). Defaults to **true**.
        /// When retrieving live resources, the start time (`startTime`) and end time (`endTime`) of the desired interval should be
        /// included. When retrieving inventory resources, an optional timestamp (`timestamp`) parameter can be specified to return
        /// the version of each resource closest (not-after) that timestamp.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate all process resource.
        /// Only applies when `live=false`. When not specified, the service uses DateTime.UtcNow.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MachinesListProcesses_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, bool? live, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.DateTime? timestamp, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
            }
        }

        /// <summary>Generates the specified map.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="body">Request options.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MapsGenerate(string subscriptionId, string resourceGroupName, string workspaceName, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMapRequest body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMapResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/generateMap"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MapsGenerate_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Generates the specified map.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Request options.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MapsGenerateViaIdentity(global::System.String viaIdentity, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMapRequest body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMapResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/generateMap$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/generateMap'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/generateMap"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MapsGenerate_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="MapsGenerate" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MapsGenerate_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMapResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.MapResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MapsGenerate" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="body">Request options.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MapsGenerate_Validate(string subscriptionId, string resourceGroupName, string workspaceName, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMapRequest body, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// Returns the specified port. The port must be live during the specified time interval. If the port is not live during the
        /// interval, status 404 (Not Found) is returned.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="portName">Port resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PortsGet(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string portName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IPort>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/ports/"
                        + global::System.Uri.EscapeDataString(portName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PortsGet_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Obtains the liveness status of the port during the specified time interval.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="portName">Port resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PortsGetLiveness(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string portName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ILiveness>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/ports/"
                        + global::System.Uri.EscapeDataString(portName)
                        + "/liveness"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PortsGetLiveness_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Obtains the liveness status of the port during the specified time interval.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PortsGetLivenessViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ILiveness>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/ports/(?<portName>[^/]+)/liveness$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/ports/{portName}/liveness'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                var portName = _match.Groups["portName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/ports/"
                        + portName
                        + "/liveness"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PortsGetLiveness_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PortsGetLiveness" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PortsGetLiveness_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ILiveness>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.Liveness.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PortsGetLiveness" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="portName">Port resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PortsGetLiveness_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string portName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
                await eventListener.AssertNotNull(nameof(portName),portName);
                await eventListener.AssertMinimumLength(nameof(portName),portName,3);
                await eventListener.AssertMaximumLength(nameof(portName),portName,64);
            }
        }

        /// <summary>
        /// Returns the specified port. The port must be live during the specified time interval. If the port is not live during the
        /// interval, status 404 (Not Found) is returned.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PortsGetViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IPort>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/ports/(?<portName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/ports/{portName}'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                var portName = _match.Groups["portName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/ports/"
                        + portName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PortsGet_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PortsGet" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PortsGet_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IPort>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.Port.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PortsGet" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="portName">Port resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PortsGet_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string portName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
                await eventListener.AssertNotNull(nameof(portName),portName);
                await eventListener.AssertMinimumLength(nameof(portName),portName,3);
                await eventListener.AssertMaximumLength(nameof(portName),portName,64);
            }
        }

        /// <summary>Returns a collection of processes accepting on the specified port</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="portName">Port resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PortsListAcceptingProcesses(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string portName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IProcessCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/ports/"
                        + global::System.Uri.EscapeDataString(portName)
                        + "/acceptingProcesses"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PortsListAcceptingProcesses_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns a collection of processes accepting on the specified port</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PortsListAcceptingProcessesViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IProcessCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/ports/(?<portName>[^/]+)/acceptingProcesses$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/ports/{portName}/acceptingProcesses'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                var portName = _match.Groups["portName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/ports/"
                        + portName
                        + "/acceptingProcesses"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PortsListAcceptingProcesses_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PortsListAcceptingProcesses" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PortsListAcceptingProcesses_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IProcessCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ProcessCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PortsListAcceptingProcesses" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="portName">Port resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PortsListAcceptingProcesses_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string portName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
                await eventListener.AssertNotNull(nameof(portName),portName);
                await eventListener.AssertMinimumLength(nameof(portName),portName,3);
                await eventListener.AssertMaximumLength(nameof(portName),portName,64);
            }
        }

        /// <summary>Returns a collection of connections established via the specified port.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="portName">Port resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PortsListConnections(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string portName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IConnectionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/ports/"
                        + global::System.Uri.EscapeDataString(portName)
                        + "/connections"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PortsListConnections_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns a collection of connections established via the specified port.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PortsListConnectionsViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IConnectionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/ports/(?<portName>[^/]+)/connections$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/ports/{portName}/connections'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                var portName = _match.Groups["portName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/ports/"
                        + portName
                        + "/connections"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PortsListConnections_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PortsListConnections" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PortsListConnections_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IConnectionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ConnectionCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PortsListConnections" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="portName">Port resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PortsListConnections_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string portName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
                await eventListener.AssertNotNull(nameof(portName),portName);
                await eventListener.AssertMinimumLength(nameof(portName),portName,3);
                await eventListener.AssertMaximumLength(nameof(portName),portName,64);
            }
        }

        /// <summary>Returns the specified process.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="processName">Process resource name.</param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate a resource. When not
        /// specified, the service uses DateTime.UtcNow.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ProcessesGet(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string processName, global::System.DateTime? timestamp, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IProcess>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/processes/"
                        + global::System.Uri.EscapeDataString(processName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timestamp ? global::System.String.Empty : "timestamp=" + timestamp?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ProcessesGet_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Obtains the liveness status of the process during the specified time interval.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="processName">Process resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ProcessesGetLiveness(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string processName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ILiveness>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/processes/"
                        + global::System.Uri.EscapeDataString(processName)
                        + "/liveness"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ProcessesGetLiveness_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Obtains the liveness status of the process during the specified time interval.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ProcessesGetLivenessViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ILiveness>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/processes/(?<processName>[^/]+)/liveness$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/processes/{processName}/liveness'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                var processName = _match.Groups["processName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/processes/"
                        + processName
                        + "/liveness"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ProcessesGetLiveness_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ProcessesGetLiveness" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ProcessesGetLiveness_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ILiveness>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.Liveness.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ProcessesGetLiveness" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="processName">Process resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ProcessesGetLiveness_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string processName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
                await eventListener.AssertNotNull(nameof(processName),processName);
                await eventListener.AssertMinimumLength(nameof(processName),processName,3);
                await eventListener.AssertMaximumLength(nameof(processName),processName,128);
            }
        }

        /// <summary>Returns the specified process.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate a resource. When not
        /// specified, the service uses DateTime.UtcNow.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ProcessesGetViaIdentity(global::System.String viaIdentity, global::System.DateTime? timestamp, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IProcess>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/processes/(?<processName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/processes/{processName}'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                var processName = _match.Groups["processName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/processes/"
                        + processName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timestamp ? global::System.String.Empty : "timestamp=" + timestamp?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ProcessesGet_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ProcessesGet" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ProcessesGet_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IProcess>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.Process.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ProcessesGet" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="processName">Process resource name.</param>
        /// <param name="timestamp">UTC date and time specifying a time instance relative to which to evaluate a resource. When not
        /// specified, the service uses DateTime.UtcNow.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ProcessesGet_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string processName, global::System.DateTime? timestamp, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
                await eventListener.AssertNotNull(nameof(processName),processName);
                await eventListener.AssertMinimumLength(nameof(processName),processName,3);
                await eventListener.AssertMaximumLength(nameof(processName),processName,128);
            }
        }

        /// <summary>Returns a collection of ports on which this process is accepting</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="processName">Process resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ProcessesListAcceptingPorts(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string processName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IPortCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/processes/"
                        + global::System.Uri.EscapeDataString(processName)
                        + "/acceptingPorts"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ProcessesListAcceptingPorts_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns a collection of ports on which this process is accepting</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ProcessesListAcceptingPortsViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IPortCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/processes/(?<processName>[^/]+)/acceptingPorts$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/processes/{processName}/acceptingPorts'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                var processName = _match.Groups["processName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/processes/"
                        + processName
                        + "/acceptingPorts"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ProcessesListAcceptingPorts_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ProcessesListAcceptingPorts" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ProcessesListAcceptingPorts_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IPortCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.PortCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ProcessesListAcceptingPorts" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="processName">Process resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ProcessesListAcceptingPorts_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string processName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
                await eventListener.AssertNotNull(nameof(processName),processName);
                await eventListener.AssertMinimumLength(nameof(processName),processName,3);
                await eventListener.AssertMaximumLength(nameof(processName),processName,128);
            }
        }

        /// <summary>
        /// Returns a collection of connections terminating or originating at the specified process
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="processName">Process resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ProcessesListConnections(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string processName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IConnectionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/machines/"
                        + global::System.Uri.EscapeDataString(machineName)
                        + "/processes/"
                        + global::System.Uri.EscapeDataString(processName)
                        + "/connections"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ProcessesListConnections_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Returns a collection of connections terminating or originating at the specified process
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ProcessesListConnectionsViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IConnectionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/machines/(?<machineName>[^/]+)/processes/(?<processName>[^/]+)/connections$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/machines/{machineName}/processes/{processName}/connections'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                var machineName = _match.Groups["machineName"].Value;
                var processName = _match.Groups["processName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/machines/"
                        + machineName
                        + "/processes/"
                        + processName
                        + "/connections"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ProcessesListConnections_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ProcessesListConnections" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ProcessesListConnections_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IConnectionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ConnectionCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ProcessesListConnections" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="machineName">Machine resource name.</param>
        /// <param name="processName">Process resource name.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ProcessesListConnections_Validate(string subscriptionId, string resourceGroupName, string workspaceName, string machineName, string processName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
                await eventListener.AssertNotNull(nameof(machineName),machineName);
                await eventListener.AssertMinimumLength(nameof(machineName),machineName,3);
                await eventListener.AssertMaximumLength(nameof(machineName),machineName,64);
                await eventListener.AssertNotNull(nameof(processName),processName);
                await eventListener.AssertMinimumLength(nameof(processName),processName,3);
                await eventListener.AssertMaximumLength(nameof(processName),processName,128);
            }
        }

        /// <summary>Returns summary information about the machines in the workspace.</summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task SummariesGetMachines(string subscriptionId, string resourceGroupName, string workspaceName, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachinesSummary>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/resourceGroups/"
                        + global::System.Uri.EscapeDataString(resourceGroupName)
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + global::System.Uri.EscapeDataString(workspaceName)
                        + "/features/serviceMap/summaries/machines"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.SummariesGetMachines_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns summary information about the machines in the workspace.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task SummariesGetMachinesViaIdentity(global::System.String viaIdentity, global::System.DateTime? startTime, global::System.DateTime? endTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachinesSummary>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2015-11-01-preview";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/Microsoft.OperationalInsights/workspaces/(?<workspaceName>[^/]+)/features/serviceMap/summaries/machines$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.OperationalInsights/workspaces/{workspaceName}/features/serviceMap/summaries/machines'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                var resourceGroupName = _match.Groups["resourceGroupName"].Value;
                var workspaceName = _match.Groups["workspaceName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/resourceGroups/"
                        + resourceGroupName
                        + "/providers/Microsoft.OperationalInsights/workspaces/"
                        + workspaceName
                        + "/features/serviceMap/summaries/machines"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endTime ? global::System.String.Empty : "endTime=" + endTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.SummariesGetMachines_Call(request,onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="SummariesGetMachines" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task SummariesGetMachines_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IMachinesSummary>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.MachinesSummary.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Models.Api20151101Preview.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="SummariesGetMachines" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subscriptionId">Azure subscription identifier.</param>
        /// <param name="resourceGroupName">Resource group name within the specified subscriptionId.</param>
        /// <param name="workspaceName">OMS workspace containing the resources of interest.</param>
        /// <param name="startTime">UTC date and time specifying the start time of an interval. When not specified the service uses
        /// DateTime.UtcNow - 10m</param>
        /// <param name="endTime">UTC date and time specifying the end time of an interval. When not specified the service uses DateTime.UtcNow</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task SummariesGetMachines_Validate(string subscriptionId, string resourceGroupName, string workspaceName, global::System.DateTime? startTime, global::System.DateTime? endTime, Microsoft.Azure.PowerShell.Cmdlets.ServiceMap.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertNotNull(nameof(resourceGroupName),resourceGroupName);
                await eventListener.AssertMinimumLength(nameof(resourceGroupName),resourceGroupName,1);
                await eventListener.AssertMaximumLength(nameof(resourceGroupName),resourceGroupName,64);
                await eventListener.AssertRegEx(nameof(resourceGroupName),resourceGroupName,@"[a-zA-Z0-9_-]+");
                await eventListener.AssertNotNull(nameof(workspaceName),workspaceName);
                await eventListener.AssertMinimumLength(nameof(workspaceName),workspaceName,3);
                await eventListener.AssertMaximumLength(nameof(workspaceName),workspaceName,63);
                await eventListener.AssertRegEx(nameof(workspaceName),workspaceName,@"[a-zA-Z0-9_][a-zA-Z0-9_-]+[a-zA-Z0-9_]");
            }
        }
    }
}
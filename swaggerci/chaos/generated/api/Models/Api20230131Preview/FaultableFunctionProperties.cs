// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Extensions;

    /// <summary>Application function in which fault can be injected</summary>
    public partial class FaultableFunctionProperties :
        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFaultableFunctionProperties,
        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFaultableFunctionPropertiesInternal
    {

        /// <summary>culture of an archive</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public string ArchiveCulture { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).ArchiveCulture; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).ArchiveCulture = value ?? null; }

        /// <summary>name of an archive which defines the function</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public string ArchiveName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).ArchiveName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).ArchiveName = value ?? null; }

        /// <summary>public key token of an archive</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public string ArchivePublicKeyToken { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).ArchivePublicKeyToken; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).ArchivePublicKeyToken = value ?? null; }

        /// <summary>defines the type of an archive</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public string ArchiveType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).ArchiveType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).ArchiveType = value ?? null; }

        /// <summary>version of an archive</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public string ArchiveVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).ArchiveVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).ArchiveVersion = value ?? null; }

        /// <summary>Backing field for <see cref="Category" /> property.</summary>
        private string _category;

        /// <summary>SDK or Custom library in which fault is injected</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Owned)]
        public string Category { get => this._category; set => this._category = value; }

        /// <summary>Backing field for <see cref="FaultCapability" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFaultCapabilityProperties[] _faultCapability;

        /// <summary>faults supported by torch for the function</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFaultCapabilityProperties[] FaultCapability { get => this._faultCapability; set => this._faultCapability = value; }

        /// <summary>Internal Acessors for Signature</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignatureProperties Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFaultableFunctionPropertiesInternal.Signature { get => (this._signature = this._signature ?? new Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.SignatureProperties()); set { {_signature = value;} } }

        /// <summary>Internal Acessors for SignatureArchive</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesArchive Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFaultableFunctionPropertiesInternal.SignatureArchive { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).Archive; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).Archive = value; }

        /// <summary>Backing field for <see cref="Signature" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignatureProperties _signature;

        /// <summary>Method Signature of the faultable function</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignatureProperties Signature { get => (this._signature = this._signature ?? new Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.SignatureProperties()); set => this._signature = value; }

        /// <summary>List of arguments of a function</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFunctionArguments[] SignatureArgument { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).Argument; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).Argument = value ?? null /* arrayOf */; }

        /// <summary>Namespace in which the function is defined</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public string SignatureFunctionNamespace { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).FunctionNamespace; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).FunctionNamespace = value ; }

        /// <summary>Number of types defined in a generic</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public int? SignatureGenericCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).GenericCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).GenericCount = value ?? default(int); }

        /// <summary>Types defined if Class is a generic class</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public string[] SignatureGenericType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).GenericType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).GenericType = value ?? null /* arrayOf */; }

        /// <summary>Name of a function</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public string SignatureName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).Name = value ; }

        /// <summary>ClassName in which the function is defined</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Origin(Microsoft.Azure.PowerShell.Cmdlets.Chaos.PropertyOrigin.Inlined)]
        public string SignatureType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesInternal)Signature).Type = value ; }

        /// <summary>Creates an new <see cref="FaultableFunctionProperties" /> instance.</summary>
        public FaultableFunctionProperties()
        {

        }
    }
    /// Application function in which fault can be injected
    public partial interface IFaultableFunctionProperties :
        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.IJsonSerializable
    {
        /// <summary>culture of an archive</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"culture of an archive",
        SerializedName = @"culture",
        PossibleTypes = new [] { typeof(string) })]
        string ArchiveCulture { get; set; }
        /// <summary>name of an archive which defines the function</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"name of an archive which defines the function",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string ArchiveName { get; set; }
        /// <summary>public key token of an archive</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"public key token of an archive",
        SerializedName = @"publicKeyToken",
        PossibleTypes = new [] { typeof(string) })]
        string ArchivePublicKeyToken { get; set; }
        /// <summary>defines the type of an archive</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"defines the type of an archive",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        string ArchiveType { get; set; }
        /// <summary>version of an archive</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"version of an archive",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string ArchiveVersion { get; set; }
        /// <summary>SDK or Custom library in which fault is injected</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SDK or Custom library in which fault is injected",
        SerializedName = @"category",
        PossibleTypes = new [] { typeof(string) })]
        string Category { get; set; }
        /// <summary>faults supported by torch for the function</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"faults supported by torch for the function",
        SerializedName = @"faultCapabilities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFaultCapabilityProperties) })]
        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFaultCapabilityProperties[] FaultCapability { get; set; }
        /// <summary>List of arguments of a function</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of arguments of a function",
        SerializedName = @"arguments",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFunctionArguments) })]
        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFunctionArguments[] SignatureArgument { get; set; }
        /// <summary>Namespace in which the function is defined</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Namespace in which the function is defined",
        SerializedName = @"functionNamespace",
        PossibleTypes = new [] { typeof(string) })]
        string SignatureFunctionNamespace { get; set; }
        /// <summary>Number of types defined in a generic</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of types defined in a generic",
        SerializedName = @"genericCount",
        PossibleTypes = new [] { typeof(int) })]
        int? SignatureGenericCount { get; set; }
        /// <summary>Types defined if Class is a generic class</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Types defined if Class is a generic class",
        SerializedName = @"genericTypes",
        PossibleTypes = new [] { typeof(string) })]
        string[] SignatureGenericType { get; set; }
        /// <summary>Name of a function</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Name of a function",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string SignatureName { get; set; }
        /// <summary>ClassName in which the function is defined</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Chaos.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"ClassName in which the function is defined",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        string SignatureType { get; set; }

    }
    /// Application function in which fault can be injected
    internal partial interface IFaultableFunctionPropertiesInternal

    {
        /// <summary>culture of an archive</summary>
        string ArchiveCulture { get; set; }
        /// <summary>name of an archive which defines the function</summary>
        string ArchiveName { get; set; }
        /// <summary>public key token of an archive</summary>
        string ArchivePublicKeyToken { get; set; }
        /// <summary>defines the type of an archive</summary>
        string ArchiveType { get; set; }
        /// <summary>version of an archive</summary>
        string ArchiveVersion { get; set; }
        /// <summary>SDK or Custom library in which fault is injected</summary>
        string Category { get; set; }
        /// <summary>faults supported by torch for the function</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFaultCapabilityProperties[] FaultCapability { get; set; }
        /// <summary>Method Signature of the faultable function</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignatureProperties Signature { get; set; }

        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.ISignaturePropertiesArchive SignatureArchive { get; set; }
        /// <summary>List of arguments of a function</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Chaos.Models.Api20230131Preview.IFunctionArguments[] SignatureArgument { get; set; }
        /// <summary>Namespace in which the function is defined</summary>
        string SignatureFunctionNamespace { get; set; }
        /// <summary>Number of types defined in a generic</summary>
        int? SignatureGenericCount { get; set; }
        /// <summary>Types defined if Class is a generic class</summary>
        string[] SignatureGenericType { get; set; }
        /// <summary>Name of a function</summary>
        string SignatureName { get; set; }
        /// <summary>ClassName in which the function is defined</summary>
        string SignatureType { get; set; }

    }
}
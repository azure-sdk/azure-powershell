// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Extensions;

    /// <summary>Represents a migration resource for patch.</summary>
    public partial class MigrationResourceForPatch :
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourceForPatch,
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourceForPatchInternal
    {

        /// <summary>Password for source server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public string AdminCredentialsSourceServerPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).AdminCredentialsSourceServerPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).AdminCredentialsSourceServerPassword = value ?? null; }

        /// <summary>Password for target server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public string AdminCredentialsTargetServerPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).AdminCredentialsTargetServerPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).AdminCredentialsTargetServerPassword = value ?? null; }

        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.CancelEnum? Cancel { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).Cancel; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).Cancel = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.CancelEnum)""); }

        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public string[] DbsToCancelMigrationOn { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).DbsToCancelMigrationOn; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).DbsToCancelMigrationOn = value ?? null /* arrayOf */; }

        /// <summary>Number of databases to migrate</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public string[] DbsToMigrate { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).DbsToMigrate; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).DbsToMigrate = value ?? null /* arrayOf */; }

        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public string[] DbsToTriggerCutoverOn { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).DbsToTriggerCutoverOn; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).DbsToTriggerCutoverOn = value ?? null /* arrayOf */; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatch Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourceForPatchInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.MigrationResourcePropertiesForPatch()); set { {_property = value;} } }

        /// <summary>Internal Acessors for SecretParameter</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationSecretParameters Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourceForPatchInternal.SecretParameter { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SecretParameter; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SecretParameter = value; }

        /// <summary>Internal Acessors for SecretParameterAdminCredentials</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IAdminCredentials Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourceForPatchInternal.SecretParameterAdminCredentials { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SecretParameterAdminCredentials; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SecretParameterAdminCredentials = value; }

        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.MigrateRolesEnum? MigrateRole { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).MigrateRole; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).MigrateRole = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.MigrateRolesEnum)""); }

        /// <summary>There are two types of migration modes Online and Offline</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.MigrationMode? MigrationMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).MigrationMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).MigrationMode = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.MigrationMode)""); }

        /// <summary>Start time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public global::System.DateTime? MigrationWindowStartTimeInUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).MigrationWindowStartTimeInUtc; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).MigrationWindowStartTimeInUtc = value ?? default(global::System.DateTime); }

        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).OverwriteDbsInTarget; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).OverwriteDbsInTarget = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.OverwriteDbsInTargetEnum)""); }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatch _property;

        /// <summary>Migration resource properties.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatch Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.MigrationResourcePropertiesForPatch()); set => this._property = value; }

        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public string SecretParameterSourceServerUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SecretParameterSourceServerUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SecretParameterSourceServerUsername = value ?? null; }

        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public string SecretParameterTargetServerUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SecretParameterTargetServerUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SecretParameterTargetServerUsername = value ?? null; }

        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SetupLogicalReplicationOnSourceDbIfNeeded; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SetupLogicalReplicationOnSourceDbIfNeeded = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.LogicalReplicationOnSourceDbEnum)""); }

        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public string SourceDbServerFullyQualifiedDomainName { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SourceDbServerFullyQualifiedDomainName; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SourceDbServerFullyQualifiedDomainName = value ?? null; }

        /// <summary>ResourceId of the source database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public string SourceDbServerResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SourceDbServerResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).SourceDbServerResourceId = value ?? null; }

        /// <summary>Indicates whether the data migration should start right away</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.StartDataMigrationEnum? StartDataMigration { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).StartDataMigration; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).StartDataMigration = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.StartDataMigrationEnum)""); }

        /// <summary>Backing field for <see cref="Tag" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourceForPatchTags _tag;

        /// <summary>Application-specific metadata in the form of key-value pairs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourceForPatchTags Tag { get => (this._tag = this._tag ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.MigrationResourceForPatchTags()); set => this._tag = value; }

        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public string TargetDbServerFullyQualifiedDomainName { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).TargetDbServerFullyQualifiedDomainName; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).TargetDbServerFullyQualifiedDomainName = value ?? null; }

        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.TriggerCutoverEnum? TriggerCutover { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).TriggerCutover; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatchInternal)Property).TriggerCutover = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.TriggerCutoverEnum)""); }

        /// <summary>Creates an new <see cref="MigrationResourceForPatch" /> instance.</summary>
        public MigrationResourceForPatch()
        {

        }
    }
    /// Represents a migration resource for patch.
    public partial interface IMigrationResourceForPatch :
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.IJsonSerializable
    {
        /// <summary>Password for source server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Password for source server.",
        SerializedName = @"sourceServerPassword",
        PossibleTypes = new [] { typeof(string) })]
        string AdminCredentialsSourceServerPassword { get; set; }
        /// <summary>Password for target server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Password for target server.",
        SerializedName = @"targetServerPassword",
        PossibleTypes = new [] { typeof(string) })]
        string AdminCredentialsTargetServerPassword { get; set; }
        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To trigger cancel for entire migration we need to send this flag as True",
        SerializedName = @"cancel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.CancelEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.CancelEnum? Cancel { get; set; }
        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When you want to trigger cancel for specific databases send cancel flag as True and database names in this array",
        SerializedName = @"dbsToCancelMigrationOn",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToCancelMigrationOn { get; set; }
        /// <summary>Number of databases to migrate</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of databases to migrate",
        SerializedName = @"dbsToMigrate",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToMigrate { get; set; }
        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array",
        SerializedName = @"dbsToTriggerCutoverOn",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToTriggerCutoverOn { get; set; }
        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To migrate roles and permissions we need to send this flag as True",
        SerializedName = @"migrateRoles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.MigrateRolesEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.MigrateRolesEnum? MigrateRole { get; set; }
        /// <summary>There are two types of migration modes Online and Offline</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"There are two types of migration modes Online and Offline",
        SerializedName = @"migrationMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.MigrationMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.MigrationMode? MigrationMode { get; set; }
        /// <summary>Start time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Start time in UTC for migration window",
        SerializedName = @"migrationWindowStartTimeInUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? MigrationWindowStartTimeInUtc { get; set; }
        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration workflow will wait for a confirmation, if it detects that the database already exists.",
        SerializedName = @"overwriteDbsInTarget",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.OverwriteDbsInTargetEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get; set; }
        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets the username for the source server. This user need not be an admin.",
        SerializedName = @"sourceServerUsername",
        PossibleTypes = new [] { typeof(string) })]
        string SecretParameterSourceServerUsername { get; set; }
        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets the username for the target server. This user need not be an admin.",
        SerializedName = @"targetServerUsername",
        PossibleTypes = new [] { typeof(string) })]
        string SecretParameterTargetServerUsername { get; set; }
        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether to setup LogicalReplicationOnSourceDb, if needed",
        SerializedName = @"setupLogicalReplicationOnSourceDbIfNeeded",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.LogicalReplicationOnSourceDbEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get; set; }
        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration service will always use it for connection",
        SerializedName = @"sourceDbServerFullyQualifiedDomainName",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>ResourceId of the source database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ResourceId of the source database server",
        SerializedName = @"sourceDbServerResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerResourceId { get; set; }
        /// <summary>Indicates whether the data migration should start right away</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the data migration should start right away",
        SerializedName = @"startDataMigration",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.StartDataMigrationEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.StartDataMigrationEnum? StartDataMigration { get; set; }
        /// <summary>Application-specific metadata in the form of key-value pairs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Application-specific metadata in the form of key-value pairs.",
        SerializedName = @"tags",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourceForPatchTags) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourceForPatchTags Tag { get; set; }
        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration service will always use it for connection",
        SerializedName = @"targetDbServerFullyQualifiedDomainName",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To trigger cutover for entire migration we need to send this flag as True",
        SerializedName = @"triggerCutover",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.TriggerCutoverEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.TriggerCutoverEnum? TriggerCutover { get; set; }

    }
    /// Represents a migration resource for patch.
    internal partial interface IMigrationResourceForPatchInternal

    {
        /// <summary>Password for source server.</summary>
        string AdminCredentialsSourceServerPassword { get; set; }
        /// <summary>Password for target server.</summary>
        string AdminCredentialsTargetServerPassword { get; set; }
        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.CancelEnum? Cancel { get; set; }
        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        string[] DbsToCancelMigrationOn { get; set; }
        /// <summary>Number of databases to migrate</summary>
        string[] DbsToMigrate { get; set; }
        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        string[] DbsToTriggerCutoverOn { get; set; }
        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.MigrateRolesEnum? MigrateRole { get; set; }
        /// <summary>There are two types of migration modes Online and Offline</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.MigrationMode? MigrationMode { get; set; }
        /// <summary>Start time in UTC for migration window</summary>
        global::System.DateTime? MigrationWindowStartTimeInUtc { get; set; }
        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get; set; }
        /// <summary>Migration resource properties.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourcePropertiesForPatch Property { get; set; }
        /// <summary>Migration secret parameters</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationSecretParameters SecretParameter { get; set; }
        /// <summary>Admin credentials for source and target servers</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IAdminCredentials SecretParameterAdminCredentials { get; set; }
        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        string SecretParameterSourceServerUsername { get; set; }
        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        string SecretParameterTargetServerUsername { get; set; }
        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get; set; }
        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        string SourceDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>ResourceId of the source database server</summary>
        string SourceDbServerResourceId { get; set; }
        /// <summary>Indicates whether the data migration should start right away</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.StartDataMigrationEnum? StartDataMigration { get; set; }
        /// <summary>Application-specific metadata in the form of key-value pairs.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20250315Privatepreview.IMigrationResourceForPatchTags Tag { get; set; }
        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        string TargetDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.TriggerCutoverEnum? TriggerCutover { get; set; }

    }
}
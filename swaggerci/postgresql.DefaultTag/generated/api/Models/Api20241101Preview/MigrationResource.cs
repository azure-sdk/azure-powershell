// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Extensions;

    /// <summary>Represents a migration resource.</summary>
    public partial class MigrationResource :
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResource,
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal,
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ITrackedResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ITrackedResource __trackedResource = new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.TrackedResource();

        /// <summary>Password for source server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string AdminCredentialsSourceServerPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).AdminCredentialsSourceServerPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).AdminCredentialsSourceServerPassword = value ?? null; }

        /// <summary>Password for target server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string AdminCredentialsTargetServerPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).AdminCredentialsTargetServerPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).AdminCredentialsTargetServerPassword = value ?? null; }

        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? Cancel { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).Cancel; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).Cancel = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum)""); }

        /// <summary>Error message, if any, for the migration state</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string CurrentStatusError { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentStatusError; }

        /// <summary>State of migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationState? CurrentStatusState { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentStatusState; }

        /// <summary>Migration sub state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationSubState? CurrentSubStateDetailCurrentSubState { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentSubStateDetailCurrentSubState; }

        /// <summary>Dictionary of <DbMigrationStatus></summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationSubStateDetailsDbDetails CurrentSubStateDetailDbDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentSubStateDetailDbDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentSubStateDetailDbDetail = value ?? null /* model class */; }

        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string[] DbsToCancelMigrationOn { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).DbsToCancelMigrationOn; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).DbsToCancelMigrationOn = value ?? null /* arrayOf */; }

        /// <summary>Number of databases to migrate</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string[] DbsToMigrate { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).DbsToMigrate; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).DbsToMigrate = value ?? null /* arrayOf */; }

        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string[] DbsToTriggerCutoverOn { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).DbsToTriggerCutoverOn; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).DbsToTriggerCutoverOn = value ?? null /* arrayOf */; }

        /// <summary>
        /// Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).Id; }

        /// <summary>The geo-location where the resource lives</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public string Location { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ITrackedResourceInternal)__trackedResource).Location; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ITrackedResourceInternal)__trackedResource).Location = value ; }

        /// <summary>Internal Acessors for CurrentStatus</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationStatus Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.CurrentStatus { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentStatus; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentStatus = value; }

        /// <summary>Internal Acessors for CurrentStatusCurrentSubStateDetail</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationSubStateDetails Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.CurrentStatusCurrentSubStateDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentStatusCurrentSubStateDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentStatusCurrentSubStateDetail = value; }

        /// <summary>Internal Acessors for CurrentStatusError</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.CurrentStatusError { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentStatusError; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentStatusError = value; }

        /// <summary>Internal Acessors for CurrentStatusState</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationState? Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.CurrentStatusState { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentStatusState; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentStatusState = value; }

        /// <summary>Internal Acessors for CurrentSubStateDetailCurrentSubState</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationSubState? Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.CurrentSubStateDetailCurrentSubState { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentSubStateDetailCurrentSubState; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentSubStateDetailCurrentSubState = value; }

        /// <summary>Internal Acessors for CurrentSubStateDetailValidationDetail</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IValidationDetails Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.CurrentSubStateDetailValidationDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentSubStateDetailValidationDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).CurrentSubStateDetailValidationDetail = value; }

        /// <summary>Internal Acessors for MigrationId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.MigrationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationId; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationId = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceProperties Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.MigrationResourceProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for SecretParameter</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationSecretParameters Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.SecretParameter { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SecretParameter; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SecretParameter = value; }

        /// <summary>Internal Acessors for SecretParameterAdminCredentials</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IAdminCredentials Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.SecretParameterAdminCredentials { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SecretParameterAdminCredentials; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SecretParameterAdminCredentials = value; }

        /// <summary>Internal Acessors for SourceDbServerMetadata</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IDbServerMetadata Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.SourceDbServerMetadata { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadata; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadata = value; }

        /// <summary>Internal Acessors for SourceDbServerMetadataLocation</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.SourceDbServerMetadataLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataLocation; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataLocation = value; }

        /// <summary>Internal Acessors for SourceDbServerMetadataSku</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IServerSku Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.SourceDbServerMetadataSku { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataSku; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataSku = value; }

        /// <summary>Internal Acessors for TargetDbServerMetadata</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IDbServerMetadata Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.TargetDbServerMetadata { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadata; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadata = value; }

        /// <summary>Internal Acessors for TargetDbServerMetadataLocation</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.TargetDbServerMetadataLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataLocation; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataLocation = value; }

        /// <summary>Internal Acessors for TargetDbServerMetadataSku</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IServerSku Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.TargetDbServerMetadataSku { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataSku; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataSku = value; }

        /// <summary>Internal Acessors for TargetDbServerResourceId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceInternal.TargetDbServerResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerResourceId = value; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).Name = value; }

        /// <summary>Internal Acessors for SystemData</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ISystemData Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal.SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemData; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemData = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).Type = value; }

        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? MigrateRole { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrateRole; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrateRole = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum)""); }

        /// <summary>ID for migration, a GUID.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string MigrationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationId; }

        /// <summary>ResourceId of the private endpoint migration instance</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string MigrationInstanceResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationInstanceResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationInstanceResourceId = value ?? null; }

        /// <summary>There are two types of migration modes Online and Offline</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? MigrationMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationMode = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode)""); }

        /// <summary>This indicates the supported Migration option for the migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationOption? MigrationOption { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationOption; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationOption = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationOption)""); }

        /// <summary>End time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public global::System.DateTime? MigrationWindowEndTimeInUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationWindowEndTimeInUtc; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationWindowEndTimeInUtc = value ?? default(global::System.DateTime); }

        /// <summary>Start time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public global::System.DateTime? MigrationWindowStartTimeInUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationWindowStartTimeInUtc; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).MigrationWindowStartTimeInUtc = value ?? default(global::System.DateTime); }

        /// <summary>The name of the resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).Name; }

        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).OverwriteDbsInTarget; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).OverwriteDbsInTarget = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum)""); }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceProperties _property;

        /// <summary>Migration resource properties.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.MigrationResourceProperties()); set => this._property = value; }

        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SecretParameterSourceServerUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SecretParameterSourceServerUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SecretParameterSourceServerUsername = value ?? null; }

        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SecretParameterTargetServerUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SecretParameterTargetServerUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SecretParameterTargetServerUsername = value ?? null; }

        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SetupLogicalReplicationOnSourceDbIfNeeded; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SetupLogicalReplicationOnSourceDbIfNeeded = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum)""); }

        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SourceDbServerFullyQualifiedDomainName { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerFullyQualifiedDomainName; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerFullyQualifiedDomainName = value ?? null; }

        /// <summary>Location of database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SourceDbServerMetadataLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataLocation; }

        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SourceDbServerMetadataSkuName { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataSkuName; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataSkuName = value ?? null; }

        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? SourceDbServerMetadataSkuTier { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataSkuTier; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataSkuTier = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier)""); }

        /// <summary>Storage size in MB for database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public int? SourceDbServerMetadataStorageMb { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataStorageMb; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataStorageMb = value ?? default(int); }

        /// <summary>Version for database engine</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SourceDbServerMetadataVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerMetadataVersion = value ?? null; }

        /// <summary>
        /// ResourceId of the source database server in case the sourceType is PostgreSQLSingleServer. For other source types this
        /// should be ipaddress:port@username or hostname:port@username
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SourceDbServerResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceDbServerResourceId = value ?? null; }

        /// <summary>
        /// migration source server type : OnPremises, AWS, GCP, AzureVM, PostgreSQLSingleServer, AWS_RDS, AWS_AURORA, AWS_EC2, GCP_CloudSQL,
        /// GCP_AlloyDB, GCP_Compute, EDB, EDB_Oracle_Server, EDB_PostgreSQL, PostgreSQLFlexibleServer, PostgreSQLCosmosDB, Huawei_RDS,
        /// Huawei_Compute, Heroku_PostgreSQL, Crunchy_PostgreSQL, ApsaraDB_RDS, Digital_Ocean_Droplets, Digital_Ocean_PostgreSQL,
        /// or Supabase_PostgreSQL
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SourceType? SourceType { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceType; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SourceType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SourceType)""); }

        /// <summary>
        /// SSL modes for migration. Default SSL mode for PostgreSQLSingleServer is VerifyFull and Prefer for other source types
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SslMode? SslMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SslMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).SslMode = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SslMode)""); }

        /// <summary>Indicates whether the data migration should start right away</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? StartDataMigration { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).StartDataMigration; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).StartDataMigration = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum)""); }

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ISystemData SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemData; }

        /// <summary>The timestamp of resource creation (UTC).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataCreatedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataCreatedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public string SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataCreatedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataCreatedBy = value ?? null; }

        /// <summary>The type of identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CreatedByType? SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataCreatedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataCreatedByType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CreatedByType)""); }

        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataLastModifiedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataLastModifiedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataLastModifiedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataLastModifiedBy = value ?? null; }

        /// <summary>The type of identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CreatedByType? SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataLastModifiedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).SystemDataLastModifiedByType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CreatedByType)""); }

        /// <summary>Resource tags.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ITrackedResourceTags Tag { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ITrackedResourceInternal)__trackedResource).Tag; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ITrackedResourceInternal)__trackedResource).Tag = value ?? null /* model class */; }

        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string TargetDbServerFullyQualifiedDomainName { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerFullyQualifiedDomainName; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerFullyQualifiedDomainName = value ?? null; }

        /// <summary>Location of database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string TargetDbServerMetadataLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataLocation; }

        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string TargetDbServerMetadataSkuName { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataSkuName; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataSkuName = value ?? null; }

        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? TargetDbServerMetadataSkuTier { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataSkuTier; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataSkuTier = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier)""); }

        /// <summary>Storage size in MB for database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public int? TargetDbServerMetadataStorageMb { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataStorageMb; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataStorageMb = value ?? default(int); }

        /// <summary>Version for database engine</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string TargetDbServerMetadataVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerMetadataVersion = value ?? null; }

        /// <summary>ResourceId of the source database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string TargetDbServerResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TargetDbServerResourceId; }

        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? TriggerCutover { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TriggerCutover; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).TriggerCutover = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum)""); }

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.IResourceInternal)__trackedResource).Type; }

        /// <summary>Details of server level validations</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IDbLevelValidationStatus[] ValidationDetailDbLevelValidationDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).ValidationDetailDbLevelValidationDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).ValidationDetailDbLevelValidationDetail = value ?? null /* arrayOf */; }

        /// <summary>Details of server level validations</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IValidationSummaryItem[] ValidationDetailServerLevelValidationDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).ValidationDetailServerLevelValidationDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).ValidationDetailServerLevelValidationDetail = value ?? null /* arrayOf */; }

        /// <summary>Validation status for migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.ValidationState? ValidationDetailStatus { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).ValidationDetailStatus; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).ValidationDetailStatus = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.ValidationState)""); }

        /// <summary>Validation End date-time in UTC</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public global::System.DateTime? ValidationDetailValidationEndTimeInUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).ValidationDetailValidationEndTimeInUtc; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).ValidationDetailValidationEndTimeInUtc = value ?? default(global::System.DateTime); }

        /// <summary>Validation Start date-time in UTC</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public global::System.DateTime? ValidationDetailValidationStartTimeInUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).ValidationDetailValidationStartTimeInUtc; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourcePropertiesInternal)Property).ValidationDetailValidationStartTimeInUtc = value ?? default(global::System.DateTime); }

        /// <summary>Creates an new <see cref="MigrationResource" /> instance.</summary>
        public MigrationResource()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__trackedResource), __trackedResource);
            await eventListener.AssertObjectIsValid(nameof(__trackedResource), __trackedResource);
        }
    }
    /// Represents a migration resource.
    public partial interface IMigrationResource :
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ITrackedResource
    {
        /// <summary>Password for source server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Password for source server.",
        SerializedName = @"sourceServerPassword",
        PossibleTypes = new [] { typeof(string) })]
        string AdminCredentialsSourceServerPassword { get; set; }
        /// <summary>Password for target server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Password for target server.",
        SerializedName = @"targetServerPassword",
        PossibleTypes = new [] { typeof(string) })]
        string AdminCredentialsTargetServerPassword { get; set; }
        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To trigger cancel for entire migration we need to send this flag as True",
        SerializedName = @"cancel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? Cancel { get; set; }
        /// <summary>Error message, if any, for the migration state</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Error message, if any, for the migration state",
        SerializedName = @"error",
        PossibleTypes = new [] { typeof(string) })]
        string CurrentStatusError { get;  }
        /// <summary>State of migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"State of migration",
        SerializedName = @"state",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationState) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationState? CurrentStatusState { get;  }
        /// <summary>Migration sub state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Migration sub state.",
        SerializedName = @"currentSubState",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationSubState) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationSubState? CurrentSubStateDetailCurrentSubState { get;  }
        /// <summary>Dictionary of <DbMigrationStatus></summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Dictionary of <DbMigrationStatus>",
        SerializedName = @"dbDetails",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationSubStateDetailsDbDetails) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationSubStateDetailsDbDetails CurrentSubStateDetailDbDetail { get; set; }
        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When you want to trigger cancel for specific databases send cancel flag as True and database names in this array",
        SerializedName = @"dbsToCancelMigrationOn",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToCancelMigrationOn { get; set; }
        /// <summary>Number of databases to migrate</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of databases to migrate",
        SerializedName = @"dbsToMigrate",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToMigrate { get; set; }
        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array",
        SerializedName = @"dbsToTriggerCutoverOn",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToTriggerCutoverOn { get; set; }
        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To migrate roles and permissions we need to send this flag as True",
        SerializedName = @"migrateRoles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? MigrateRole { get; set; }
        /// <summary>ID for migration, a GUID.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"ID for migration, a GUID.",
        SerializedName = @"migrationId",
        PossibleTypes = new [] { typeof(string) })]
        string MigrationId { get;  }
        /// <summary>ResourceId of the private endpoint migration instance</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ResourceId of the private endpoint migration instance",
        SerializedName = @"migrationInstanceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string MigrationInstanceResourceId { get; set; }
        /// <summary>There are two types of migration modes Online and Offline</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"There are two types of migration modes Online and Offline",
        SerializedName = @"migrationMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? MigrationMode { get; set; }
        /// <summary>This indicates the supported Migration option for the migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This indicates the supported Migration option for the migration",
        SerializedName = @"migrationOption",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationOption) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationOption? MigrationOption { get; set; }
        /// <summary>End time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"End time in UTC for migration window",
        SerializedName = @"migrationWindowEndTimeInUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? MigrationWindowEndTimeInUtc { get; set; }
        /// <summary>Start time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Start time in UTC for migration window",
        SerializedName = @"migrationWindowStartTimeInUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? MigrationWindowStartTimeInUtc { get; set; }
        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration workflow will wait for a confirmation, if it detects that the database already exists.",
        SerializedName = @"overwriteDbsInTarget",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get; set; }
        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets the username for the source server. This user need not be an admin.",
        SerializedName = @"sourceServerUsername",
        PossibleTypes = new [] { typeof(string) })]
        string SecretParameterSourceServerUsername { get; set; }
        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets the username for the target server. This user need not be an admin.",
        SerializedName = @"targetServerUsername",
        PossibleTypes = new [] { typeof(string) })]
        string SecretParameterTargetServerUsername { get; set; }
        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether to setup LogicalReplicationOnSourceDb, if needed",
        SerializedName = @"setupLogicalReplicationOnSourceDbIfNeeded",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get; set; }
        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration service will always use it for connection",
        SerializedName = @"sourceDbServerFullyQualifiedDomainName",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>Location of database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Location of database server",
        SerializedName = @"location",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerMetadataLocation { get;  }
        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerMetadataSkuName { get; set; }
        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The tier of the particular SKU, e.g. Burstable.",
        SerializedName = @"tier",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? SourceDbServerMetadataSkuTier { get; set; }
        /// <summary>Storage size in MB for database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Storage size in MB for database server",
        SerializedName = @"storageMb",
        PossibleTypes = new [] { typeof(int) })]
        int? SourceDbServerMetadataStorageMb { get; set; }
        /// <summary>Version for database engine</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Version for database engine",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerMetadataVersion { get; set; }
        /// <summary>
        /// ResourceId of the source database server in case the sourceType is PostgreSQLSingleServer. For other source types this
        /// should be ipaddress:port@username or hostname:port@username
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ResourceId of the source database server in case the sourceType is PostgreSQLSingleServer. For other source types this should be ipaddress:port@username or hostname:port@username",
        SerializedName = @"sourceDbServerResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerResourceId { get; set; }
        /// <summary>
        /// migration source server type : OnPremises, AWS, GCP, AzureVM, PostgreSQLSingleServer, AWS_RDS, AWS_AURORA, AWS_EC2, GCP_CloudSQL,
        /// GCP_AlloyDB, GCP_Compute, EDB, EDB_Oracle_Server, EDB_PostgreSQL, PostgreSQLFlexibleServer, PostgreSQLCosmosDB, Huawei_RDS,
        /// Huawei_Compute, Heroku_PostgreSQL, Crunchy_PostgreSQL, ApsaraDB_RDS, Digital_Ocean_Droplets, Digital_Ocean_PostgreSQL,
        /// or Supabase_PostgreSQL
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"migration source server type : OnPremises, AWS, GCP, AzureVM, PostgreSQLSingleServer, AWS_RDS, AWS_AURORA, AWS_EC2, GCP_CloudSQL, GCP_AlloyDB, GCP_Compute, EDB, EDB_Oracle_Server, EDB_PostgreSQL, PostgreSQLFlexibleServer, PostgreSQLCosmosDB, Huawei_RDS, Huawei_Compute, Heroku_PostgreSQL, Crunchy_PostgreSQL, ApsaraDB_RDS, Digital_Ocean_Droplets, Digital_Ocean_PostgreSQL, or Supabase_PostgreSQL",
        SerializedName = @"sourceType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SourceType) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SourceType? SourceType { get; set; }
        /// <summary>
        /// SSL modes for migration. Default SSL mode for PostgreSQLSingleServer is VerifyFull and Prefer for other source types
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SSL modes for migration. Default SSL mode for PostgreSQLSingleServer is VerifyFull and Prefer for other source types",
        SerializedName = @"sslMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SslMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SslMode? SslMode { get; set; }
        /// <summary>Indicates whether the data migration should start right away</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the data migration should start right away",
        SerializedName = @"startDataMigration",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? StartDataMigration { get; set; }
        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration service will always use it for connection",
        SerializedName = @"targetDbServerFullyQualifiedDomainName",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>Location of database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Location of database server",
        SerializedName = @"location",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerMetadataLocation { get;  }
        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerMetadataSkuName { get; set; }
        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The tier of the particular SKU, e.g. Burstable.",
        SerializedName = @"tier",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? TargetDbServerMetadataSkuTier { get; set; }
        /// <summary>Storage size in MB for database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Storage size in MB for database server",
        SerializedName = @"storageMb",
        PossibleTypes = new [] { typeof(int) })]
        int? TargetDbServerMetadataStorageMb { get; set; }
        /// <summary>Version for database engine</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Version for database engine",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerMetadataVersion { get; set; }
        /// <summary>ResourceId of the source database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"ResourceId of the source database server",
        SerializedName = @"targetDbServerResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerResourceId { get;  }
        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To trigger cutover for entire migration we need to send this flag as True",
        SerializedName = @"triggerCutover",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? TriggerCutover { get; set; }
        /// <summary>Details of server level validations</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Details of server level validations",
        SerializedName = @"dbLevelValidationDetails",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IDbLevelValidationStatus) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IDbLevelValidationStatus[] ValidationDetailDbLevelValidationDetail { get; set; }
        /// <summary>Details of server level validations</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Details of server level validations",
        SerializedName = @"serverLevelValidationDetails",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IValidationSummaryItem) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IValidationSummaryItem[] ValidationDetailServerLevelValidationDetail { get; set; }
        /// <summary>Validation status for migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Validation status for migration",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.ValidationState) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.ValidationState? ValidationDetailStatus { get; set; }
        /// <summary>Validation End date-time in UTC</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Validation End date-time in UTC",
        SerializedName = @"validationEndTimeInUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ValidationDetailValidationEndTimeInUtc { get; set; }
        /// <summary>Validation Start date-time in UTC</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Validation Start date-time in UTC",
        SerializedName = @"validationStartTimeInUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ValidationDetailValidationStartTimeInUtc { get; set; }

    }
    /// Represents a migration resource.
    internal partial interface IMigrationResourceInternal :
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api50.ITrackedResourceInternal
    {
        /// <summary>Password for source server.</summary>
        string AdminCredentialsSourceServerPassword { get; set; }
        /// <summary>Password for target server.</summary>
        string AdminCredentialsTargetServerPassword { get; set; }
        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? Cancel { get; set; }
        /// <summary>Current status of migration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationStatus CurrentStatus { get; set; }
        /// <summary>Current Migration sub state details.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationSubStateDetails CurrentStatusCurrentSubStateDetail { get; set; }
        /// <summary>Error message, if any, for the migration state</summary>
        string CurrentStatusError { get; set; }
        /// <summary>State of migration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationState? CurrentStatusState { get; set; }
        /// <summary>Migration sub state.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationSubState? CurrentSubStateDetailCurrentSubState { get; set; }
        /// <summary>Dictionary of <DbMigrationStatus></summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationSubStateDetailsDbDetails CurrentSubStateDetailDbDetail { get; set; }
        /// <summary>Details for the validation for migration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IValidationDetails CurrentSubStateDetailValidationDetail { get; set; }
        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        string[] DbsToCancelMigrationOn { get; set; }
        /// <summary>Number of databases to migrate</summary>
        string[] DbsToMigrate { get; set; }
        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        string[] DbsToTriggerCutoverOn { get; set; }
        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? MigrateRole { get; set; }
        /// <summary>ID for migration, a GUID.</summary>
        string MigrationId { get; set; }
        /// <summary>ResourceId of the private endpoint migration instance</summary>
        string MigrationInstanceResourceId { get; set; }
        /// <summary>There are two types of migration modes Online and Offline</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? MigrationMode { get; set; }
        /// <summary>This indicates the supported Migration option for the migration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationOption? MigrationOption { get; set; }
        /// <summary>End time in UTC for migration window</summary>
        global::System.DateTime? MigrationWindowEndTimeInUtc { get; set; }
        /// <summary>Start time in UTC for migration window</summary>
        global::System.DateTime? MigrationWindowStartTimeInUtc { get; set; }
        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get; set; }
        /// <summary>Migration resource properties.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationResourceProperties Property { get; set; }
        /// <summary>Migration secret parameters</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IMigrationSecretParameters SecretParameter { get; set; }
        /// <summary>Admin credentials for source and target servers</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IAdminCredentials SecretParameterAdminCredentials { get; set; }
        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        string SecretParameterSourceServerUsername { get; set; }
        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        string SecretParameterTargetServerUsername { get; set; }
        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get; set; }
        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        string SourceDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>Metadata of the source database server</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IDbServerMetadata SourceDbServerMetadata { get; set; }
        /// <summary>Location of database server</summary>
        string SourceDbServerMetadataLocation { get; set; }
        /// <summary>SKU for the database server. This object is empty for PG single server</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IServerSku SourceDbServerMetadataSku { get; set; }
        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        string SourceDbServerMetadataSkuName { get; set; }
        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? SourceDbServerMetadataSkuTier { get; set; }
        /// <summary>Storage size in MB for database server</summary>
        int? SourceDbServerMetadataStorageMb { get; set; }
        /// <summary>Version for database engine</summary>
        string SourceDbServerMetadataVersion { get; set; }
        /// <summary>
        /// ResourceId of the source database server in case the sourceType is PostgreSQLSingleServer. For other source types this
        /// should be ipaddress:port@username or hostname:port@username
        /// </summary>
        string SourceDbServerResourceId { get; set; }
        /// <summary>
        /// migration source server type : OnPremises, AWS, GCP, AzureVM, PostgreSQLSingleServer, AWS_RDS, AWS_AURORA, AWS_EC2, GCP_CloudSQL,
        /// GCP_AlloyDB, GCP_Compute, EDB, EDB_Oracle_Server, EDB_PostgreSQL, PostgreSQLFlexibleServer, PostgreSQLCosmosDB, Huawei_RDS,
        /// Huawei_Compute, Heroku_PostgreSQL, Crunchy_PostgreSQL, ApsaraDB_RDS, Digital_Ocean_Droplets, Digital_Ocean_PostgreSQL,
        /// or Supabase_PostgreSQL
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SourceType? SourceType { get; set; }
        /// <summary>
        /// SSL modes for migration. Default SSL mode for PostgreSQLSingleServer is VerifyFull and Prefer for other source types
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SslMode? SslMode { get; set; }
        /// <summary>Indicates whether the data migration should start right away</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? StartDataMigration { get; set; }
        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        string TargetDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>Metadata of the target database server</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IDbServerMetadata TargetDbServerMetadata { get; set; }
        /// <summary>Location of database server</summary>
        string TargetDbServerMetadataLocation { get; set; }
        /// <summary>SKU for the database server. This object is empty for PG single server</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IServerSku TargetDbServerMetadataSku { get; set; }
        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        string TargetDbServerMetadataSkuName { get; set; }
        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? TargetDbServerMetadataSkuTier { get; set; }
        /// <summary>Storage size in MB for database server</summary>
        int? TargetDbServerMetadataStorageMb { get; set; }
        /// <summary>Version for database engine</summary>
        string TargetDbServerMetadataVersion { get; set; }
        /// <summary>ResourceId of the source database server</summary>
        string TargetDbServerResourceId { get; set; }
        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? TriggerCutover { get; set; }
        /// <summary>Details of server level validations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IDbLevelValidationStatus[] ValidationDetailDbLevelValidationDetail { get; set; }
        /// <summary>Details of server level validations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20241101Preview.IValidationSummaryItem[] ValidationDetailServerLevelValidationDetail { get; set; }
        /// <summary>Validation status for migration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.ValidationState? ValidationDetailStatus { get; set; }
        /// <summary>Validation End date-time in UTC</summary>
        global::System.DateTime? ValidationDetailValidationEndTimeInUtc { get; set; }
        /// <summary>Validation Start date-time in UTC</summary>
        global::System.DateTime? ValidationDetailValidationStartTimeInUtc { get; set; }

    }
}
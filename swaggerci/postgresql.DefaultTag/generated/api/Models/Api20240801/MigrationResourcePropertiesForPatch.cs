// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801
{
    using static Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Extensions;

    /// <summary>Migration resource properties for patch.</summary>
    public partial class MigrationResourcePropertiesForPatch :
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesForPatch,
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesForPatchInternal
    {

        /// <summary>Password for source server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string AdminCredentialsSourceServerPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentialsSourceServerPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentialsSourceServerPassword = value ?? null; }

        /// <summary>Password for target server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string AdminCredentialsTargetServerPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentialsTargetServerPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentialsTargetServerPassword = value ?? null; }

        /// <summary>Backing field for <see cref="Cancel" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? _cancel;

        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? Cancel { get => this._cancel; set => this._cancel = value; }

        /// <summary>Backing field for <see cref="DbsToCancelMigrationOn" /> property.</summary>
        private string[] _dbsToCancelMigrationOn;

        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string[] DbsToCancelMigrationOn { get => this._dbsToCancelMigrationOn; set => this._dbsToCancelMigrationOn = value; }

        /// <summary>Backing field for <see cref="DbsToMigrate" /> property.</summary>
        private string[] _dbsToMigrate;

        /// <summary>Number of databases to migrate</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string[] DbsToMigrate { get => this._dbsToMigrate; set => this._dbsToMigrate = value; }

        /// <summary>Backing field for <see cref="DbsToTriggerCutoverOn" /> property.</summary>
        private string[] _dbsToTriggerCutoverOn;

        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string[] DbsToTriggerCutoverOn { get => this._dbsToTriggerCutoverOn; set => this._dbsToTriggerCutoverOn = value; }

        /// <summary>Internal Acessors for SecretParameter</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParameters Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesForPatchInternal.SecretParameter { get => (this._secretParameter = this._secretParameter ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.MigrationSecretParameters()); set { {_secretParameter = value;} } }

        /// <summary>Internal Acessors for SecretParameterAdminCredentials</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IAdminCredentials Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesForPatchInternal.SecretParameterAdminCredentials { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentials; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentials = value; }

        /// <summary>Backing field for <see cref="MigrateRole" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? _migrateRole;

        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? MigrateRole { get => this._migrateRole; set => this._migrateRole = value; }

        /// <summary>Backing field for <see cref="MigrationMode" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? _migrationMode;

        /// <summary>There are two types of migration modes Online and Offline</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? MigrationMode { get => this._migrationMode; set => this._migrationMode = value; }

        /// <summary>Backing field for <see cref="MigrationWindowStartTimeInUtc" /> property.</summary>
        private global::System.DateTime? _migrationWindowStartTimeInUtc;

        /// <summary>Start time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public global::System.DateTime? MigrationWindowStartTimeInUtc { get => this._migrationWindowStartTimeInUtc; set => this._migrationWindowStartTimeInUtc = value; }

        /// <summary>Backing field for <see cref="OverwriteDbsInTarget" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? _overwriteDbsInTarget;

        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get => this._overwriteDbsInTarget; set => this._overwriteDbsInTarget = value; }

        /// <summary>Backing field for <see cref="SecretParameter" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParameters _secretParameter;

        /// <summary>Migration secret parameters</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParameters SecretParameter { get => (this._secretParameter = this._secretParameter ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.MigrationSecretParameters()); set => this._secretParameter = value; }

        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SecretParameterSourceServerUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).SourceServerUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).SourceServerUsername = value ?? null; }

        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SecretParameterTargetServerUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).TargetServerUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).TargetServerUsername = value ?? null; }

        /// <summary>
        /// Backing field for <see cref="SetupLogicalReplicationOnSourceDbIfNeeded" /> property.
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? _setupLogicalReplicationOnSourceDbIfNeeded;

        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get => this._setupLogicalReplicationOnSourceDbIfNeeded; set => this._setupLogicalReplicationOnSourceDbIfNeeded = value; }

        /// <summary>
        /// Backing field for <see cref="SourceDbServerFullyQualifiedDomainName" /> property.
        /// </summary>
        private string _sourceDbServerFullyQualifiedDomainName;

        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string SourceDbServerFullyQualifiedDomainName { get => this._sourceDbServerFullyQualifiedDomainName; set => this._sourceDbServerFullyQualifiedDomainName = value; }

        /// <summary>Backing field for <see cref="SourceDbServerResourceId" /> property.</summary>
        private string _sourceDbServerResourceId;

        /// <summary>ResourceId of the source database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string SourceDbServerResourceId { get => this._sourceDbServerResourceId; set => this._sourceDbServerResourceId = value; }

        /// <summary>Backing field for <see cref="StartDataMigration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? _startDataMigration;

        /// <summary>Indicates whether the data migration should start right away</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? StartDataMigration { get => this._startDataMigration; set => this._startDataMigration = value; }

        /// <summary>
        /// Backing field for <see cref="TargetDbServerFullyQualifiedDomainName" /> property.
        /// </summary>
        private string _targetDbServerFullyQualifiedDomainName;

        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string TargetDbServerFullyQualifiedDomainName { get => this._targetDbServerFullyQualifiedDomainName; set => this._targetDbServerFullyQualifiedDomainName = value; }

        /// <summary>Backing field for <see cref="TriggerCutover" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? _triggerCutover;

        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? TriggerCutover { get => this._triggerCutover; set => this._triggerCutover = value; }

        /// <summary>Creates an new <see cref="MigrationResourcePropertiesForPatch" /> instance.</summary>
        public MigrationResourcePropertiesForPatch()
        {

        }
    }
    /// Migration resource properties for patch.
    public partial interface IMigrationResourcePropertiesForPatch :
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.IJsonSerializable
    {
        /// <summary>Password for source server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Password for source server.",
        SerializedName = @"sourceServerPassword",
        PossibleTypes = new [] { typeof(string) })]
        string AdminCredentialsSourceServerPassword { get; set; }
        /// <summary>Password for target server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Password for target server.",
        SerializedName = @"targetServerPassword",
        PossibleTypes = new [] { typeof(string) })]
        string AdminCredentialsTargetServerPassword { get; set; }
        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To trigger cancel for entire migration we need to send this flag as True",
        SerializedName = @"cancel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? Cancel { get; set; }
        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When you want to trigger cancel for specific databases send cancel flag as True and database names in this array",
        SerializedName = @"dbsToCancelMigrationOn",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToCancelMigrationOn { get; set; }
        /// <summary>Number of databases to migrate</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of databases to migrate",
        SerializedName = @"dbsToMigrate",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToMigrate { get; set; }
        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array",
        SerializedName = @"dbsToTriggerCutoverOn",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToTriggerCutoverOn { get; set; }
        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To migrate roles and permissions we need to send this flag as True",
        SerializedName = @"migrateRoles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? MigrateRole { get; set; }
        /// <summary>There are two types of migration modes Online and Offline</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"There are two types of migration modes Online and Offline",
        SerializedName = @"migrationMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? MigrationMode { get; set; }
        /// <summary>Start time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Start time in UTC for migration window",
        SerializedName = @"migrationWindowStartTimeInUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? MigrationWindowStartTimeInUtc { get; set; }
        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration workflow will wait for a confirmation, if it detects that the database already exists.",
        SerializedName = @"overwriteDbsInTarget",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get; set; }
        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets the username for the source server. This user need not be an admin.",
        SerializedName = @"sourceServerUsername",
        PossibleTypes = new [] { typeof(string) })]
        string SecretParameterSourceServerUsername { get; set; }
        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets the username for the target server. This user need not be an admin.",
        SerializedName = @"targetServerUsername",
        PossibleTypes = new [] { typeof(string) })]
        string SecretParameterTargetServerUsername { get; set; }
        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether to setup LogicalReplicationOnSourceDb, if needed",
        SerializedName = @"setupLogicalReplicationOnSourceDbIfNeeded",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get; set; }
        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration service will always use it for connection",
        SerializedName = @"sourceDbServerFullyQualifiedDomainName",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>ResourceId of the source database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ResourceId of the source database server",
        SerializedName = @"sourceDbServerResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerResourceId { get; set; }
        /// <summary>Indicates whether the data migration should start right away</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the data migration should start right away",
        SerializedName = @"startDataMigration",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? StartDataMigration { get; set; }
        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration service will always use it for connection",
        SerializedName = @"targetDbServerFullyQualifiedDomainName",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To trigger cutover for entire migration we need to send this flag as True",
        SerializedName = @"triggerCutover",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? TriggerCutover { get; set; }

    }
    /// Migration resource properties for patch.
    internal partial interface IMigrationResourcePropertiesForPatchInternal

    {
        /// <summary>Password for source server.</summary>
        string AdminCredentialsSourceServerPassword { get; set; }
        /// <summary>Password for target server.</summary>
        string AdminCredentialsTargetServerPassword { get; set; }
        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? Cancel { get; set; }
        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        string[] DbsToCancelMigrationOn { get; set; }
        /// <summary>Number of databases to migrate</summary>
        string[] DbsToMigrate { get; set; }
        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        string[] DbsToTriggerCutoverOn { get; set; }
        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? MigrateRole { get; set; }
        /// <summary>There are two types of migration modes Online and Offline</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? MigrationMode { get; set; }
        /// <summary>Start time in UTC for migration window</summary>
        global::System.DateTime? MigrationWindowStartTimeInUtc { get; set; }
        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get; set; }
        /// <summary>Migration secret parameters</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParameters SecretParameter { get; set; }
        /// <summary>Admin credentials for source and target servers</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IAdminCredentials SecretParameterAdminCredentials { get; set; }
        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        string SecretParameterSourceServerUsername { get; set; }
        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        string SecretParameterTargetServerUsername { get; set; }
        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get; set; }
        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        string SourceDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>ResourceId of the source database server</summary>
        string SourceDbServerResourceId { get; set; }
        /// <summary>Indicates whether the data migration should start right away</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? StartDataMigration { get; set; }
        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        string TargetDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? TriggerCutover { get; set; }

    }
}
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801
{
    using static Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Extensions;

    /// <summary>Migration resource properties.</summary>
    public partial class MigrationResourceProperties :
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourceProperties,
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal
    {

        /// <summary>Password for source server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string AdminCredentialsSourceServerPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentialsSourceServerPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentialsSourceServerPassword = value ?? null; }

        /// <summary>Password for target server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string AdminCredentialsTargetServerPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentialsTargetServerPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentialsTargetServerPassword = value ?? null; }

        /// <summary>Backing field for <see cref="Cancel" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? _cancel;

        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? Cancel { get => this._cancel; set => this._cancel = value; }

        /// <summary>Backing field for <see cref="CurrentStatus" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatus _currentStatus;

        /// <summary>Current status of migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatus CurrentStatus { get => (this._currentStatus = this._currentStatus ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.MigrationStatus()); }

        /// <summary>Error message, if any, for the migration state</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string CurrentStatusError { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).Error; }

        /// <summary>State of migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationState? CurrentStatusState { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).State; }

        /// <summary>Migration sub state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationSubState? CurrentSubStateDetailCurrentSubState { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).CurrentSubStateDetailCurrentSubState; }

        /// <summary>Dictionary of <DbMigrationStatus></summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSubStateDetailsDbDetails CurrentSubStateDetailDbDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).CurrentSubStateDetailDbDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).CurrentSubStateDetailDbDetail = value ?? null /* model class */; }

        /// <summary>Backing field for <see cref="DbsToCancelMigrationOn" /> property.</summary>
        private string[] _dbsToCancelMigrationOn;

        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string[] DbsToCancelMigrationOn { get => this._dbsToCancelMigrationOn; set => this._dbsToCancelMigrationOn = value; }

        /// <summary>Backing field for <see cref="DbsToMigrate" /> property.</summary>
        private string[] _dbsToMigrate;

        /// <summary>Number of databases to migrate</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string[] DbsToMigrate { get => this._dbsToMigrate; set => this._dbsToMigrate = value; }

        /// <summary>Backing field for <see cref="DbsToTriggerCutoverOn" /> property.</summary>
        private string[] _dbsToTriggerCutoverOn;

        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string[] DbsToTriggerCutoverOn { get => this._dbsToTriggerCutoverOn; set => this._dbsToTriggerCutoverOn = value; }

        /// <summary>Internal Acessors for CurrentStatus</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatus Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.CurrentStatus { get => (this._currentStatus = this._currentStatus ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.MigrationStatus()); set { {_currentStatus = value;} } }

        /// <summary>Internal Acessors for CurrentStatusCurrentSubStateDetail</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSubStateDetails Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.CurrentStatusCurrentSubStateDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).CurrentSubStateDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).CurrentSubStateDetail = value; }

        /// <summary>Internal Acessors for CurrentStatusError</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.CurrentStatusError { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).Error; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).Error = value; }

        /// <summary>Internal Acessors for CurrentStatusState</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationState? Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.CurrentStatusState { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).State; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).State = value; }

        /// <summary>Internal Acessors for CurrentSubStateDetailCurrentSubState</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationSubState? Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.CurrentSubStateDetailCurrentSubState { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).CurrentSubStateDetailCurrentSubState; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).CurrentSubStateDetailCurrentSubState = value; }

        /// <summary>Internal Acessors for CurrentSubStateDetailValidationDetail</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IValidationDetails Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.CurrentSubStateDetailValidationDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).CurrentSubStateDetailValidationDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).CurrentSubStateDetailValidationDetail = value; }

        /// <summary>Internal Acessors for MigrationId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.MigrationId { get => this._migrationId; set { {_migrationId = value;} } }

        /// <summary>Internal Acessors for SecretParameter</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParameters Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.SecretParameter { get => (this._secretParameter = this._secretParameter ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.MigrationSecretParameters()); set { {_secretParameter = value;} } }

        /// <summary>Internal Acessors for SecretParameterAdminCredentials</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IAdminCredentials Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.SecretParameterAdminCredentials { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentials; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).AdminCredentials = value; }

        /// <summary>Internal Acessors for SourceDbServerMetadata</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadata Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.SourceDbServerMetadata { get => (this._sourceDbServerMetadata = this._sourceDbServerMetadata ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.DbServerMetadata()); set { {_sourceDbServerMetadata = value;} } }

        /// <summary>Internal Acessors for SourceDbServerMetadataLocation</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.SourceDbServerMetadataLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).Location; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).Location = value; }

        /// <summary>Internal Acessors for SourceDbServerMetadataSku</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IServerSku Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.SourceDbServerMetadataSku { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).Sku; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).Sku = value; }

        /// <summary>Internal Acessors for TargetDbServerMetadata</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadata Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.TargetDbServerMetadata { get => (this._targetDbServerMetadata = this._targetDbServerMetadata ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.DbServerMetadata()); set { {_targetDbServerMetadata = value;} } }

        /// <summary>Internal Acessors for TargetDbServerMetadataLocation</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.TargetDbServerMetadataLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).Location; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).Location = value; }

        /// <summary>Internal Acessors for TargetDbServerMetadataSku</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IServerSku Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.TargetDbServerMetadataSku { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).Sku; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).Sku = value; }

        /// <summary>Internal Acessors for TargetDbServerResourceId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationResourcePropertiesInternal.TargetDbServerResourceId { get => this._targetDbServerResourceId; set { {_targetDbServerResourceId = value;} } }

        /// <summary>Backing field for <see cref="MigrateRole" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? _migrateRole;

        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? MigrateRole { get => this._migrateRole; set => this._migrateRole = value; }

        /// <summary>Backing field for <see cref="MigrationId" /> property.</summary>
        private string _migrationId;

        /// <summary>ID for migration, a GUID.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string MigrationId { get => this._migrationId; }

        /// <summary>Backing field for <see cref="MigrationInstanceResourceId" /> property.</summary>
        private string _migrationInstanceResourceId;

        /// <summary>ResourceId of the private endpoint migration instance</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string MigrationInstanceResourceId { get => this._migrationInstanceResourceId; set => this._migrationInstanceResourceId = value; }

        /// <summary>Backing field for <see cref="MigrationMode" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? _migrationMode;

        /// <summary>There are two types of migration modes Online and Offline</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? MigrationMode { get => this._migrationMode; set => this._migrationMode = value; }

        /// <summary>Backing field for <see cref="MigrationOption" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationOption? _migrationOption;

        /// <summary>This indicates the supported Migration option for the migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationOption? MigrationOption { get => this._migrationOption; set => this._migrationOption = value; }

        /// <summary>Backing field for <see cref="MigrationWindowEndTimeInUtc" /> property.</summary>
        private global::System.DateTime? _migrationWindowEndTimeInUtc;

        /// <summary>End time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public global::System.DateTime? MigrationWindowEndTimeInUtc { get => this._migrationWindowEndTimeInUtc; set => this._migrationWindowEndTimeInUtc = value; }

        /// <summary>Backing field for <see cref="MigrationWindowStartTimeInUtc" /> property.</summary>
        private global::System.DateTime? _migrationWindowStartTimeInUtc;

        /// <summary>Start time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public global::System.DateTime? MigrationWindowStartTimeInUtc { get => this._migrationWindowStartTimeInUtc; set => this._migrationWindowStartTimeInUtc = value; }

        /// <summary>Backing field for <see cref="OverwriteDbsInTarget" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? _overwriteDbsInTarget;

        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get => this._overwriteDbsInTarget; set => this._overwriteDbsInTarget = value; }

        /// <summary>Backing field for <see cref="SecretParameter" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParameters _secretParameter;

        /// <summary>Migration secret parameters</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParameters SecretParameter { get => (this._secretParameter = this._secretParameter ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.MigrationSecretParameters()); set => this._secretParameter = value; }

        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SecretParameterSourceServerUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).SourceServerUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).SourceServerUsername = value ?? null; }

        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SecretParameterTargetServerUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).TargetServerUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParametersInternal)SecretParameter).TargetServerUsername = value ?? null; }

        /// <summary>
        /// Backing field for <see cref="SetupLogicalReplicationOnSourceDbIfNeeded" /> property.
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? _setupLogicalReplicationOnSourceDbIfNeeded;

        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get => this._setupLogicalReplicationOnSourceDbIfNeeded; set => this._setupLogicalReplicationOnSourceDbIfNeeded = value; }

        /// <summary>
        /// Backing field for <see cref="SourceDbServerFullyQualifiedDomainName" /> property.
        /// </summary>
        private string _sourceDbServerFullyQualifiedDomainName;

        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string SourceDbServerFullyQualifiedDomainName { get => this._sourceDbServerFullyQualifiedDomainName; set => this._sourceDbServerFullyQualifiedDomainName = value; }

        /// <summary>Backing field for <see cref="SourceDbServerMetadata" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadata _sourceDbServerMetadata;

        /// <summary>Metadata of the source database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadata SourceDbServerMetadata { get => (this._sourceDbServerMetadata = this._sourceDbServerMetadata ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.DbServerMetadata()); }

        /// <summary>Location of database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SourceDbServerMetadataLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).Location; }

        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SourceDbServerMetadataSkuName { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).SkuName; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).SkuName = value ?? null; }

        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? SourceDbServerMetadataSkuTier { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).SkuTier; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).SkuTier = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier)""); }

        /// <summary>Storage size in MB for database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public int? SourceDbServerMetadataStorageMb { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).StorageMb; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).StorageMb = value ?? default(int); }

        /// <summary>Version for database engine</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string SourceDbServerMetadataVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).Version; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)SourceDbServerMetadata).Version = value ?? null; }

        /// <summary>Backing field for <see cref="SourceDbServerResourceId" /> property.</summary>
        private string _sourceDbServerResourceId;

        /// <summary>
        /// ResourceId of the source database server in case the sourceType is PostgreSQLSingleServer. For other source types this
        /// should be ipaddress:port@username or hostname:port@username
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string SourceDbServerResourceId { get => this._sourceDbServerResourceId; set => this._sourceDbServerResourceId = value; }

        /// <summary>Backing field for <see cref="SourceType" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SourceType? _sourceType;

        /// <summary>
        /// migration source server type : OnPremises, AWS, GCP, AzureVM, PostgreSQLSingleServer, AWS_RDS, AWS_AURORA, AWS_EC2, GCP_CloudSQL,
        /// GCP_AlloyDB, GCP_Compute, or EDB
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SourceType? SourceType { get => this._sourceType; set => this._sourceType = value; }

        /// <summary>Backing field for <see cref="SslMode" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SslMode? _sslMode;

        /// <summary>
        /// SSL modes for migration. Default SSL mode for PostgreSQLSingleServer is VerifyFull and Prefer for other source types
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SslMode? SslMode { get => this._sslMode; set => this._sslMode = value; }

        /// <summary>Backing field for <see cref="StartDataMigration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? _startDataMigration;

        /// <summary>Indicates whether the data migration should start right away</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? StartDataMigration { get => this._startDataMigration; set => this._startDataMigration = value; }

        /// <summary>
        /// Backing field for <see cref="TargetDbServerFullyQualifiedDomainName" /> property.
        /// </summary>
        private string _targetDbServerFullyQualifiedDomainName;

        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string TargetDbServerFullyQualifiedDomainName { get => this._targetDbServerFullyQualifiedDomainName; set => this._targetDbServerFullyQualifiedDomainName = value; }

        /// <summary>Backing field for <see cref="TargetDbServerMetadata" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadata _targetDbServerMetadata;

        /// <summary>Metadata of the target database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadata TargetDbServerMetadata { get => (this._targetDbServerMetadata = this._targetDbServerMetadata ?? new Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.DbServerMetadata()); }

        /// <summary>Location of database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string TargetDbServerMetadataLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).Location; }

        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string TargetDbServerMetadataSkuName { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).SkuName; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).SkuName = value ?? null; }

        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? TargetDbServerMetadataSkuTier { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).SkuTier; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).SkuTier = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier)""); }

        /// <summary>Storage size in MB for database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public int? TargetDbServerMetadataStorageMb { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).StorageMb; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).StorageMb = value ?? default(int); }

        /// <summary>Version for database engine</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public string TargetDbServerMetadataVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).Version; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadataInternal)TargetDbServerMetadata).Version = value ?? null; }

        /// <summary>Backing field for <see cref="TargetDbServerResourceId" /> property.</summary>
        private string _targetDbServerResourceId;

        /// <summary>ResourceId of the source database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public string TargetDbServerResourceId { get => this._targetDbServerResourceId; }

        /// <summary>Backing field for <see cref="TriggerCutover" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? _triggerCutover;

        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? TriggerCutover { get => this._triggerCutover; set => this._triggerCutover = value; }

        /// <summary>Details of server level validations</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbLevelValidationStatus[] ValidationDetailDbLevelValidationDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).ValidationDetailDbLevelValidationDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).ValidationDetailDbLevelValidationDetail = value ?? null /* arrayOf */; }

        /// <summary>Details of server level validations</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IValidationSummaryItem[] ValidationDetailServerLevelValidationDetail { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).ValidationDetailServerLevelValidationDetail; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).ValidationDetailServerLevelValidationDetail = value ?? null /* arrayOf */; }

        /// <summary>Validation status for migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.ValidationState? ValidationDetailStatus { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).ValidationDetailStatus; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).ValidationDetailStatus = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.ValidationState)""); }

        /// <summary>Validation End date-time in UTC</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public global::System.DateTime? ValidationDetailValidationEndTimeInUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).ValidationDetailValidationEndTimeInUtc; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).ValidationDetailValidationEndTimeInUtc = value ?? default(global::System.DateTime); }

        /// <summary>Validation Start date-time in UTC</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Origin(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.PropertyOrigin.Inlined)]
        public global::System.DateTime? ValidationDetailValidationStartTimeInUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).ValidationDetailValidationStartTimeInUtc; set => ((Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatusInternal)CurrentStatus).ValidationDetailValidationStartTimeInUtc = value ?? default(global::System.DateTime); }

        /// <summary>Creates an new <see cref="MigrationResourceProperties" /> instance.</summary>
        public MigrationResourceProperties()
        {

        }
    }
    /// Migration resource properties.
    public partial interface IMigrationResourceProperties :
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.IJsonSerializable
    {
        /// <summary>Password for source server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Password for source server.",
        SerializedName = @"sourceServerPassword",
        PossibleTypes = new [] { typeof(string) })]
        string AdminCredentialsSourceServerPassword { get; set; }
        /// <summary>Password for target server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Password for target server.",
        SerializedName = @"targetServerPassword",
        PossibleTypes = new [] { typeof(string) })]
        string AdminCredentialsTargetServerPassword { get; set; }
        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To trigger cancel for entire migration we need to send this flag as True",
        SerializedName = @"cancel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? Cancel { get; set; }
        /// <summary>Error message, if any, for the migration state</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Error message, if any, for the migration state",
        SerializedName = @"error",
        PossibleTypes = new [] { typeof(string) })]
        string CurrentStatusError { get;  }
        /// <summary>State of migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"State of migration",
        SerializedName = @"state",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationState) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationState? CurrentStatusState { get;  }
        /// <summary>Migration sub state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Migration sub state.",
        SerializedName = @"currentSubState",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationSubState) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationSubState? CurrentSubStateDetailCurrentSubState { get;  }
        /// <summary>Dictionary of <DbMigrationStatus></summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Dictionary of <DbMigrationStatus>",
        SerializedName = @"dbDetails",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSubStateDetailsDbDetails) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSubStateDetailsDbDetails CurrentSubStateDetailDbDetail { get; set; }
        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When you want to trigger cancel for specific databases send cancel flag as True and database names in this array",
        SerializedName = @"dbsToCancelMigrationOn",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToCancelMigrationOn { get; set; }
        /// <summary>Number of databases to migrate</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of databases to migrate",
        SerializedName = @"dbsToMigrate",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToMigrate { get; set; }
        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array",
        SerializedName = @"dbsToTriggerCutoverOn",
        PossibleTypes = new [] { typeof(string) })]
        string[] DbsToTriggerCutoverOn { get; set; }
        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To migrate roles and permissions we need to send this flag as True",
        SerializedName = @"migrateRoles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? MigrateRole { get; set; }
        /// <summary>ID for migration, a GUID.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"ID for migration, a GUID.",
        SerializedName = @"migrationId",
        PossibleTypes = new [] { typeof(string) })]
        string MigrationId { get;  }
        /// <summary>ResourceId of the private endpoint migration instance</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ResourceId of the private endpoint migration instance",
        SerializedName = @"migrationInstanceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string MigrationInstanceResourceId { get; set; }
        /// <summary>There are two types of migration modes Online and Offline</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"There are two types of migration modes Online and Offline",
        SerializedName = @"migrationMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? MigrationMode { get; set; }
        /// <summary>This indicates the supported Migration option for the migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This indicates the supported Migration option for the migration",
        SerializedName = @"migrationOption",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationOption) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationOption? MigrationOption { get; set; }
        /// <summary>End time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"End time in UTC for migration window",
        SerializedName = @"migrationWindowEndTimeInUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? MigrationWindowEndTimeInUtc { get; set; }
        /// <summary>Start time in UTC for migration window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Start time in UTC for migration window",
        SerializedName = @"migrationWindowStartTimeInUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? MigrationWindowStartTimeInUtc { get; set; }
        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration workflow will wait for a confirmation, if it detects that the database already exists.",
        SerializedName = @"overwriteDbsInTarget",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get; set; }
        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets the username for the source server. This user need not be an admin.",
        SerializedName = @"sourceServerUsername",
        PossibleTypes = new [] { typeof(string) })]
        string SecretParameterSourceServerUsername { get; set; }
        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets the username for the target server. This user need not be an admin.",
        SerializedName = @"targetServerUsername",
        PossibleTypes = new [] { typeof(string) })]
        string SecretParameterTargetServerUsername { get; set; }
        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether to setup LogicalReplicationOnSourceDb, if needed",
        SerializedName = @"setupLogicalReplicationOnSourceDbIfNeeded",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get; set; }
        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration service will always use it for connection",
        SerializedName = @"sourceDbServerFullyQualifiedDomainName",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>Location of database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Location of database server",
        SerializedName = @"location",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerMetadataLocation { get;  }
        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerMetadataSkuName { get; set; }
        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The tier of the particular SKU, e.g. Burstable.",
        SerializedName = @"tier",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? SourceDbServerMetadataSkuTier { get; set; }
        /// <summary>Storage size in MB for database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Storage size in MB for database server",
        SerializedName = @"storageMb",
        PossibleTypes = new [] { typeof(int) })]
        int? SourceDbServerMetadataStorageMb { get; set; }
        /// <summary>Version for database engine</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Version for database engine",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerMetadataVersion { get; set; }
        /// <summary>
        /// ResourceId of the source database server in case the sourceType is PostgreSQLSingleServer. For other source types this
        /// should be ipaddress:port@username or hostname:port@username
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ResourceId of the source database server in case the sourceType is PostgreSQLSingleServer. For other source types this should be ipaddress:port@username or hostname:port@username",
        SerializedName = @"sourceDbServerResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string SourceDbServerResourceId { get; set; }
        /// <summary>
        /// migration source server type : OnPremises, AWS, GCP, AzureVM, PostgreSQLSingleServer, AWS_RDS, AWS_AURORA, AWS_EC2, GCP_CloudSQL,
        /// GCP_AlloyDB, GCP_Compute, or EDB
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"migration source server type : OnPremises, AWS, GCP, AzureVM, PostgreSQLSingleServer, AWS_RDS, AWS_AURORA, AWS_EC2, GCP_CloudSQL, GCP_AlloyDB, GCP_Compute, or EDB",
        SerializedName = @"sourceType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SourceType) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SourceType? SourceType { get; set; }
        /// <summary>
        /// SSL modes for migration. Default SSL mode for PostgreSQLSingleServer is VerifyFull and Prefer for other source types
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SSL modes for migration. Default SSL mode for PostgreSQLSingleServer is VerifyFull and Prefer for other source types",
        SerializedName = @"sslMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SslMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SslMode? SslMode { get; set; }
        /// <summary>Indicates whether the data migration should start right away</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the data migration should start right away",
        SerializedName = @"startDataMigration",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? StartDataMigration { get; set; }
        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration service will always use it for connection",
        SerializedName = @"targetDbServerFullyQualifiedDomainName",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>Location of database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Location of database server",
        SerializedName = @"location",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerMetadataLocation { get;  }
        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerMetadataSkuName { get; set; }
        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The tier of the particular SKU, e.g. Burstable.",
        SerializedName = @"tier",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? TargetDbServerMetadataSkuTier { get; set; }
        /// <summary>Storage size in MB for database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Storage size in MB for database server",
        SerializedName = @"storageMb",
        PossibleTypes = new [] { typeof(int) })]
        int? TargetDbServerMetadataStorageMb { get; set; }
        /// <summary>Version for database engine</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Version for database engine",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerMetadataVersion { get; set; }
        /// <summary>ResourceId of the source database server</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"ResourceId of the source database server",
        SerializedName = @"targetDbServerResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string TargetDbServerResourceId { get;  }
        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To trigger cutover for entire migration we need to send this flag as True",
        SerializedName = @"triggerCutover",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? TriggerCutover { get; set; }
        /// <summary>Details of server level validations</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Details of server level validations",
        SerializedName = @"dbLevelValidationDetails",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbLevelValidationStatus) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbLevelValidationStatus[] ValidationDetailDbLevelValidationDetail { get; set; }
        /// <summary>Details of server level validations</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Details of server level validations",
        SerializedName = @"serverLevelValidationDetails",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IValidationSummaryItem) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IValidationSummaryItem[] ValidationDetailServerLevelValidationDetail { get; set; }
        /// <summary>Validation status for migration</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Validation status for migration",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.ValidationState) })]
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.ValidationState? ValidationDetailStatus { get; set; }
        /// <summary>Validation End date-time in UTC</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Validation End date-time in UTC",
        SerializedName = @"validationEndTimeInUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ValidationDetailValidationEndTimeInUtc { get; set; }
        /// <summary>Validation Start date-time in UTC</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Validation Start date-time in UTC",
        SerializedName = @"validationStartTimeInUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ValidationDetailValidationStartTimeInUtc { get; set; }

    }
    /// Migration resource properties.
    internal partial interface IMigrationResourcePropertiesInternal

    {
        /// <summary>Password for source server.</summary>
        string AdminCredentialsSourceServerPassword { get; set; }
        /// <summary>Password for target server.</summary>
        string AdminCredentialsTargetServerPassword { get; set; }
        /// <summary>To trigger cancel for entire migration we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.CancelEnum? Cancel { get; set; }
        /// <summary>Current status of migration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationStatus CurrentStatus { get; set; }
        /// <summary>Current Migration sub state details.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSubStateDetails CurrentStatusCurrentSubStateDetail { get; set; }
        /// <summary>Error message, if any, for the migration state</summary>
        string CurrentStatusError { get; set; }
        /// <summary>State of migration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationState? CurrentStatusState { get; set; }
        /// <summary>Migration sub state.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationSubState? CurrentSubStateDetailCurrentSubState { get; set; }
        /// <summary>Dictionary of <DbMigrationStatus></summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSubStateDetailsDbDetails CurrentSubStateDetailDbDetail { get; set; }
        /// <summary>Details for the validation for migration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IValidationDetails CurrentSubStateDetailValidationDetail { get; set; }
        /// <summary>
        /// When you want to trigger cancel for specific databases send cancel flag as True and database names in this array
        /// </summary>
        string[] DbsToCancelMigrationOn { get; set; }
        /// <summary>Number of databases to migrate</summary>
        string[] DbsToMigrate { get; set; }
        /// <summary>
        /// When you want to trigger cutover for specific databases send triggerCutover flag as True and database names in this array
        /// </summary>
        string[] DbsToTriggerCutoverOn { get; set; }
        /// <summary>To migrate roles and permissions we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrateRolesEnum? MigrateRole { get; set; }
        /// <summary>ID for migration, a GUID.</summary>
        string MigrationId { get; set; }
        /// <summary>ResourceId of the private endpoint migration instance</summary>
        string MigrationInstanceResourceId { get; set; }
        /// <summary>There are two types of migration modes Online and Offline</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationMode? MigrationMode { get; set; }
        /// <summary>This indicates the supported Migration option for the migration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.MigrationOption? MigrationOption { get; set; }
        /// <summary>End time in UTC for migration window</summary>
        global::System.DateTime? MigrationWindowEndTimeInUtc { get; set; }
        /// <summary>Start time in UTC for migration window</summary>
        global::System.DateTime? MigrationWindowStartTimeInUtc { get; set; }
        /// <summary>
        /// Indicates whether the databases on the target server can be overwritten, if already present. If set to False, the migration
        /// workflow will wait for a confirmation, if it detects that the database already exists.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.OverwriteDbsInTargetEnum? OverwriteDbsInTarget { get; set; }
        /// <summary>Migration secret parameters</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IMigrationSecretParameters SecretParameter { get; set; }
        /// <summary>Admin credentials for source and target servers</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IAdminCredentials SecretParameterAdminCredentials { get; set; }
        /// <summary>
        /// Gets or sets the username for the source server. This user need not be an admin.
        /// </summary>
        string SecretParameterSourceServerUsername { get; set; }
        /// <summary>
        /// Gets or sets the username for the target server. This user need not be an admin.
        /// </summary>
        string SecretParameterTargetServerUsername { get; set; }
        /// <summary>Indicates whether to setup LogicalReplicationOnSourceDb, if needed</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.LogicalReplicationOnSourceDbEnum? SetupLogicalReplicationOnSourceDbIfNeeded { get; set; }
        /// <summary>
        /// Source server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        string SourceDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>Metadata of the source database server</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadata SourceDbServerMetadata { get; set; }
        /// <summary>Location of database server</summary>
        string SourceDbServerMetadataLocation { get; set; }
        /// <summary>SKU for the database server. This object is empty for PG single server</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IServerSku SourceDbServerMetadataSku { get; set; }
        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        string SourceDbServerMetadataSkuName { get; set; }
        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? SourceDbServerMetadataSkuTier { get; set; }
        /// <summary>Storage size in MB for database server</summary>
        int? SourceDbServerMetadataStorageMb { get; set; }
        /// <summary>Version for database engine</summary>
        string SourceDbServerMetadataVersion { get; set; }
        /// <summary>
        /// ResourceId of the source database server in case the sourceType is PostgreSQLSingleServer. For other source types this
        /// should be ipaddress:port@username or hostname:port@username
        /// </summary>
        string SourceDbServerResourceId { get; set; }
        /// <summary>
        /// migration source server type : OnPremises, AWS, GCP, AzureVM, PostgreSQLSingleServer, AWS_RDS, AWS_AURORA, AWS_EC2, GCP_CloudSQL,
        /// GCP_AlloyDB, GCP_Compute, or EDB
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SourceType? SourceType { get; set; }
        /// <summary>
        /// SSL modes for migration. Default SSL mode for PostgreSQLSingleServer is VerifyFull and Prefer for other source types
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SslMode? SslMode { get; set; }
        /// <summary>Indicates whether the data migration should start right away</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.StartDataMigrationEnum? StartDataMigration { get; set; }
        /// <summary>
        /// Target server fully qualified domain name (FQDN) or IP address. It is a optional value, if customer provide it, migration
        /// service will always use it for connection
        /// </summary>
        string TargetDbServerFullyQualifiedDomainName { get; set; }
        /// <summary>Metadata of the target database server</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbServerMetadata TargetDbServerMetadata { get; set; }
        /// <summary>Location of database server</summary>
        string TargetDbServerMetadataLocation { get; set; }
        /// <summary>SKU for the database server. This object is empty for PG single server</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IServerSku TargetDbServerMetadataSku { get; set; }
        /// <summary>The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.</summary>
        string TargetDbServerMetadataSkuName { get; set; }
        /// <summary>The tier of the particular SKU, e.g. Burstable.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.SkuTier? TargetDbServerMetadataSkuTier { get; set; }
        /// <summary>Storage size in MB for database server</summary>
        int? TargetDbServerMetadataStorageMb { get; set; }
        /// <summary>Version for database engine</summary>
        string TargetDbServerMetadataVersion { get; set; }
        /// <summary>ResourceId of the source database server</summary>
        string TargetDbServerResourceId { get; set; }
        /// <summary>To trigger cutover for entire migration we need to send this flag as True</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.TriggerCutoverEnum? TriggerCutover { get; set; }
        /// <summary>Details of server level validations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IDbLevelValidationStatus[] ValidationDetailDbLevelValidationDetail { get; set; }
        /// <summary>Details of server level validations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Models.Api20240801.IValidationSummaryItem[] ValidationDetailServerLevelValidationDetail { get; set; }
        /// <summary>Validation status for migration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.PostgreSqlServer.Support.ValidationState? ValidationDetailStatus { get; set; }
        /// <summary>Validation End date-time in UTC</summary>
        global::System.DateTime? ValidationDetailValidationEndTimeInUtc { get; set; }
        /// <summary>Validation Start date-time in UTC</summary>
        global::System.DateTime? ValidationDetailValidationStartTimeInUtc { get; set; }

    }
}

# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Updates an existing server.
The request body can contain one to many of the properties present in the normal server definition.
.Description
Updates an existing server.
The request body can contain one to many of the properties present in the normal server definition.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.IPostgreSqlIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20240801.IServer
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IPostgreSqlIdentity>: Identity Parameter
  [BackupName <String>]: The name of the backup.
  [ConfigurationName <String>]: The name of the server configuration.
  [DatabaseName <String>]: The name of the database.
  [FirewallRuleName <String>]: The name of the server firewall rule.
  [GroupName <String>]: The name of the private link resource.
  [Id <String>]: Resource identity path
  [LocationName <String>]: The name of the location.
  [MigrationName <String>]: The name of the migration.
  [ObjectId <String>]: Guid of the objectId for the administrator.
  [PrivateEndpointConnectionName <String>]: The name of the private endpoint connection.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [ServerName <String>]: The name of the server.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [TargetDbServerName <String>]: The name of the target database server.
  [ThreatProtectionName <ThreatProtectionName?>]: The name of the Threat Protection state.
  [VirtualEndpointName <String>]: The name of the virtual endpoint.
.Link
https://learn.microsoft.com/powershell/module/az.postgresql/update-azpostgresqlserver
#>
function Update-AzPostgreSqlServer {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20240801.IServer])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Alias('ServerName')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Path')]
    [System.String]
    # The name of the server.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.IPostgreSqlIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # The administrator's login name of a server.
    # Can only be specified when the server is trying to switch to password authentication and does not have default administrator login.
    ${AdministratorLogin},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.Security.SecureString]
    # The password of the administrator login.
    ${AdministratorLoginPassword},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ActiveDirectoryAuthEnum])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ActiveDirectoryAuthEnum]
    # If Enabled, Azure Active Directory authentication is enabled.
    ${AuthConfigActiveDirectoryAuth},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.PasswordAuthEnum])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.PasswordAuthEnum]
    # If Enabled, Password authentication is enabled.
    ${AuthConfigPasswordAuth},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # Tenant id of the server.
    ${AuthConfigTenantId},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.GeoRedundantBackupEnum])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.GeoRedundantBackupEnum]
    # A value indicating whether Geo-Redundant backup is enabled on the server.
    ${BackupGeoRedundantBackup},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.Int32]
    # Backup retention days for the server.
    ${BackupRetentionDay},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.CreateModeForUpdate])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.CreateModeForUpdate]
    # The mode to update a new PostgreSQL server.
    ${CreateMode},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.KeyStatusEnum])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.KeyStatusEnum]
    # Geo-backup encryption key status for Data encryption enabled server.
    ${DataEncryptionGeoBackupEncryptionKeyStatus},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # URI for the key in keyvault for data encryption for geo-backup of server.
    ${DataEncryptionGeoBackupKeyUri},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # Resource Id for the User assigned identity to be used for data encryption for geo-backup of server.
    ${DataEncryptionGeoBackupUserAssignedIdentityId},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.KeyStatusEnum])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.KeyStatusEnum]
    # Primary encryption key status for Data encryption enabled server.
    ${DataEncryptionPrimaryEncryptionKeyStatus},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # URI for the key in keyvault for data encryption of the primary server.
    ${DataEncryptionPrimaryKeyUri},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # Resource Id for the User assigned identity to be used for data encryption of the primary server.
    ${DataEncryptionPrimaryUserAssignedIdentityId},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ArmServerKeyType])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ArmServerKeyType]
    # Data encryption type to depict if it is System Managed vs Azure Key vault.
    ${DataEncryptionType},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.HighAvailabilityMode])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.HighAvailabilityMode]
    # The HA mode for the server.
    ${HighAvailabilityMode},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # availability zone information of the standby.
    ${HighAvailabilityStandbyAvailabilityZone},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.IdentityType])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.IdentityType]
    # the types of identities associated with this resource; currently restricted to 'None and UserAssigned'
    ${IdentityType},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20240801.IUserAssignedIdentityMap]))]
    [System.Collections.Hashtable]
    # represents user assigned identities map.
    ${IdentityUserAssignedIdentity},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # indicates whether custom window is enabled or disabled
    ${MaintenanceWindowCustomWindow},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.Int32]
    # day of week for maintenance window
    ${MaintenanceWindowDayOfWeek},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.Int32]
    # start hour for maintenance window
    ${MaintenanceWindowStartHour},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.Int32]
    # start minute for maintenance window
    ${MaintenanceWindowStartMinute},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # Delegated subnet arm resource id.
    # This is required to be passed during create, in case we want the server to be VNET injected, i.e.
    # Private access server.
    # During update, pass this only if we want to update the value for Private DNS zone.
    ${NetworkDelegatedSubnetResourceId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # Private dns zone arm resource id.
    # This is required to be passed during create, in case we want the server to be VNET injected, i.e.
    # Private access server.
    # During update, pass this only if we want to update the value for Private DNS zone.
    ${NetworkPrivateDnsZoneArmResourceId},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ServerPublicNetworkAccessState])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ServerPublicNetworkAccessState]
    # public network access is enabled or not
    ${NetworkPublicNetworkAccess},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ReadReplicaPromoteMode])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ReadReplicaPromoteMode]
    # Sets the promote mode for a replica server.
    # This is a write only property.
    ${ReplicaPromoteMode},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ReplicationPromoteOption])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ReplicationPromoteOption]
    # Sets the promote options for a replica server.
    # This is a write only property.
    ${ReplicaPromoteOption},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ReplicationRole])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ReplicationRole]
    # Used to indicate role of the server in replication set.
    ${ReplicaRole},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ReplicationRole])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ReplicationRole]
    # Replication role of the server
    ${ReplicationRole},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.String]
    # The name of the sku, typically, tier + family + cores, e.g.
    # Standard_D4s_v3.
    ${SkuName},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.SkuTier])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.SkuTier]
    # The tier of the particular SKU, e.g.
    # Burstable.
    ${SkuTier},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.StorageAutoGrow])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.StorageAutoGrow]
    # Flag to enable / disable Storage Auto grow for flexible server.
    ${StorageAutoGrow},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.Int32]
    # Storage tier IOPS quantity.
    # This property is required to be set for storage Type PremiumV2_LRS
    ${StorageIop},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.Int32]
    # Max storage allowed for a server.
    ${StorageSizeGb},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [System.Int32]
    # Storage throughput for the server.
    # This is required to be set for storage Type PremiumV2_LRS
    ${StorageThroughput},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.AzureManagedDiskPerformanceTiers])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.AzureManagedDiskPerformanceTiers]
    # Name of storage tier for IOPS.
    ${StorageTier},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.StorageType])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.StorageType]
    # Storage type for the server.
    # Allowed values are Premium_LRS and PremiumV2_LRS, and default is Premium_LRS if not specified
    ${StorageType},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Models.Api20240801.IServerForUpdateTags]))]
    [System.Collections.Hashtable]
    # Application-specific metadata in the form of key-value pairs.
    ${Tag},

    [Parameter()]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ServerVersion])]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Support.ServerVersion]
    # PostgreSQL Server version.
    # Version 16 is currently not supported for MVU.
    ${Version},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.PostgreSql.private\Update-AzPostgreSqlServer_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.PostgreSql.private\Update-AzPostgreSqlServer_UpdateViaIdentityExpanded';
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId')) {
            $testPlayback = $false
            $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.PostgreSql.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

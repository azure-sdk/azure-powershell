// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Extensions;

    /// <summary>Details of the Compute Fleet.</summary>
    public partial class FleetPropertiesUpdate :
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IFleetPropertiesUpdate,
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IFleetPropertiesUpdateInternal
    {

        /// <summary>Backing field for <see cref="ComputeProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IComputeProfileUpdate _computeProfile;

        /// <summary>Compute Profile to use for running user's workloads.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IComputeProfileUpdate ComputeProfile { get => (this._computeProfile = this._computeProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ComputeProfileUpdate()); set => this._computeProfile = value; }

        /// <summary>
        /// Base Virtual Machine Profile Properties to be specified according to "specification/compute/resource-manager/Microsoft.Compute/ComputeRP/stable/{computeApiVersion}/virtualMachineScaleSet.json#/definitions/VirtualMachineScaleSetVMProfile"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20230901.IVirtualMachineScaleSetVMProfile ComputeProfileBaseVirtualMachineProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IComputeProfileUpdateInternal)ComputeProfile).BaseVirtualMachineProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IComputeProfileUpdateInternal)ComputeProfile).BaseVirtualMachineProfile = value ?? null /* model class */; }

        /// <summary>
        /// Specifies the Microsoft.Compute API version to use when creating underlying Virtual Machine scale sets and Virtual Machines.
        /// The default value will be the latest supported computeApiVersion by Compute Fleet.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public string ComputeProfileComputeApiVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IComputeProfileUpdateInternal)ComputeProfile).ComputeApiVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IComputeProfileUpdateInternal)ComputeProfile).ComputeApiVersion = value ?? null; }

        /// <summary>
        /// Specifies the number of fault domains to use when creating the underlying VMSS.
        /// A fault domain is a logical group of hardware within an Azure datacenter.
        /// VMs in the same fault domain share a common power source and network switch.
        /// If not specified, defaults to 1, which represents "Max Spreading" (using as many fault domains as possible).
        /// This property cannot be updated.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public int? ComputeProfilePlatformFaultDomainCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IComputeProfileUpdateInternal)ComputeProfile).PlatformFaultDomainCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IComputeProfileUpdateInternal)ComputeProfile).PlatformFaultDomainCount = value ?? default(int); }

        /// <summary>Internal Acessors for ComputeProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IComputeProfileUpdate Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IFleetPropertiesUpdateInternal.ComputeProfile { get => (this._computeProfile = this._computeProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ComputeProfileUpdate()); set { {_computeProfile = value;} } }

        /// <summary>Internal Acessors for RegularPriorityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IRegularPriorityProfile Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IFleetPropertiesUpdateInternal.RegularPriorityProfile { get => (this._regularPriorityProfile = this._regularPriorityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.RegularPriorityProfile()); set { {_regularPriorityProfile = value;} } }

        /// <summary>Internal Acessors for SpotPriorityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfile Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IFleetPropertiesUpdateInternal.SpotPriorityProfile { get => (this._spotPriorityProfile = this._spotPriorityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.SpotPriorityProfile()); set { {_spotPriorityProfile = value;} } }

        /// <summary>Backing field for <see cref="RegularPriorityProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IRegularPriorityProfile _regularPriorityProfile;

        /// <summary>Configuration Options for Regular instances in Compute Fleet.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IRegularPriorityProfile RegularPriorityProfile { get => (this._regularPriorityProfile = this._regularPriorityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.RegularPriorityProfile()); set => this._regularPriorityProfile = value; }

        /// <summary>
        /// Allocation strategy to follow when determining the VM sizes distribution for Regular VMs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.RegularPriorityAllocationStrategy? RegularPriorityProfileAllocationStrategy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IRegularPriorityProfileInternal)RegularPriorityProfile).AllocationStrategy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IRegularPriorityProfileInternal)RegularPriorityProfile).AllocationStrategy = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.RegularPriorityAllocationStrategy)""); }

        /// <summary>Total capacity to achieve. It is currently in terms of number of VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public int? RegularPriorityProfileCapacity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IRegularPriorityProfileInternal)RegularPriorityProfile).Capacity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IRegularPriorityProfileInternal)RegularPriorityProfile).Capacity = value ?? default(int); }

        /// <summary>
        /// Minimum capacity to achieve which cannot be updated. If we will not be able to "guarantee" minimum capacity, we will reject
        /// the request in the sync path itself.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public int? RegularPriorityProfileMinCapacity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IRegularPriorityProfileInternal)RegularPriorityProfile).MinCapacity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IRegularPriorityProfileInternal)RegularPriorityProfile).MinCapacity = value ?? default(int); }

        /// <summary>Backing field for <see cref="SpotPriorityProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfile _spotPriorityProfile;

        /// <summary>Configuration Options for Spot instances in Compute Fleet.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfile SpotPriorityProfile { get => (this._spotPriorityProfile = this._spotPriorityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.SpotPriorityProfile()); set => this._spotPriorityProfile = value; }

        /// <summary>
        /// Allocation strategy to follow when determining the VM sizes distribution for Spot VMs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.SpotAllocationStrategy? SpotPriorityProfileAllocationStrategy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).AllocationStrategy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).AllocationStrategy = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.SpotAllocationStrategy)""); }

        /// <summary>Total capacity to achieve. It is currently in terms of number of VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public int? SpotPriorityProfileCapacity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).Capacity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).Capacity = value ?? default(int); }

        /// <summary>Eviction Policy to follow when evicting Spot VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.EvictionPolicy? SpotPriorityProfileEvictionPolicy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).EvictionPolicy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).EvictionPolicy = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.EvictionPolicy)""); }

        /// <summary>
        /// Flag to enable/disable continuous goal seeking for the desired capacity and restoration of evicted Spot VMs.
        /// If maintain is enabled, AzureFleetRP will use all VM sizes in vmSizesProfile to create new VMs (if VMs are evicted deleted)
        /// or update existing VMs with new VM sizes (if VMs are evicted deallocated or failed to allocate due to capacity constraint)
        /// in order to achieve the desired capacity.
        /// Maintain is enabled by default.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public bool? SpotPriorityProfileMaintain { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).Maintain; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).Maintain = value ?? default(bool); }

        /// <summary>Price per hour of each Spot VM will never exceed this.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public float? SpotPriorityProfileMaxPricePerVM { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).MaxPricePerVM; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).MaxPricePerVM = value ?? default(float); }

        /// <summary>
        /// Minimum capacity to achieve which cannot be updated. If we will not be able to "guarantee" minimum capacity, we will reject
        /// the request in the sync path itself.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Inlined)]
        public int? SpotPriorityProfileMinCapacity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).MinCapacity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfileInternal)SpotPriorityProfile).MinCapacity = value ?? default(int); }

        /// <summary>Backing field for <see cref="VMSizesProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IVMSizeProfile[] _vMSizesProfile;

        /// <summary>List of VM sizes supported for Compute Fleet</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.Fleet.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IVMSizeProfile[] VMSizesProfile { get => this._vMSizesProfile; set => this._vMSizesProfile = value; }

        /// <summary>Creates an new <see cref="FleetPropertiesUpdate" /> instance.</summary>
        public FleetPropertiesUpdate()
        {

        }
    }
    /// Details of the Compute Fleet.
    public partial interface IFleetPropertiesUpdate :
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.IJsonSerializable
    {
        /// <summary>
        /// Base Virtual Machine Profile Properties to be specified according to "specification/compute/resource-manager/Microsoft.Compute/ComputeRP/stable/{computeApiVersion}/virtualMachineScaleSet.json#/definitions/VirtualMachineScaleSetVMProfile"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Base Virtual Machine Profile Properties to be specified according to ""specification/compute/resource-manager/Microsoft.Compute/ComputeRP/stable/{computeApiVersion}/virtualMachineScaleSet.json#/definitions/VirtualMachineScaleSetVMProfile""",
        SerializedName = @"baseVirtualMachineProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20230901.IVirtualMachineScaleSetVMProfile) })]
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20230901.IVirtualMachineScaleSetVMProfile ComputeProfileBaseVirtualMachineProfile { get; set; }
        /// <summary>
        /// Specifies the Microsoft.Compute API version to use when creating underlying Virtual Machine scale sets and Virtual Machines.
        /// The default value will be the latest supported computeApiVersion by Compute Fleet.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the Microsoft.Compute API version to use when creating underlying Virtual Machine scale sets and Virtual Machines.
        The default value will be the latest supported computeApiVersion by Compute Fleet.",
        SerializedName = @"computeApiVersion",
        PossibleTypes = new [] { typeof(string) })]
        string ComputeProfileComputeApiVersion { get; set; }
        /// <summary>
        /// Specifies the number of fault domains to use when creating the underlying VMSS.
        /// A fault domain is a logical group of hardware within an Azure datacenter.
        /// VMs in the same fault domain share a common power source and network switch.
        /// If not specified, defaults to 1, which represents "Max Spreading" (using as many fault domains as possible).
        /// This property cannot be updated.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the number of fault domains to use when creating the underlying VMSS.
        A fault domain is a logical group of hardware within an Azure datacenter.
        VMs in the same fault domain share a common power source and network switch.
        If not specified, defaults to 1, which represents ""Max Spreading"" (using as many fault domains as possible).
        This property cannot be updated.",
        SerializedName = @"platformFaultDomainCount",
        PossibleTypes = new [] { typeof(int) })]
        int? ComputeProfilePlatformFaultDomainCount { get; set; }
        /// <summary>
        /// Allocation strategy to follow when determining the VM sizes distribution for Regular VMs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allocation strategy to follow when determining the VM sizes distribution for Regular VMs.",
        SerializedName = @"allocationStrategy",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.RegularPriorityAllocationStrategy) })]
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.RegularPriorityAllocationStrategy? RegularPriorityProfileAllocationStrategy { get; set; }
        /// <summary>Total capacity to achieve. It is currently in terms of number of VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Total capacity to achieve. It is currently in terms of number of VMs.",
        SerializedName = @"capacity",
        PossibleTypes = new [] { typeof(int) })]
        int? RegularPriorityProfileCapacity { get; set; }
        /// <summary>
        /// Minimum capacity to achieve which cannot be updated. If we will not be able to "guarantee" minimum capacity, we will reject
        /// the request in the sync path itself.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Minimum capacity to achieve which cannot be updated. If we will not be able to ""guarantee"" minimum capacity, we will reject the request in the sync path itself.",
        SerializedName = @"minCapacity",
        PossibleTypes = new [] { typeof(int) })]
        int? RegularPriorityProfileMinCapacity { get; set; }
        /// <summary>
        /// Allocation strategy to follow when determining the VM sizes distribution for Spot VMs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allocation strategy to follow when determining the VM sizes distribution for Spot VMs.",
        SerializedName = @"allocationStrategy",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.SpotAllocationStrategy) })]
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.SpotAllocationStrategy? SpotPriorityProfileAllocationStrategy { get; set; }
        /// <summary>Total capacity to achieve. It is currently in terms of number of VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Total capacity to achieve. It is currently in terms of number of VMs.",
        SerializedName = @"capacity",
        PossibleTypes = new [] { typeof(int) })]
        int? SpotPriorityProfileCapacity { get; set; }
        /// <summary>Eviction Policy to follow when evicting Spot VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Eviction Policy to follow when evicting Spot VMs.",
        SerializedName = @"evictionPolicy",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.EvictionPolicy) })]
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.EvictionPolicy? SpotPriorityProfileEvictionPolicy { get; set; }
        /// <summary>
        /// Flag to enable/disable continuous goal seeking for the desired capacity and restoration of evicted Spot VMs.
        /// If maintain is enabled, AzureFleetRP will use all VM sizes in vmSizesProfile to create new VMs (if VMs are evicted deleted)
        /// or update existing VMs with new VM sizes (if VMs are evicted deallocated or failed to allocate due to capacity constraint)
        /// in order to achieve the desired capacity.
        /// Maintain is enabled by default.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Flag to enable/disable continuous goal seeking for the desired capacity and restoration of evicted Spot VMs.
        If maintain is enabled, AzureFleetRP will use all VM sizes in vmSizesProfile to create new VMs (if VMs are evicted deleted)
        or update existing VMs with new VM sizes (if VMs are evicted deallocated or failed to allocate due to capacity constraint) in order to achieve the desired capacity.
        Maintain is enabled by default.",
        SerializedName = @"maintain",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SpotPriorityProfileMaintain { get; set; }
        /// <summary>Price per hour of each Spot VM will never exceed this.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Price per hour of each Spot VM will never exceed this.",
        SerializedName = @"maxPricePerVM",
        PossibleTypes = new [] { typeof(float) })]
        float? SpotPriorityProfileMaxPricePerVM { get; set; }
        /// <summary>
        /// Minimum capacity to achieve which cannot be updated. If we will not be able to "guarantee" minimum capacity, we will reject
        /// the request in the sync path itself.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Minimum capacity to achieve which cannot be updated. If we will not be able to ""guarantee"" minimum capacity, we will reject the request in the sync path itself.",
        SerializedName = @"minCapacity",
        PossibleTypes = new [] { typeof(int) })]
        int? SpotPriorityProfileMinCapacity { get; set; }
        /// <summary>List of VM sizes supported for Compute Fleet</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Fleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of VM sizes supported for Compute Fleet",
        SerializedName = @"vmSizesProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IVMSizeProfile) })]
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IVMSizeProfile[] VMSizesProfile { get; set; }

    }
    /// Details of the Compute Fleet.
    internal partial interface IFleetPropertiesUpdateInternal

    {
        /// <summary>Compute Profile to use for running user's workloads.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IComputeProfileUpdate ComputeProfile { get; set; }
        /// <summary>
        /// Base Virtual Machine Profile Properties to be specified according to "specification/compute/resource-manager/Microsoft.Compute/ComputeRP/stable/{computeApiVersion}/virtualMachineScaleSet.json#/definitions/VirtualMachineScaleSetVMProfile"
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20230901.IVirtualMachineScaleSetVMProfile ComputeProfileBaseVirtualMachineProfile { get; set; }
        /// <summary>
        /// Specifies the Microsoft.Compute API version to use when creating underlying Virtual Machine scale sets and Virtual Machines.
        /// The default value will be the latest supported computeApiVersion by Compute Fleet.
        /// </summary>
        string ComputeProfileComputeApiVersion { get; set; }
        /// <summary>
        /// Specifies the number of fault domains to use when creating the underlying VMSS.
        /// A fault domain is a logical group of hardware within an Azure datacenter.
        /// VMs in the same fault domain share a common power source and network switch.
        /// If not specified, defaults to 1, which represents "Max Spreading" (using as many fault domains as possible).
        /// This property cannot be updated.
        /// </summary>
        int? ComputeProfilePlatformFaultDomainCount { get; set; }
        /// <summary>Configuration Options for Regular instances in Compute Fleet.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IRegularPriorityProfile RegularPriorityProfile { get; set; }
        /// <summary>
        /// Allocation strategy to follow when determining the VM sizes distribution for Regular VMs.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.RegularPriorityAllocationStrategy? RegularPriorityProfileAllocationStrategy { get; set; }
        /// <summary>Total capacity to achieve. It is currently in terms of number of VMs.</summary>
        int? RegularPriorityProfileCapacity { get; set; }
        /// <summary>
        /// Minimum capacity to achieve which cannot be updated. If we will not be able to "guarantee" minimum capacity, we will reject
        /// the request in the sync path itself.
        /// </summary>
        int? RegularPriorityProfileMinCapacity { get; set; }
        /// <summary>Configuration Options for Spot instances in Compute Fleet.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.ISpotPriorityProfile SpotPriorityProfile { get; set; }
        /// <summary>
        /// Allocation strategy to follow when determining the VM sizes distribution for Spot VMs.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.SpotAllocationStrategy? SpotPriorityProfileAllocationStrategy { get; set; }
        /// <summary>Total capacity to achieve. It is currently in terms of number of VMs.</summary>
        int? SpotPriorityProfileCapacity { get; set; }
        /// <summary>Eviction Policy to follow when evicting Spot VMs.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Support.EvictionPolicy? SpotPriorityProfileEvictionPolicy { get; set; }
        /// <summary>
        /// Flag to enable/disable continuous goal seeking for the desired capacity and restoration of evicted Spot VMs.
        /// If maintain is enabled, AzureFleetRP will use all VM sizes in vmSizesProfile to create new VMs (if VMs are evicted deleted)
        /// or update existing VMs with new VM sizes (if VMs are evicted deallocated or failed to allocate due to capacity constraint)
        /// in order to achieve the desired capacity.
        /// Maintain is enabled by default.
        /// </summary>
        bool? SpotPriorityProfileMaintain { get; set; }
        /// <summary>Price per hour of each Spot VM will never exceed this.</summary>
        float? SpotPriorityProfileMaxPricePerVM { get; set; }
        /// <summary>
        /// Minimum capacity to achieve which cannot be updated. If we will not be able to "guarantee" minimum capacity, we will reject
        /// the request in the sync path itself.
        /// </summary>
        int? SpotPriorityProfileMinCapacity { get; set; }
        /// <summary>List of VM sizes supported for Compute Fleet</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Fleet.Models.Api20240501Preview.IVMSizeProfile[] VMSizesProfile { get; set; }

    }
}